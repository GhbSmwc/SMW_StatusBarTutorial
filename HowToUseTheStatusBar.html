<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
		</style>
	</head>





<body onload="Calculate()">
<center><h1>How to use the status bar</h1></center>
<hr>
<p>So you want to edit the HUD to display custom info to the player. Obviously, this requires at least basic ASM knowledge. Fear not! Once you got the pattern down, you'll understand how it works!</p>

<p>You should know these before doing this:</p>
<ul>

<li><p>Ersanio's tutorial<sup><a href="https://www.smwcentral.net/?p=section&a=details&id=15073">[1]</a><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">[2]</a></sup>
on something simple as how to write a value to memory. You should also know about binary and hexidecimal, since many data explained here stored in memory are bitwise (mainly the tile properties).</p></li>

<li><p>Understand the mechanics of <a href="https://www.smwcentral.net/?p=section&a=details&id=19043">Asar</a>, such as defines and labels.</p></li>

</ul>
<hr>
<h2>Javascript tools</h2>
<ul>
	<li>
		<a href="Readme_Files/TileDataAddr.html" id="QuickJSTools_TileDataAddr">S-PPU tile addressing tool</a>
	</li>
	<li>
		<a href="Readme_Files/JS_YXPCCCTT.html" id="QuickJSTools_JS_YXPCCCTT">Quick Hex &harr; Binary converter for YXPCCCTT bit format.</a>
	</li>
	<li>
		<a href="Readme_Files/JS_FrameToTimer.html" id="QuickJSTools_JS_FrameToTimer">Convert 32-bit frame to and from timer format.</a>
	</li>
</ul>
<hr>
<h2>Quick navigation</h2>
<li><a href="#WarmUp" id="WarmUpBack">The warm-up: SMW's status bar.</a></li>
<li><a href="#TileFormat" id="TileFormatBack">Tile data format</a></li>
<li><a href="#SBPatches" id="SBPatchesBack">Other status bar patches</a></li>
<li><a href="#RoutineControl" id="RoutineControlBack">Adding routine-controlled display to the HUD.</a></li>
<ul>
	<li><a href="#DisplayNumbers" id="DisplayNumbersBack">Displaying decimal numbers</a></li>
	<ul>
		<li><a href="#RemoveLeadingZeroes" id="RemoveLeadingZeroesBack">Remove leading zeroes (leading spaces)</a></li>
	</ul>
	<ul>
		<li><a href="#AlignedDigits" id="AlignedDigitsBack">Remove Leading zeros, with left/right-aligned digits</a></li>
		<ul>
			<li><a href="#RightAligned" id="RightAlignedBack">Right aligned display</a></li>
		</ul>
		<li><a href="#IncrementDecrementAnimation" id="IncrementDecrementAnimationBack">Counting animation</a></li>
		<li><a href="#Frames2Timer" id="Frames2TimerBack">Display a timer in Hours:Minutes:Seconds:Centiseconds format</a></li>
		<li><a href="#Percentage" id="PercentageBack">Display a percentage</li>
	</ul>
	<li><a href="#RepeatedSymbol" id="RepeatedSymbolBack">Displaying repeated symbol n times.</a></li>
	<li><a href="#GraphicalBar" id="GraphicalBarBack">Display a graphical bar</a></li>
</ul>
<li><a href="#OverworldBorder" id="OverworldBorderBack">Displaying stuff on the overworld border</a></li>
<li><a href="#OtherNotes" id="OtherNotesBack">Other Notes</a></li>
<hr>
<p>I have provided several routines to make writing codes much user-friendly as possible. So lets begin.</p>
<h2 id="WarmUp"><a href="#WarmUpBack">^</a>The warm-up: SMW's status bar.</h2>
<p>Here, consider looking at this image:<br>
<img src="Readme_Files/StatusBarMap.png"><br>
RAM address <kbd>$7E0EF9-$7E0F2E</kbd> controls what tile to display. How do you modify it? Well you edit the
contents in the mentioned RAM address. There are 2 ways you can edit RAM addresses:
<ul>
<li>Most recommended: a debugger, specifically, <a href="https://www.smwcentral.net/?p=section&a=details&id=21616">Bsnes+</a>. This method applies temporary changes to your game for testing purposes,
it does not actually make &ldquo;permanent&rdquo; changes to your game. To make modifications, be at a level, and on the debugger, go to the menubar on the window, Tools &rightarrow; Debugger.
Now on the Debugger window: &rightarrow; Tools &rightarrow; Memory Editor, and enter on the search bar &ldquo;<kbd>7E0EF9</kbd>&rdquo; (or just &ldquo;<kbd>0EF9</kbd>&rdquo;, if using a SA-1 ROM, its
&ldquo;<kbd>6EF9</kbd>&rdquo;). It should now scroll to that address. From here, type in the hexidecimal number. At the time of making this, the memory editor lacks filtering features like entering a range. However, when you select a byte (a pair of hexidecimal digits), the info bar at the bottom shows what address you are on
to edit:<br>
<img src="Readme_Files/MemoryEditorAddress.png"></li>
<li>Create an ASM file to run under <a href="https://www.smwcentral.net/?p=section&a=details&id=19982">uberasm tool</a> as <kbd>level</kbd> under <kbd>main:</kbd> label, and just use <kbd>LDA #$xx : STA $xxxxxx</kbd>.</li>
</ul>

Now, for the RAM address, each byte is each 8x8 tile, meaning each time you go to the next address, its the next 8x8 tile number:<br>
<input type="radio" name="GameType" id="NormalROM" onclick="Calculate()" checked><label for="NormalROM">Normal game</label><br>
<input type="radio" name="GameType" id="SA1ROM" onclick="Calculate()"><label for="SA1ROM">SA-1</label>
<span id="SMWStatusBarTable"></span><br>
All of these bytes stored in RAM <kbd>$7E0EF9-$7E0F2E</kbd> are <kbd>TTTTTTTT</kbd>, which means you can only modify the tile number through RAM in-game. You may be wondering, if I wanted to edit the tiles here,
what value should I put? Well, <kbd>TTTTTTTT</kbd> is actually <i>what tile number to use</i>, from the tile data. When viewing the tile data stored in <kbd>GFX28</kbd> via <a href="https://www.smwcentral.net/?p=section&a=details&id=15671">YY-CHR</a>,
you can find what tile graphic to use by hovering your mouse over the 8x8 tile you want to use. After this, you should see on the bottom bar of the window showing what tile number that is:<br>
<img src="Readme_Files/TileNumber.png"><br>
Of course, you can view the tile &ldquo;number&rdquo; with bsnes+'s &ldquo;Tile Viewer&rdquo; (Debugger &rightarrow; S-PPU &rightarrow; Tile Viewer), it will only display its <i>tilemap address</i> (bottom bar of window).
I've made a conversion <a id="TileDataAddr" href="Readme_Files/TileDataAddr.html">cheatsheet here</a>.

Now you have the value you need. Just write that desired tile number to any tile number you want to write (either debugger or uberasm, if uberasm tool, you have to save, insert to your game, and run it to view the changes). For example, to write an
item box corner tile on the left of the top row, then it is tile number <kbd>$3A</kbd> to write at <kbd>$7E0EF9</kbd>, if using uberasm tool, its <kbd>LDA #$3A : STA $0EF9|!addr</kbd>.</p>

<p>Now hold up, when you play around with the tiles, many tiles will use the wrong palette, well, this is part of the tile properties (in binary, its <kbd>%YXPCCCTT</kbd>) that's hard-coded, that's right, there are actually 2 bytes of information
for each 8x8 tile with the tile numbers being in ROM and RAM and the properties all being hardcoded. When the level loads, the status bar routine will first transfer default tile number and properties from ROM addresses <kbd>$008C81-$008CFE</kbd>,
which contains all the tiles for the status bar, while the RAM itself only contain some of the tile numbers. To modify hardcoded tiles, I've already presented their addresses that directly correlates to the RAM addresses, for the top and bottom
lines of the item box:
<table>
<tr><th>Coordinate</th><th>Address (%TTTTTTTT, %YXPCCCTT)</th></tr>
<tr><th colspan="2">Top line of item box</th></tr>
<tr><td><kbd>(14,1)</kbd> (<kbd>($E,$1)</kbd>)</td><td><kbd>$008C81</kbd>, <kbd>$008C82</kbd></td></tr>
<tr><td><kbd>(15,1)</kbd> (<kbd>($F,$1)</kbd>)</td><td><kbd>$008C83</kbd>, <kbd>$008C84</kbd></td></tr>
<tr><td><kbd>(16,1)</kbd> (<kbd>($10,$1)</kbd>)</td><td><kbd>$008C85</kbd>, <kbd>$008C86</kbd></td></tr>
<tr><td><kbd>(17,1)</kbd> (<kbd>($11,$1)</kbd>)</td><td><kbd>$008C87</kbd>, <kbd>$008C88</kbd></td></tr>
<tr><th colspan="2">bottom line of item box</th></tr>
<tr><td><kbd>(14,4)</kbd> (<kbd>($E,$4)</kbd>)</td><td><kbd>$008CF7</kbd>, <kbd>$008CF8</kbd></td></tr>
<tr><td><kbd>(15,4)</kbd> (<kbd>($F,$4)</kbd>)</td><td><kbd>$008CF9</kbd>, <kbd>$008CFA</kbd></td></tr>
<tr><td><kbd>(16,4)</kbd> (<kbd>($10,$4)</kbd>)</td><td><kbd>$008CFB</kbd>, <kbd>$008CFC</kbd></td></tr>
<tr><td><kbd>(17,4)</kbd> (<kbd>($11,$4)</kbd>)</td><td><kbd>$008CFD</kbd>, <kbd>$008CFE</kbd></td></tr>
</table>
If you modify these hardcoded values through a debugger, the changes will only apply on the next level reload, since the hardcoded upload only occurs on level load.</p>

<p>You may be wondering, why did I include the tile coordinate in these tables? Well, is because of bsnes+'s ability to display the tile coordinates in the tilemap viewer (Debugger &rightarrow; S-PPU &rightarrow;
Tilemap Viewer, and select &ldquo;3&rdquo; on the BG.):<br>
<img src="Readme_Files/TileCoordinate.png"><br>
and then you can use that coordinate and CTRL+F here on this HTML file to locate what RAM/ROM address to modify, which is way easier than to trial-and-error modifying each address to find the desired location.</p>

<p>I've also provided a patch, <kbd>DefaultTiles.asm</kbd> which is intended to be an ASM patch version of the <a href="https://www.smwcentral.net/?p=section&a=details&id=4580">SMW status bar editor tool</a>.</p>
<hr>
<h2 id="TileFormat"><a href="#TileFormatBack">^</a>Tile data format</h2>
<p>As explained earlier about the palette issue, and that each 8x8 tile possess 2 bytes, I'll give you a summary of the entire tile data:
<ul>
	<li>
		<kbd>TTTTTTTT</kbd> is the tile number (previously explained already), refers to what tile to use from the tile stored in VRAM. Note that this alone is the tile number within a page.
	</li>
	<li>
		<kbd>YXPCCCTT</kbd> is the tile properties:
		<ul>
			<li>
				<kbd>TT</kbd> (ranges from 0-3): Page number. This is technically the upper bits of the tile number, which is why I use the same <kbd>T</kbd> instead
				another letter, therefore 10 bits used for the tile number (referred to as &ldquo;character&rdquo; in the debugger and the SNES dev manuel),
				but we refer the upper 2 bits as the page number, while the lower 8 bits as the tile number (within a page):<br>
				<img src="Readme_Files/PageNumberTT.png">
			</li>
			<li>
				<kbd>CCC</kbd> (ranges from 0-7): Palette number. This refers to what group-4 on the palette to use:<br>
				<img src="Readme_Files/PaletteCCC_0_7.png">
			</li>
			<li>
				<kbd>P</kbd> (0 or 1): Priority (1 is above everything or 0 is behind). Usually these are SET to prevent things (such as sprites,
				layer 1 or layer 2 (including those if they have priority)) from overlapping the HUD.
				For example, the bonus star symbol with and without priority against a cloud tile:<br>
				<img src="Readme_Files/PriorityP.png">
			</li>
			<li>
				<kbd>X</kbd> (0 or 1): X-flip. i.e: <img src="Readme_Files/HorizFlipX.png">
			</li>
			<li>
				<kbd>Y</kbd> (0 or 1): Y-flip. i.e: <img src="Readme_Files/VertiFlipY.png">
			</li>
		</ul>
	</li>
</ul>
I've made a <a href="Readme_Files/JS_YXPCCCTT.html" id="JS_YXPCCCTT">simple converter</a> since most debuggers only allow hex for editing and viewing values.

Now there are 2 formats on how a pair of bytes are being stored. SMW uses both, where default tiles are the &ldquo;2-bytes together&rdquo; format while RAM address <kbd>$7E0EF9-$7E0F2E</kbd>
are &ldquo;TileNumber and Props in their own table&rdquo; format but without the properties.
<table>
<tr>
<th>TileNumber and Props in their own table</th>
<th>2-bytes together</th>
</tr>
<tr>
<td><table><tr><td><pre>!TileNumbAddr: TTTTTTTT (tile 0)
!TileNumbAddr+1: TTTTTTTT (tile 1)
!TileNumbAddr+2: TTTTTTTT (tile 2)
!TileNumbAddr+3: TTTTTTTT (tile 3)
[...]</pre></td></tr></table>
On a separate table:
<table><tr><td><pre>!TilePropAddr: YXPCCCTT (tile 0)
!TilePropAddr+1: YXPCCCTT (tile 1)
!TilePropAddr+2: YXPCCCTT (tile 2)
!TilePropAddr+3: YXPCCCTT (tile 3)
[...]
;I refer this as "[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]"</pre></td></tr></table><br>
Tile numbers and properties are stored in 2 separate tables, one for each.
Every time you advance the next byte, you are on the next 8x8 tile.
</td>

<td><table><tr><td><pre>!TileAddr: TTTTTTTT (tile 0)
!TileAddr+1: YXPCCCTT (tile 0)
!TileAddr+2: TTTTTTTT (tile 1)
!TileAddr+3: YXPCCCTT (tile 1)
!TileAddr+4: TTTTTTTT (tile 2)
!TileAddr+5: YXPCCCTT (tile 2)
!TileAddr+6: TTTTTTTT (tile 3)
!TileAddr+7: YXPCCCTT (tile 3)
[...]

;I call refer this as "[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]"</pre></td></tr></table><br>
Every tile have 2 bytes placed one after another, so both tile numbers and properties are alternating
every byte. Therefore, to get to the next 8x8 tile, is a move of 2 bytes instead of one.

</td>
</tr>
</table>
</p>

<p>I've made a &ldquo;friendly hex-edit&rdquo; patch included in this package called <kbd>DefaultTiles.asm</kbd>, which is an alternative to
<a href="https://www.smwcentral.net/?p=section&a=details&id=4580">Smallhacker's status bar editor patch</a>.</p>

<hr>
<h2 id="SBPatches"><a href="#SBPatchesBack">^</a>Other status bar patches</h2>
<p>Because SMW's status bar is extremely limited, other users decided to make status bar patches:
<ul>
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar</a>. This gives you a 32x5 8x8 tile area,
	therefore 160 8x8 tiles to edit.<sup>1</sup></p></li>
	
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld Border +</a>. Not a &ldquo;status bar&rdquo;, but similar
	in terms of editing the layer 3 8x8 tiles. This gives you 32x<kbd>!TopLines</kbd> (for the top of the screen) and 32x<kbd>!BottomLines</kbd> (for the bottom of the screen)
	8x8 tile area, therefore, up to 224 8x8 tiles you can edit.<sup>1</sup> <kbd>!TopLines</kbd> is how many lines for the top of the screen, an integer 0-5.
	<kbd>!BottomLines</kbd> is same as previously mentioned, but for the bottom of the screen being an integer 0-2.</p></li>
	
<li><p><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>'s status bar patches<sup>2</sup></p></li>
	<ul>
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21562">Minimalist Status Bars</a>. This shrinks your status bar to 1 or
		2 lines of 8x8 tiles. Therefore, 32 or 64 tiles you can edit.</p></li>
		
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3 Status Bar</a>. True to the name, this replaces SMW's HUD with
		SMB3's HUD on the bottom of the screen. This gives you a 32x4 8x8 tile area, therefore 128 8x8 tiles to edit</p></li>
	</ul>
</ul>

<p>You may be wondering:
<ul>
<li><sup>1</sup>Uses the &ldquo;2-bytes together&rdquo; format, the <kbd>[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]</kbd></li>
<li><sup>2</sup>Uses the &ldquo;TileNumber and Props in their own table&rdquo; format, the <kbd>[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]</kbd></li>
</ul>
Therefore, many ASM patches that display on the status bar that I made are hybrid-support of these two formats. The define <kbd>!StatusbarFormat</kbd> is what
you need to edit to work with other status bar patches, set it to <kbd>$01</kbd> if &ldquo;TileNumber and Props in their own table&rdquo; otherwise set it to
<kbd>$02</kbd>. In case if you are wondering why there are duplicate routines (<abbr title="For &ldquo;TileNumber and Props in their own table">a normal version</abbr> and <abbr title="For &ldquo;2-bytes together&rdquo;">a version with &ldquo;Format2&rdquo; appended to the end of
the subroutine label</abbr>) in the ASM files is because in case if you are designing a hack that have the status bar patch using the &ldquo;TileNumber and Props in
their own table&rdquo; format and the overworld border plus patch, which your hack is now using BOTH formats.</p>

<p>Thankfully, I made HTML Javascript files for all of these ASM resources to enable you to search what RAM address of a given tile.</p>

</p>
<hr>
<h2 id="RoutineControl"><a href="#RoutineControlBack">^</a>Adding routine-controlled display to the HUD.</h2>
<p>This method assumes you are using uberasm tool to test your code to write to the status bar. The first thing you want to do is have all the ASM files in &ldquo;<kbd>StatusBarRoutines</kbd>&rdquo;
inserted into uberasm tool's &ldquo;<kbd>library</kbd>&rdquo; folder, and have the entire folder &ldquo;<kbd>StatusBarRoutinesDefines</kbd>&rdquo; be in the same directory as the uberasm tool exe program is at.</p>

<p>Feel free to look into the library ASM files, since I added descriptions and comments to give a better understanding how they work.</p>

<p>NOTE: most codes provided here do not modify the tile properties in any way, since very unlikely that many hacks would ever modify the tile properties. If you happen to have a display to &ldquo;overlap&rdquo; and
is using different tile properties, upon switching back to the old display may cause the old display to use the YXPCCCTT data of the new display over it. You can simply fix that by reverting the YXPCCCTT.</p>

<p>You also need to insert the graphic file from this provided <kbd>ExGFX</kbd> folder (<kbd>ExGFX80.bin</kbd>) if you are wanting to test out the code of displaying the &ldquo;/&rdquo; symbol when displaying
2 numbers. It should be inserted as &ldquo;LG1&rdquo; on the layer 3 GFX.</p>

<p>Before we start using the subroutines, we will demonstrate how to write tiles that change based on a given info <kbd>!RAMToMeasure</kbd>. It's very easy to write a tile that is different depending on
a condition using branches:
<table><tr><td><pre>!StatusBarPosition = $0EF9|!addr
!RAMToMeasure = $60
	main:
	LDA !RAMToMeasure
	BEQ +
	LDA #$00
	BRA ++
	+
	LDA #$01
	++
	STA !StatusBarPosition
	RTL</pre></td></tr></table><br>
and if you are tired of using branches, then an even simpler approach is to use tables:
<table><tr><td><pre>!StatusBarPosition = $0EF9|!addr
!RAMToMeasure = $60
	main:
	LDA !RAMToMeasure
	TAX
	LDA Table,x
	STA !StatusBarPosition
	RTL
	
	Table:
	db $xx ;&gt;When !RAMToMeasure = $00
	db $xx ;&gt;When !RAMToMeasure = $01
	db $xx ;&gt;When !RAMToMeasure = $02</pre></td></tr></table></p>
	
<p>But what about other not-so-simple displays? Well, the following shows you how to do that.</p>

<h3 id="DisplayNumbers"><a href="#DisplayNumbersBack">^</a>Displaying decimal numbers</h3>

<p>To display a single digit, just store the value directly to the tile RAM. Digits are correctly displayed if the value is 0-9. Any above that will display more than just digits.</p>

<p>But how do you display multi-digits on the status bar? Well, you use a subroutine that would wrap each digits just like how our real-world decimal number works
(ones place reset every 10s, 10s increases every 100th value, and the 1000s resets every 10000s, and so on). The routine, <kbd>HexDec</kbd> converts a given number to
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal (BCD, unpacked)</a> to write each digit tiles onto the status bar. Thankfully,
the status bar graphic tiles on GFX28 starts with digits 0-9 so you don't have to convert digit numbers to digit graphics.</p>

<p>Do note that all subroutines here will always have leading zeroes stored (either as in the registers for 2-3 digits or as an array of digits for 4+ digit displays) when there are fewer
digits than the maximum. If you wanted to remove leading zeroes, I will explain that in the next section.</p>

<p>For the overworld border (<abbr title="So far, there isn't any other patches that lets you edit the overworld border similarly to the status bar.">assuming you're using the Overworld Border+ patch</abbr>),
which is stored in <kbd>GFX2A</kbd>, after calling the HexDec routine, you must add each digit by #$22 (<a href="Readme_Files/OWB_Digits.png" target="_blank">digit graphics are stored as tile numbers $22-$2B</a>),
and make sure you are using page 1 and not 0 on the tile properties (example, to display the number &ldquo;<font color="red">1</font><font color="blue">2</font>&rdquo;, the values must be <kbd><font color="red">$01</font>+$22 = $23</kbd>
for the tens and <kbd><font color="blue">$02</font>+$22 = $24</kbd> for the ones). I'll later explain how to display digits on the overworld border later on this document.</p>


<p>Create a text file, name it <kbd>StatusBarTest.asm</kbd>. Edit that text file to include this code:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	STA !StatusBarPosition				;&gt;Write 10s place
	RTL
</pre></td></tr></table></p>

<p>Now save, and insert in either as gamemode under number 14 (level), or level. Then run the tool to apply the changes.</p>

<p>Test the game (using a debugger, bsnes+) by going to the level that you inserted this created ASM file (or any level if using gamemode 14), you should see the
digits displayed on the HUD. Again, palettes, X/Y flips and other weird shenanigans can happen if you use SMW's vanilla status bar without
editing the default values. Now depending on what RAM to use set by <kbd>!RAMToMeasure</kbd>, it could display <kbd>00</kbd> or <kbd>[&lt;digits 0-9 or glitched tile here&gt;&lt;digits 0-9&gt;]</kbd>,
then on the debugger window, go to memory editor and search for the RAM you set for <kbd>!RAMToMeasure</kbd> (example: 60), edit the value in that byte to be any values $00-$63. It should
display their decimal version of the hex number:
<table>
<tr><th>Hex bytes</th><th>Displayed</th></tr>
<tr><td>$09</td><td>09</td></tr>
<tr><td>$0A</td><td>10</td></tr>
<tr><td>$0B</td><td>11</td></tr>
<tr><td colspan="2">...</td></tr>
<tr><td>$61</td><td>97</td></tr>
<tr><td>$62</td><td>98</td></tr>
<tr><td>$63</td><td>99</td></tr>
<tr><td bgcolor="red">$64</td><td bgcolor="red">A0</td></tr>
<tr><td bgcolor="red">$65</td><td bgcolor="red">A1</td></tr>
<tr><td bgcolor="red">$66</td><td bgcolor="red">A2</td></tr>
<tr><td colspan="2" bgcolor="red">(10s place digit cycles through the alphabet characters every 10th value until...)</td></tr>
<tr><td bgcolor="red">$FF</td><td bgcolor="red">P5</td></tr>
</table>
What happens if you enter numbers greater than $63? Well, when the routine is used like that, it is designed to display up to 2 digits. If the number is greater than $64, the 10s place digit start showing graphics
other than digits. This is because of how the routine works, is that the 10s place digit wasn't wrapped (wrapped, as in digits reset to 0 when going past 9: 8, 9, 0, 1 , 2...), so it can display
&ldquo;digits&rdquo; greater than 9 (98, 99, A0, A1, A2...).</p>

<p>You can fix this problem and make it allow the full range of the 8-bit value by after writing the ones digit, TXA, then call the routine again, and after that, A is the 10s, and X is the 100s place:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;Call again to get the 10s and 100s.
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 10s place
	TXA						;&gt;STX $xxxxxx don't exists.
	STA !StatusBarPosition				;&gt; Write 100s place
	RTL
</pre></td></tr></table><br>
The reason why this works is because A is the modulo result of A/10 of the input. Modulo is the division remainder and wraps a number
into a range of <kbd>0</kbd> to <kbd>Divisor-1</kbd> (in this case, 0-9). This is the same as repeated subtraction until the number cannot be subtracted any more (without going into the negatives).
To handle the higher digits, the loop also counts every successful subtractions by 10, which is how X increases every 10th value. When handling the 100s digit, you
basically divided the value by 10 again, which is <kbd>!RAMToMeasure/10/10</kbd>, which is the same as <kbd>!RAMToMeasure/(10^2)</kbd> which leads to <kbd>!RAMToMeasure/100</kbd>,
resulting A now being the 10s place wrapping every 100 and X increasing every 100. Because the maximum value stored in an 8-bit byte is 255, there is no way the hundreds place digit
will be able to glitch out at 1000. For more information how base conversion works, I found a wikipedia article on positional notation
<a href="https://en.wikipedia.org/wiki/Positional_notation#Base_conversion">on converting radixes</a>.</p>

<p id="Left2RightHexDec">Do note that this method have a cost: The higher the number to convert to BCD, the more subtractions by 10<sup>1 &rightarrow; (NumberOfDigits-1)</sup> it would take to get all the
digits outputted, not really harsh since this is 8-bit, so up to 25 iterations for a 2-digit (plus up to 2 more for 10s and 100s by calling the HexDec routine again). However, if you
DO want speed, do this instead. This works from left-to-right by repeatedly subtracting 100 until A is 0-99. The number of subtractions is now how many 100s for the 100s digit, after
that, with A being 0-99, we do the same but with 10s (how many 10s) instead of 100s to find how many 10s. After that, A is 0-9 which is already the ones place:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits		;&gt;Obtain 3 digits in A, X and Y.
	STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	TYA						;\Write 100s place.
	STA !StatusBarPosition				;/
	RTL
</pre></td></tr></table></p>

<p>What about if I wanted to convert 16-bit numbers (or if you have 3-4 digits and want to go above 255)? Well, good news for you, I've provided more than just 8-bit HexDec
converters. Here is the code in question (up to 65535). Example, RAM $60 contains the value <kbd>$1234</kbd> (in memory, its <kbd>$34, $12</kbd>), I write my 16-bit number to address
<kbd>$00-$01</kbd>, then call the subroutine <kbd>SixteenBitHexDecDivision</kbd> after that, the digits of 4660 are stored. Note that this is ordered in decreasing significant decimal digits
(<abbr title="!Scratchram_16bitHexDecOutput+4">last</abbr> byte = 1s, second-last = 10s...):
<table>
<tr><th>Define relative address</th><th>RAM address (normal/Sa-1)</th><th>Output value</th></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+0</kbd></td><td><kbd>$02/$04</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 10000s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+1</kbd></td><td><kbd>$03/$05</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+2</kbd></td><td><kbd>$04/$06</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 100s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+3</kbd></td><td><kbd>$05/$07</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 10s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+4</kbd></td><td><kbd>$06/$08</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; 1s place)</td></tr>
</table><br>
As a side note, all &ldquo;bigger number&rdquo; (handles more bytes to handle larger values) hexdec subroutines can work with &ldquo;smaller numbers&rdquo; (less bytes) hexdec subroutines by masking out
the higher byte(s). For example: using a 16-bit hexdec, an 8-bit number #$FF, when supplied into the input, you then zero out the high byte (<kbd>STZ $01</kbd>) so that it treats the value as #$00FF.

Here is the code in question for you to test:</p>
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar
!NumberOfDigitsDisplayed = 5		;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	REP #$20
	LDA !RAMToMeasure		;\Submit the value into $00-$01, the input to convert the raw binary value into BCD, unpacked.
	STA $00				;/
	SEP #$20
	JSL HexDec_SixteenBitHexDecDivision
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBarPosition,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w (!Scratchram_16bitHexDecOutput)+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBarPosition,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></td></tr></table><br>
	
	<p>Greater than 65535? (unlikely for other stuff besides a huge currency counter or custom score). This one is a 32-bit HexDec, up to
	4,294,967,295 ($FFFFFFFF) can be properly displayed. Remember, this is little endian, for example: a number
	<abbr title="287454020 in decimal">$11223344</abbr> must be inputted as
	<kbd>[$44, $33, $22, $11]</kbd> into <kbd>$00-$03</kbd> and should output as <kbd>[$02, $08, $07, $04, $05, $04, $00, $02, $00]</kbd> in
	<kbd>!Scratchram_32bitHexDecOutput</kbd>.<br>
	
	Here is an example using the previously mentioned number, with <kbd>!MaxNumberOfDigits</kbd> set to <kbd>9</kbd>, using default <kbd>!Scratchram_32bitHexDecOutput</kbd>.
	Again, the digits stored in each bytes are ordered in decreasing significant decimal digits (<abbr title="!Scratchram_32bitHexDecOutput+(!MaxNumberOfDigits-1)">last byte</abbr> is always
	the 1s place, regardless of <kbd>!MaxNumberOfDigits</kbd>'s value)
	<table>
	<tr><th>Define relative address</th><th>Default RAM address (normal/Sa-1)</th><th>Output value</th></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+0</kbd></td><td><kbd>$7F844E/$40019C</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 100000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+1</kbd></td><td><kbd>$7F844F/$40019D</kbd></td><td><kbd>$08</kbd> (represents &ldquo;8&rdquo; for 10000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+2</kbd></td><td><kbd>$7F8450/$40019E</kbd></td><td><kbd>$07</kbd> (represents &ldquo;7&rdquo; for 1000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+3</kbd></td><td><kbd>$7F8451/$40019F</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 100000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+4</kbd></td><td><kbd>$7F8452/$4001A0</kbd></td><td><kbd>$05</kbd> (represents &ldquo;5&rdquo; for 10000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+5</kbd></td><td><kbd>$7F8453/$4001A1</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+6</kbd></td><td><kbd>$7F8454/$4001A2</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 100s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+7</kbd></td><td><kbd>$7F8455/$4001A3</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 10s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+8</kbd></td><td><kbd>$7F8456/$4001A4</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 1s)</td></tr>
	
	</table><br>
	
	Code in question:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0F09|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;>How many digits, enter 1-10 (pointless if you enter less than 5).

	;Don't change this.
		if defined("sa1") == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif
	main:
	REP #$20
	LDA $60			;\Low word (example: $3344 -> [$44, $33] in $00, $01)
	STA $00			;/
	LDA $62			;\High word (example: $1122 -> [$22, $11] in $02, $03)
	STA $02			;/
	SEP #$20
	JSL HexDec_Convert32bitIntegerToDecDigits	;>Should Output example as: [$02, $08, $07, $04, $05, $04, $00, $02, $00] on !Scratchram_32bitHexDecOutput.
	
	;Write to status bar:
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA !Scratchram_32bitHexDecOutput+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBarPosition,x
			DEX
			BPL -
		else
			LDX #((!NumberOfDigitsDisplayed-1)*2)
			LDY #(!NumberOfDigitsDisplayed-1)
			-
			PHX
			TYX												;&gt;Sigh, LDA $xxxxxx,y does not exist.
			LDA (!Scratchram_32bitHexDecOutput)+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1)|!dp,x
			PLX
			STA !StatusBarPosition,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></td></tr></table><br>
	
Don't ask me to make an even larger number display, because not many games would ever display 10 digits at once, plus, it takes up space on the HUD.</p>

<p>Also note that <kbd>!NumberOfDigitsDisplayed</kbd> and <kbd>!MaxNumberOfDigits</kbd> are different. <kbd>!NumberOfDigitsDisplayed</kbd> refers to only the low (rightmost digits) n digits being
displayed, while <kbd>!MaxNumberOfDigits</kbd> is the fixed number of digits (uses leading zeroes if fewer digits) stored in the digit table (you can set this to a
<abbr title="If you have multiple number displays and they are using the 32-bit HexDec each with different maximums (example: 99,999 and 999,999), then set !MaxNumberOfDigits to whatever number using this routine uses the most digits
(in this case, 6, not 5).">lower number to save space</abbr>).
Having both in case if you want to only display up to n digits less than the routine can output. For example, a counter to display 6 digits, 0-999999. You wouldn't want display
unused digits always showing 0 on the millions (1000000s) and beyond (so don't display &ldquo;0000999999&rdquo;, those first 4 digits are always 0 and therefore redundant).</p>

<h4 id="RemoveLeadingZeroes"><a href="#RemoveLeadingZeroesBack">^</a>Removing leading zeroes (leading spaces)</h4>
	<p>I've also provided routines that removes leading zeroes by simply replacing the first n digits with tile $FC in the digits table (I call this &ldquo;leading spaces&rdquo;). After calling the the JSL routines to convert them into decimal
	digits, you then call <kbd>RemoveLeadingZeroes16Bit</kbd> or <kbd>RemoveLeadingZeroes32Bit</kbd> before writing to the status bar. Make sure you match the 16 and 32 bits. For the 8-bit versions,
	a routine isn't necessary:
	<ul>
		<li>For 2-digit numbers, just replace the 10s place digit with tile #$FC if it is 0:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	BNE .NotLeadingZero
	
	.LeadingZero
	LDA #$FC					;&gt;Blank tile
	
	.NotLeadingZero
	STA !StatusBarPosition				;&gt;Write 10s place
	RTL</pre></td></tr></table>
		</li>
		<li>For 3-digit numbers, use this code template:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits		;>Obtain 3 digits in A, X and Y.
	STA !StatusBarPosition+(2*!StatusbarFormat)	;>Write 1s place
	
	.HandleHundreds
	CPY #$00					;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
	BNE ..HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
	
	..NoHundreds
	LDY #!StatusBarBlankTile			;\Erase the 100s digit
	TYA						;|
	STA !StatusBarPosition				;/
	BRA .HandleTens					;>Check if the next digit is also part of the leading zero.
	
	..HundredsNonZero
	TYA
	STA !StatusBarPosition				;>Write 100s place
	BRA .HandleTens_WriteTens			;>If at least 100, 10s shouldn't be omitted.
	
	.HandleTens
	CPX #$00					;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
	BNE ..WriteTens					;/No, then erase the 10s.
	
	..NoTens
	LDX #!StatusBarBlankTile			;>If 0, replace 10s digit with blank.
	
	..WriteTens
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	
	.Done
	RTL</pre></td></tr></table></li>
	</ul>
	</p>
<h3 id="AlignedDigits"><a href="#AlignedDigitsBack">^</a>Remove Leading zeros, with left/right-aligned digits</h3>
<p>Perhaps, in actuality, leading zeros are replaced with leading spaces, giving a <i>right-aligned</i> look. If you are designing a HUD
with an icon (or a &ldquo;label&rdquo;) to the left of the number when the number have a small number of digits, you'll have a space in between the icon and the digits, which looks ugly, especially if the number
have a huge number of digits it can display up to. Or, if you wanted the number display to look more compact. For example, a 5-digit, 16-bit number:<br>
<img src="Readme_Files/LeadingSpaces.png"><br><br>
The first routine, <kbd>SupressLeadingZeros</kbd> works like this: Search all the digits in <kbd>!Scratchram_16bitHexDecOutput</kbd>, and copy all the non-leading zero digits on and after the first (leftmost) digit and paste them into
<kbd>!Scratchram_CharacterTileTable</kbd>. You've now have a &ldquo;compressed string&rdquo; table stored. After this routine, The X register now contains a number incremented for every character being written.
See picture below:<br>
<img src="Readme_Files/NoLeadingZeroesLeftAligned.png"><br>
When written to the status bar:<br>
<img src="Readme_Files/StatusBarStringTransfer.png">
</p>
<p>To use the routine, here is the code template:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar
!NumberOfDigitsDisplayed = 5		;>How many digits, enter 1-5 (pointless if you enter less than 3).
!StatusBarPositionProps = $7FA001	;>Same as above but tile props (when enabled).
!DigitProps = %00111000			;>Properties of the digits (when enabled).


incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90"). Also setup tile properties when enabled.
		LDX.b #(!NumberOfDigitsDisplayed-1)*!StatusbarFormat
		-
		LDA #!StatusBarBlankTile
		STA !StatusBarPosition,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!DigitProps
			STA !StatusBarPositionProps,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;Number to string.
		;Process HexDec
			REP #$20					;\Convert a given number to decimal digits.
			LDA !RAMToMeasure				;|
			STA $00						;|
			SEP #$20					;|
			JSL HexDec_SixteenBitHexDecDivision		;/
		;Remove leading zeroes and have it as a character table
			LDX #$00					;>Start at character position 0.
			JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
		;Prevent writing too much characters.
			CPX.b #!NumberOfDigitsDisplayed+1		;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits				;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBarPosition : STA $00
		LDA.b #!StatusBarPosition>>8 : STA $01
		LDA.b #!StatusBarPosition>>16 : STA $02
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></td></tr></table><br>
But what if I wanted to display 2 numbers &ldquo;X/Y&rdquo; (for example: &ldquo;260/300&rdquo;)? Well, you just have the codes be (loosely) called twice under &ldquo;<kbd>Number to string</kbd>&rdquo; but like this instead:
<ol>
	<li>
		<p>The number of tiles to clear uses <kbd>LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat</kbd>, 2 numbers, plus 1 (because of the &ldquo;/&rdquo; symbol), minus 1 (because indexing ranges from 0 to
		<kbd>NumberOfItems-1</kbd>), its then multiplied by 1 or 2 to adjust the status bar data formatting.</p>
	</li>
	<li>
		<p>You have codes <kbd>Process HexDec</kbd> and <kbd>Remove leading zeroes and have it as a character table</kbd> be the same for the first number (using previous example, the 260). We will not use the failsafe
		of too many digits until after we write the second number.</p>
	</li>
	<li>
		<p>After writing the first number, you then write a character that will be in between the 2 numbers (in this case, the &ldquo;/&rdquo; symbol), after this, you <kbd>INX</kbd> so you will place the second
		number after it.</p>
	</li>
	<li>
		<p>You do the same thing as the first number, but use <kbd>PHX</kbd>, then the code that uses HexDec, without <kbd>LDX #$00</kbd>, then <kbd>PLX</kbd>, because X needs to continue counting the characters, and that HexDec routine modifies
		this to handle each of the 5 digits. After this, then you DO need that failsafe, using <kbd>CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)</kbd>, 2 numbers, plus 1 for the &ldquo;/&rdquo; symbol, plus 1 AGAIN because BCS branches if
		<kbd>X &ge; ComparedValue</kbd></p>
	</li>
</ol>
Here is an example using 2 16-bit numbers:
<table><tr><td><pre>
!RAMToMeasure = $60			;>RAM address you what to show
!RAMToMeasure2 = $62			;>Same as above
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar
!NumberOfDigitsDisplayed = 5		;>How many digits, enter 1-5 (pointless if you enter less than 3).
!StatusBarPositionProps = $7FA001	;>Same as above but tile props (when enabled).
!DigitProps = %00111000			;>Properties of the digits (when enabled).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;>2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBarPosition,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!DigitProps
			STA !StatusBarPositionProps,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20					;\Convert a given number to decimal digits.
			LDA !RAMToMeasure				;|
			STA $00						;|
			SEP #$20					;|
			JSL HexDec_SixteenBitHexDecDivision		;/
		;Remove leading zeroes and have it as a character table
			LDX #$00					;>Start at character position 0.
			JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x		;/
			INX						;>Next character position.
	;Second number
		;Process HexDec
			PHX						;>Push X because it gets modified by the HexDec routine.
			REP #$20					;\Convert a given number to decimal digits.
			LDA !RAMToMeasure2				;|
			STA $00						;|
			SEP #$20					;|
			JSL HexDec_SixteenBitHexDecDivision		;/
			PLX						;>Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
		;Prevent writing too much characters.
			CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)	;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits				;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBarPosition : STA $00		;\Set address to write at a given status bar position.
		LDA.b #!StatusBarPosition>>8 : STA $01		;|
		LDA.b #!StatusBarPosition>>16 : STA $02		;/
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></td></tr></table><br>
Again, use the debugger if you wanted to test the values using the memory editor and editing the RAM address defined by <kbd>!RAMToMeasure</kbd>, and this time, also <kbd>!RAMToMeasure2</kbd>.</p>

<h4 id="RightAligned"><a href="#RightAlignedBack">^</a>Right aligned display</h3>

<p>But what about right-aligned number display? First things first, if you are displaying a single number, this routine isn't necessary as calling the HexDec routines and replacing leading zeroes with leading spaces
is automatically right-aligned, therefore only use this routines if you are displaying X/Y. Here is how you do it: After checking if there are too many characters, you then store the RAM address of the <i>rightmost tile position</i> into $00-$02 (little endian),
call <kbd>HexDec_ConvertToRightAligned</kbd> (<kbd>HexDec_ConvertToRightAlignedFormat2</kbd> if using the [TTTTTTTT, YXPCCCTT] format), which will modify the position of where to write the digits based on how long the string are
(loop-writes are based on the starting byte of an array, not the last) by taking the position, subtract by the number of characters minus 1 tile, then that is the leftmost tile position, then call the
routine to write to the HUD:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!RAMToMeasure2 = $62			;>Same as above
!StatusBarPosition = $7FA03E		;>Where to write on the status bar. NOTE: This is now the position of the rightmost/last tile (tiles will be written here and before it).
!NumberOfDigitsDisplayed = 5		;>How many digits, enter 1-5 (pointless if you enter less than 3).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;>2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBarPosition-((((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat),x
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20					;\Convert a given number to decimal digits.
			LDA !RAMToMeasure				;|
			STA $00						;|
			SEP #$20					;|
			JSL HexDec_SixteenBitHexDecDivision		;/
		;Remove leading zeroes and have it as a character table
			LDX #$00					;>Start at character position 0.
			JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x		;/
			INX						;>Next character position.
	;Second number
		;Process HexDec
			PHX						;>Push X because it gets modified by the HexDec routine.
			REP #$20					;\Convert a given number to decimal digits.
			LDA !RAMToMeasure2				;|
			STA $00						;|
			SEP #$20					;|
			JSL HexDec_SixteenBitHexDecDivision		;/
			PLX						;>Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
	;Prevent writing too much characters.
		CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)	;\Failsafe to avoid writing more characters than intended would write onto tiles
		BCS ..TooMuchDigits				;/not being cleared from the previous code.
	;Calculate where to write for right-aligned 2-number display
		LDA.b #!StatusBarPosition : STA $00		;\Set address to write at a given status bar position.
		LDA.b #!StatusBarPosition>>8 : STA $01		;|
		LDA.b #!StatusBarPosition>>16 : STA $02		;/
		if !StatusbarFormat == $01				;\These offset the write position based on how many
			JSL HexDec_ConvertToRightAligned		;|characters so that it is right-aligned.
		else
			JSL HexDec_ConvertToRightAlignedFormat2		;|$00-$02 will now contain where is the leftmost tile.
		endif							;/
	;Write to status bar
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></td></tr></table>It should result like this:<br>
	<img src="Readme_Files/RightAligned2Numbers.png"></p>
	
<h3 id="IncrementDecrementAnimation"><a href="#IncrementDecrementAnimationBack">^</a>Counting animation</h3>
<p>In many video games, when a number is displayed on the HUD and is added or subtracted by another value (that is greater than 1), the number will gradually increase or decrease,
then stops, instead of instantly displaying the new result value. SMW does have that with the bonus stars and score when completing the level. SMW also does this with the coins,
but most of the time increment by 1 in the main game (an unused flying red coin, sprite $7E increments by 5). This is done by using $13CC as an &ldquo;adder&rdquo;, for every
value in this RAM, increments the coin count, and decreases itself once per frame. See this code here from its code:
<table><tr><td><pre>CODE_008F1D:        AD CC 13      LDA.W $13CC               ; \ If Coin increase isn't x00, 
CODE_008F20:        F0 19         BEQ CODE_008F3B           ; / branch to $8F3B 
CODE_008F22:        CE CC 13      DEC.W $13CC               ; Decrease "Coin increase" 
CODE_008F25:        EE BF 0D      INC.W RAM_StatusCoins     ; Increase coins by 1 </pre></td></tr></table>

There are two types of increment animation:
<ul>
	<li><p><b>Actual amount counting:</b> Your actual value is gradually counting, for example:
	SMW's coin is an example of this, if you were to check the player's coin count
	(<kbd>LDA $0DBF : CMP #$XX : &lt;BEQ/BNE/BCC/BCS&gt;</kbd>) while it's counting,
	it will take the current value instead of the added total value. You also don't
	write towards the actual counter directly, you just write how much to add to the adder.</p></li>
	
	<li><p><b>Mere display counting:</b> A number displayed on the HUD does the
	counting animation (therefore, the display uses the gradual-counting) upwards
	or downwards towards the actual value (the actual amount can instantly change,
	while the display counts gradually). This is done by have 2 numbers stored in
	memory: one for display that counts gradually and the other that can add and
	subtract &ldquo;instantly&rdquo; which that is the actual amount. Here, you have
	more control, you can write any value towards the actual amount, and the counting animation
	will play, even when you set it to a specific value (no adding/subtracting).</p></li>
</ul>
I usually call this a &ldquo;record effect&rdquo; on my older ASM works, but this sounds kinda misleading, Here is the example code:
<table>
<tr><th>Actual amount counting</th><th>Mere display counting</th></tr>
<tr>
<td>
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address of the actual number
!Freeram_Adder = $62			;>RAM address that adds to !RAMToMeasure
!Freeram_Subtractor = $0DC3		;>RAM address that subtracts to !RAMToMeasure
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.Adder
	LDA !Freeram_Adder
	BEQ ..Done
	
	..Increment
	DEC			;\Decrement on every step (frame)
	STA !Freeram_Adder	;|for every adder value.
	LDA !RAMToMeasure	;|
	CMP #$FF
	BEQ ..Cancel
	INC			;|
	STA !RAMToMeasure	;/
	BRA ..Done
	
	..Cancel
	;Prevent overflow. Note: Merely capping the number by writing to !RAMToMeasure will not cancel
	;how much remaining to add, so if you happen to hit this maximum, while the adder is nonzero,
	;then set !RAMToMeasure to a lower value, it will still increase from that lower value. Same
	;thing applies to subtraction when it bottoms out at 0 with !Freeram_Subtractor being nonzero
	;when !RAMToMeasure is > 0.
		LDA #$00		;>STZ $xxxxxx does not exist.
		STA !Freeram_Adder
	..Done
	
	.Subtracter
	LDA !Freeram_Subtractor
	BEQ ..Done
	
	..Decrement
	DEC
	STA !Freeram_Subtractor
	LDA !RAMToMeasure
	BEQ ..Cancel
	DEC
	STA !RAMToMeasure
	BRA ..Done
	
	..Cancel
	;Prevent underflow
		LDA #$00
		STA !Freeram_Subtractor
	..Done

	.DisplayStatusBar
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits
	STA !StatusBarPosition+(2*!StatusbarFormat)	;>Write 1s place
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	TYA						;\Write 100s place.
	STA !StatusBarPosition				;/
	RTL
	;Also note that if you have both adder and subtractor nonzero, they will cancel
	;each other out as both will increase and decrease together (results !RAMToMeasure
	;will stay the same), until one or the other is zero and starts adding or subtracting,
	;whatever is greater. For example, Adder is 30 and Subtracter is 5, results 5 frames
	;of no change, then increments by 1 25 times.</pre></td></tr></table>
Note that if you want to stack values (say you want to add by 30 twice individually), it is a better idea to not set <kbd>!Freeram_Adder</kbd> to <kbd>#$1E</kbd>, rather to
take <kbd>!Freeram_Adder</kbd>, then add <kbd>CLC : ADC.b &lt;AdderAmount&gt;</kbd>, and then write back to <kbd>!Freeram_Adder</kbd>, otherwise it will not add properly (the second increase amount would be
<kbd>SetToAmount - AdderAmountLeft</kbd> instead where in this example that <kbd>SetToAmount = 30</kbd> and <kbd>AdderAmountLeft</kbd> is the current amount to add up to <kbd>!RAMToMeasure</kbd>).
</td>
<td>
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address of the actual number
!RAMToMeasure2 = $62			;>RAM address of the displayed amount
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.CountingAnimation
	LDA !RAMToMeasure2
	CMP !RAMToMeasure
	BEQ ..NoChange
	BCC ..LessThan
	
	..GreaterThan
	LDA !RAMToMeasure2
	DEC
	BRA ..Write
	
	..LessThan
	LDA !RAMToMeasure2
	INC
	
	..Write
	STA !RAMToMeasure2
	
	..NoChange
	
	.DisplayStatusBar
	LDA !RAMToMeasure2
	JSL HexDec_EightBitHexDec3Digits
	STA !StatusBarPosition+(2*!StatusbarFormat)	;>Write 1s place
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	TYA						;\Write 100s place.
	STA !StatusBarPosition				;/
	RTL
</pre></td></tr></table><br>
If you want the counter to count even slower instead of once per frame, under the sublabel
<kbd>.CountingAnimation</kbd>, and before the first <kbd>LDA</kbd> add this code:
<table><tr><td><pre>	LDA $13
	AND.b #%00000011
	BNE ..NoChange</pre></td></tr></table><br>
The AND values must be powers of 2, minus 1 (value_for_AND = (2^n)-1) where n is how much delay, in powers of 2 of frames.
What will happen is that the number will change by 1 every 2<sup>n</sup> frames. If you want the display to freeze when $9D is set, use this code instead:
<table><tr><td><pre>	LDA $9D
	ORA $13D4|!addr
	BNE ..NoChange

	LDA $14
	AND.b #%00000011		;>Again, this is value_for_AND = (2^n)-1 where n is powers of 2 delay.
	BNE ..NoChange
</pre></td></tr></table>
</td>
</tr>
</table>
Note that there are a major drawback:
<ul>
<li><p>If the amount adds or subtract by a very large value, the counting animation will take a very long time to finally display the final amount.</p></li>
<li><p>Make sure when you do things that would &ldquo;clear memory&rdquo; (or simply &rdquo;reset/initialize values&rdquo;) such as going to another level, make sure when using &ldquo;Actual amount counting&rdquo;, not to have the
adder/subtractor be reset during transitions, otherwise the amount change gets cut off, unless you want something similar to earthbound's &ldquo;rolling HP&rdquo; system which can interrupt
the counting. You can make this &ldquo;skip the animation&rdquo; by taking the current value, and add by the remaing values to be added (like taking the coin counter (<kbd>$0DBF</kbd>), add <kbd>CLC : ADC</kbd> by <kbd>$13CC</kbd>,
and then store the total back to <kbd>$0DBF</kbd>).</p></li>
</ul>
</p>
For the &ldquo;Mere display counting&rdquo; you can alleviate the lengthy counting animation by taking the absolute difference of the display amount and actual amount, and check if the difference is too big, would
subtract/add by a larger amount, therefore instead of subtracting by a set amount per frame, you subtract by the proportion of the difference size. Here is an example using 16-bit number:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address of the actual number
!RAMToMeasure2 = $62			;>RAM address of the displayed amount
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar
!NumberOfDigitsDisplayed = 5		;>Number of digits shown.
!ChangeDivisorRate = 60			;>Scaling of increment/decrement rate. Higher number = slower.

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.CountingAnimation
	REP #$20
	LDA !RAMToMeasure2
	SEC
	SBC !RAMToMeasure
	BEQ ..Done			;>Safty check just in case it increments/decrements when it doesn't need to
	BCS ..Postive			;>Unsigned check of difference (alternative to BPL), making use of the 16-bit's carry flag as an extra bit, allowing 0-65535 instead of 0-32768
	
	..Negative
	;Add upwards towards !RAMToMeasure.
	EOR #$FFFF			;\Invert sign of number
	INC				;/
	STA $00				;\ChangePerFrame = floor(Difference/60) + 1
	LDA.w #!ChangeDivisorRate	;|
	STA $02				;|
	SEP #$20			;|
	JSL HexDec_MathDiv		;/
	REP #$20
	INC $00				;>Shouldn't add by 0
	LDA !RAMToMeasure2		;\The bigger the difference, the faster it increments.
	CLC				;|
	ADC $00				;/
	BRA ..Write
	
	..Postive
	;Subtract downwards towards !RAMToMeasure.
	STA $00				;\ChangePerFrame = floor(Difference/60) + 1
	LDA.w #!ChangeDivisorRate	;|
	STA $02				;|
	SEP #$20			;|
	JSL HexDec_MathDiv		;/
	REP #$20
	INC $00				;>Shouldn't subtract by 0
	LDA !RAMToMeasure2		;\The bigger the difference, the faster it decrements.
	SEC				;|
	SBC $00				;/
	
	..Write
	STA !RAMToMeasure2
	
	..Done
	
	.DisplayStatusBar
	LDA !RAMToMeasure2
	STA $00
	JSL HexDec_SixteenBitHexDecDivision
	JSL HexDec_RemoveLeadingZeroes16Bit
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBarPosition,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w (!Scratchram_16bitHexDecOutput)+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBarPosition,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></td></tr></table>
<hr>
<h2 id="Frames2Timer"><a href="#Frames2TimerBack">^</a>Display a timer in Hours:Minutes:Seconds:Centiseconds format</h2>
Perhaps, if you wanted to display a timer on the HUD in HH:MM:SS.CC (or MM:SS.CC) format, I've provided a routine for that and this code to use it:
<table><tr><td><pre>!RAMToMeasure = $60			;>[4 bytes] the 32-bit frame counter

;Settings
 !StatusBarPosition = $7FA000		;>Where to write on the status bar
 !Decrement = 0				;>0 = increment, 1 = decrement
 !ShowHours = 0				;>0 = MM:SS.CC, 1 = HH:MM:SS.CC
;Start timer (used only when set to decrement):
 !StartTimerHour = 0
 !StartTimerMinute = 3
 !StartTimerSeconds = 30

;Don't touch, this makes it so that !StatusBarPosition is always the first
;character being written (with hours disabled, it starts with the minutes).
	!StatusBarPositionOfset = 0
	if !ShowHours == 0
		!StatusBarPositionOfset = 3
	endif

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	init:
	if !Decrement != 0
		REP #$20
		LDA.w #(!StartTimerHour*216000)+(!StartTimerMinute*3600)+(!StartTimerSeconds*60)
		STA !RAMToMeasure
		LDA.w #(!StartTimerHour*216000)+(!StartTimerMinute*3600)+(!StartTimerSeconds*60)>>16
		STA !RAMToMeasure+2
		SEP #$20
		
	else
		REP #$20
		LDA #$0000
		STA !RAMToMeasure
		STA !RAMToMeasure+2
		SEP #$20
	endif
	RTL

	main:
	.Timer
	LDA $9D			;\Freeze timer if game is frozen in any way.
	ORA $13D4|!addr		;|
	BNE ..StopTimer		;/
	if !Decrement == 0
		..Increment
		REP #$20			;\Increment timer
		LDA !RAMToMeasure		;|
		CLC				;|
		ADC #$0001			;|
		STA !RAMToMeasure		;|
		LDA !RAMToMeasure+2		;|
		ADC #$0000			;|
		STA !RAMToMeasure+2		;/
		BCC ..NoOverflowDetected	;\Cap timer at $FFFFFFFF (19884:06:28.25 is the maximum, however hours can properly display up to 255)
		LDA #$FFFF			;|
		STA !RAMToMeasure		;|
		STA !RAMToMeasure+2		;/
		..NoOverflowDetected
	else
		REP #$20			;\Increment frame counter
		LDA !RAMToMeasure		;|Skip if timer is already 0 and triggered a code.
		ORA !RAMToMeasure+2		;|
		BEQ ..StopTimer			;/
		LDA !RAMToMeasure		;\Decrement frame counter to 0.
		SEC				;|
		SBC #$0001			;|
		STA !RAMToMeasure		;|
		LDA !RAMToMeasure+2		;|
		SBC #$0000			;|
		STA !RAMToMeasure+2		;|
		BCS ..NoUnderflow		;|\Failsafe
		LDA #$0000			;||
		STA !RAMToMeasure		;||
		STA !RAMToMeasure+2		;|/
		
		..NoUnderflow			;/
		
		LDA !RAMToMeasure		;\Check again, AFTER subtracting by 1, so that the code executes only once.
		ORA !RAMToMeasure+2		;|
		BNE ..NotDecrementedToZero	;/
		SEP #$20
		JSL TimerZero			;>Code to execute once.
		..NotDecrementedToZero
	endif
	..StopTimer
	REP #$20			;\Get timer format
	LDA !RAMToMeasure		;|
	STA $00				;|
	LDA !RAMToMeasure+2		;|
	STA $02				;|
	SEP #$20			;|
	JSL HexDec_Frames2Timer		;/
	
	if !ShowHours != 0
		;Hours
			LDA !Scratchram_Frames2TimeOutput
			JSL HexDec_EightBitHexDec
			STA !StatusBarPosition+(1*!StatusbarFormat)
			TXA
			STA !StatusBarPosition
		;Colon symbol
			LDA #$78
			STA !StatusBarPosition+(2*!StatusbarFormat)
	endif
	;Minutes
		LDA !Scratchram_Frames2TimeOutput+1
		JSL HexDec_EightBitHexDec
		STA !StatusBarPosition+((4-!StatusBarPositionOfset)*!StatusbarFormat)
		TXA
		STA !StatusBarPosition+((3-!StatusBarPositionOfset)*!StatusbarFormat)
	;Colon symbol
		LDA #$78
		STA !StatusBarPosition+((5-!StatusBarPositionOfset)*!StatusbarFormat)
	;Seconds
		LDA !Scratchram_Frames2TimeOutput+2
		JSL HexDec_EightBitHexDec
		STA !StatusBarPosition+((7-!StatusBarPositionOfset)*!StatusbarFormat)
		TXA
		STA !StatusBarPosition+((6-!StatusBarPositionOfset)*!StatusbarFormat)
	;Period symbol
		LDA #$24
		STA !StatusBarPosition+((8-!StatusBarPositionOfset)*!StatusbarFormat)
	;Centiseconds
		LDA !Scratchram_Frames2TimeOutput+3
		JSL HexDec_EightBitHexDec
		STA !StatusBarPosition+((10-!StatusBarPositionOfset)*!StatusbarFormat)
		TXA
		STA !StatusBarPosition+((9-!StatusBarPositionOfset)*!StatusbarFormat)
	RTL
	
	if !Decrement != 0
		TimerZero:
		LDA #$80	;\Example code: Fling player upwards.
		STA $7D		;/
		RTL
	endif</pre></td></tr></table>
	
<p>This works by taking a 32-bit frame counter (it must increment by 1 every 1/60th of a second, which is the NTSC SNES's game loop speed) and doing repeated divisions by 60:
<table><tr><td><pre>Frames / 60 = Q: Seconds R: Frames		;&gt;We have seconds (not wrapped 0-59 yet), and frames (wrapped 0-59, then displayed as 0-99)
Seconds / 60 = Q: Minutes R: Seconds		;&gt;We have minutes (not wrapped 0-59 yet), and seconds (wrapped 0-59)
Minutes / 60 = Q: Hours R: Minutes		;&gt;We have hours (not wrapped 0-59), and minutes (wrapped 0-59)</pre></td></tr></table>


This is an entirely different format from <a href="https://www.smwcentral.net/?p=section&a=details&id=16365">Imamelia's timer</a>
that mine have a 32-bit frame counter as a single number while Imamelia have his with each byte being stored containing each units
and increments and decrements individually. As of the time of writing this, the rightmost number on Imamelia's timer isn't the centiseconds
but rather jiffyseconds that display numbers 0-59.</p>

<p>The biggest advantages of mine is that you can add/subtract time much more easily (an item increases the timer by 5 seconds). Remember that how
65c816's addition and subtraction with carry (CLC/SEC/ADC/SBC) works? Well:
<ul>
	<li>
		ADC:
			<ul>
				<li>
					Before: If the carry is clear, will add normally. If the carry is set, will add an additional 1. For example: [<kbd>LDA #$01 : CLC : ADC #$01, Now A = #$02</kbd>],
					[<kbd>LDA #$01 : SEC : ADC #$01, Now A = #$03</kbd>]
				</li>
				<li>
					After: If A overflows (goes greater than 255 in 8-bit, 65535 in 16-bit, unsigned), the carry will be SET, otherwise if not, will be CLEAR. Example:
					[<kbd>LDA #$FF : CLC : ADC #$01, now carry is set (#$FF+#$01 = #$100 &rightarrow; #$00)</kbd>], [<kbd>LDA #$FE : CLC : ADC #$01, now carry is clear (A = #$FF)</kbd>].
				</li>
			</ul>
	</li>
	<li>
		SBC
			<ul>
				<li>
					Before: If the carry is set, will subtract normally. If the carry is clear, will subtract an additional 1. Example: [<kbd>LDA #$05 : SEC : SBC #$01, now A = #$04</kbd>]
					[<kbd>LDA #$05 : CLC : SBC #$01, now A = #$03</kbd>].
				</li>
				<li>
					After: If A underflows (goes under 0 on both 8-bit and 16-bit, unsigned), the carry will be CLEARED. Otherwise is SET. Example:
					[<kbd>LDA #$03 : SEC : SBC #$03, Now A = #$00 and carry set</kbd>], [<kbd>LDA #$03 : SEC : SBC #$04, Now A = -#$01 &rightarrow; #$FF and carry clear</kbd>].
				</li>
			</ul>
	</li>
	This is commonly done in pseudo 8-bit math to produce a potentially 16-bit number, for example with addition:
<table><tr><td><pre>
	;Made-up example: #$<font color="blue">12</font><font color="red">34</font> + #$<font color="blue"><u>56</font><font color="red">78</u></font> without carry set.
		LDA <font color="red">#$34</font>	;\Low byte
		CLC		;|#$34 + #$78 = #$AC
		ADC <font color="red"><u>#$78</u></font>	;|
		STA $00		;/
		LDA <font color="blue"><u>#$12</u></font>	;\High byte
		ADC <font color="blue"><u>#$56</u></font>	;|>If this second number is 8-bit, (for example, $78, you treat it as it has leading zeroes: $0078)
		STA $01		;/(#$12 + #$56 = #$68)
		
		;$00 to $01 = #$68AC
	;Another example: #$<font color="blue">FE</font><font color="red">FF</font> + #$<u><font color="blue">02</font><font color="red">01</font></u>, when the carry are set when they overflow
		LDA <font color="red">#$FF</font>	;\Low byte, #$FF + #$01 = #$0100, carry set and A as 8-bit = #$00.
		CLC		;|
		ADC <font color="red">#$01</font>	;|
		STA $00		;/
		LDA <font color="blue"><u>#$FE</u></font>	;\High byte, #$FE + #$02 + 1 (+1 because of the carry set) = #$0101, A as 8-bit = #$01
		ADC <font color="blue"><u>#$02</u></font>	;|carry set after this since A went above #$FF.
		STA $01		;/
		
		;$00 to $01 = #$0100, carry set. The actual correct math is #$FEFF + #$0201 = #$10100 but the low 2 bytes are stored in $00-$01.</pre></td></tr></table>
	The exact same thing can be done using 16-bit numbers to produce values that are bigger than the maximum register size (bigger than 16-bit, like 32-bit mode). Off-topic note: this also works with bit shifting as well, by using ASL/LSR, and then ROL/ROR.
	The carry flag is essentially a &ldquo;bridge&rdquo; to numbers bigger than the register size. To detect an overflow/underflow, just use BCC/BCS (branch if carry clear/set) AFTER all the bytes are added/subtracted/shifted. Also another off-topic is that
	SBC is very similar to CMP, but without affecting the A register.
</ul>
</p>

<p>For debugging purposes, or if you are planning to have items that would increase/decrease the timer, I've provided <a href="Readme_Files/JS_FrameToTimer.html" id="DebugTimerValue">a javascript converter between the total frames and timer format</a>
in case if you need to check their values stored in memory or needed to put direct frame values in there for adding/subtracting.</p>

<p>Protip: most video games never have a countdown timer of over 10 minutes, so you don't need a 32-bit number, you can simply use a smaller number of bytes and mask the high n bytes with zeroes. For example:
<table><tr><td><pre>	..StopTimer
	REP #$20			;\Get timer format
	LDA !RAMToMeasure		;|
	STA $00				;|
	LDA #$0000			;|\High words (upper 2 bytes of the 4-byte 32-bit input masked)
	STA $02				;|/
	SEP #$20			;|
	JSL HexDec_Frames2Timer		;/</pre></td></tr></table>
Here are the maximums values of the frame value and their timer equivalents:
<table>
	<tr><th>Number of bytes (max value/hex)</th><th>How long</th></tr>
	<tr><td>1 (255/$FF)</td><td>00:00:04.25</td></tr>
	<tr><td>2 (65535/$FFFF)</td><td>00:18:12.25</td></tr>
	<tr><td>3 (16777215/$FFFFFF)</td><td>77:40:20.25</td></tr>
	<tr><td>4 (4294967295/$FFFFFFFF)</td><td>19884:06:28.25 (hours will display incorrectly)</td></tr>
</table>
</p>
<hr>
<h2 id="Percentage"><a href="#PercentageBack">^</a>Display a percentage</h2>
<p>This tutorial display a number representing a percentage of something. Because we are dealing with integers here (The SNES does not support floating point numbers), we have to multiply first before we divide, as every
arithmetic operation rounds (specifically, division) the number to an integer:
<table><tr><td><pre>Improper way of dividing integers:
	Percentage = (Amount / TotalAmount) * PercentagePrecision
	
	This will round to 0 if X out of Y is less than Y, otherwise it is 100% when they equal when rounded down.
	This is because when you take a number, and divide by a larger number, it will land between 0 and 1, which
	cannot be represented in integers. So only 0 and 100 are being possible as the end result.
Proper way of dividing integers:
	Percentage = (Amount * PercentagePrecision) / TotalAmount
	
	Because this is multiplied before losing some precision from division, therefore minimizing the loss. This
	is because multiplying 2 integers always have a product being the correct number (besides wrapping around),
	whereas division, it is possible to land in between values.
</pre></td></tr></table><br>
<kbd>PercentagePrecision</kbd> is 100, 1000, or 10000. You may be wondering, why not just 100? Well, if you wanted more precise percentage display by displaying something like 50.03% this is using
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point arthmetic</a>. Meaning that a value <kbd>5003</kbd> stored in memory means 50.03 when using 10000. Here is a sample template
code to display a percentage:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;[2 bytes] RAM address you what to show (Quantity)
!RAMToMeasure2 = $62			;&gt;[2 bytes] RAM address you what to show (MaxQuantity)
!Default_PercentagePrecision = 0
;^0 = show whole number precisions, 1 = 1/10 of a percentage, 2 = 1/100. Not to be confused
; with !Scratchram_PercentageFixedPointPrecision.

!DigitDisplayAlignment = 0		;&gt;0 = left-aligned, 1 = right-aligned.

!StatusBarPosition = $7FA000	;&gt;Where to write on the status bar


incsrc "../StatusBarRoutinesDefines/Defines.asm"

main:
	;Submit fraction
		REP #$20
		LDA !RAMToMeasure
		STA !Scratchram_PercentageQuantity
		LDA !RAMToMeasure2
		STA !Scratchram_PercentageMaxQuantity
		SEP #$20
		LDA #!Default_PercentagePrecision
		STA !Scratchram_PercentageFixedPointPrecision
		JSL HexDec_ConvertToPercentage
	;Avoid displaying 0% and 100% misleadingly if close to them.
		CPY #$00
		BEQ .Normal
		CPY #$01
		BEQ .RoundTo1Percent
		CPY #$02
		BCS .RoundTo99Percent		;&gt;Just in case somehow Y is a value $03 or more
		
		.RoundTo1Percent
			REP #$20
			LDA.w #1
			STA $00
			STZ $02
			SEP #$20
			BRA .Normal
		.RoundTo99Percent
			REP #$20
			LDA.w #(10**(!Default_PercentagePrecision+2)-1)		;&gt;99%, 99.9%, or 99.99%.
			STA $00
			STZ $02
			SEP #$20
		.Normal
	;Display the number. Since it is very unlikely you display percentage greater than 100, you mostly
	;just need to use $00 (8-bit) alone.
		if !Default_PercentagePrecision == 0
			if !DigitDisplayAlignment == 1
				LDA $00
				JSL HexDec_EightBitHexDec3Digits
				STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
				
				.HandleHundreds
				CPY #$00					;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
				BNE ..HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
				
				..NoHundreds
				LDY #!StatusBarBlankTile			;\Erase the 100s digit
				TYA						;|
				STA !StatusBarPosition				;/
				BRA .HandleTens					;&gt;Check if the next digit is also part of the leading zero.
				
				..HundredsNonZero
				TYA
				STA !StatusBarPosition				;&gt;Write 100s place
				BRA .HandleTens_WriteTens			;&gt;If at least 100, 10s shouldn't be omitted.
				
				.HandleTens
				CPX #$00					;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
				BNE ..WriteTens					;/No, then erase the 10s.
				
				..NoTens
				LDX #!StatusBarBlankTile			;&gt;If 0, replace 10s digit with blank.
				
				..WriteTens
				TXA						;\Write 10s place
				STA !StatusBarPosition+(1*!StatusbarFormat)	;/
			elseif !DigitDisplayAlignment == 0
				STZ $01
				JSL HexDec_SixteenBitHexDecDivision
				
				.ClearTiles
				;Clear the tiles. To prevent leftover "ghost" tiles that should've
				;disappear when the number of digits decreases (so when "10" becomes "9",
				;won't display "90"). Also setup tile properties when enabled.
					LDX.b #(4-1)*!StatusbarFormat
					..Loop
						LDA #!StatusBarBlankTile
						STA !StatusBarPosition,x
						if !StatusBar_UsingCustomProperties != 0
							LDA.b #!DigitProps
							STA !StatusBarPositionProps,x
						endif
						DEX #!StatusbarFormat
						BPL ..Loop
				.StatusBarString
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
				;Prevent writing too much characters.
					CPX.b #4+1					;\Failsafe to avoid writing more characters than intended would write onto tiles
					BCS ..TooMuchDigits				;/not being cleared from the previous code.
				;Write percent symbol after the number
					LDA #!TileNumb_PercentSymbol			;\Write percent symbol
					STA !Scratchram_CharacterTileTable,x		;/
					INX
				;Write to status bar
					LDA.b #!StatusBarPosition : STA $00
					LDA.b #!StatusBarPosition&gt;&gt;8 : STA $01
					LDA.b #!StatusBarPosition&gt;&gt;16 : STA $02
					if !StatusbarFormat == $01
						JSL HexDec_WriteStringDigitsToHUD
					else
						JSL HexDec_WriteStringDigitsToHUDFormat2
					endif
					..TooMuchDigits
			endif
		else
			JSL HexDec_SixteenBitHexDecDivision
			if !DigitDisplayAlignment == 1
				if !Default_PercentagePrecision == 1
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast2
					;XXX.X%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/10s place
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !StatusBarPosition
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !StatusBarPosition+(1*!StatusbarFormat)
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !StatusBarPosition+(2*!StatusbarFormat)
					LDA #$24 : STA !StatusBarPosition+(3*!StatusbarFormat)					;&gt;Decimal point symbol
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !StatusBarPosition+(4*!StatusbarFormat)
					LDA #!TileNumb_PercentSymbol : STA !StatusBarPosition+(5*!StatusbarFormat)			;&gt;percent symbol
				elseif !Default_PercentagePrecision == 2
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast3
					;XXX.XX%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$00 (10000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1/10s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/100s place
					LDA !Scratchram_16bitHexDecOutput+$00 : STA !StatusBarPosition
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !StatusBarPosition+(1*!StatusbarFormat)
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !StatusBarPosition+(2*!StatusbarFormat)
					LDA #$24 : STA !StatusBarPosition+(3*!StatusbarFormat)					;&gt;Decimal point symbol
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !StatusBarPosition+(4*!StatusbarFormat)
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !StatusBarPosition+(5*!StatusbarFormat)
					LDA #!TileNumb_PercentSymbol : STA !StatusBarPosition+(6*!StatusbarFormat)			;&gt;percent symbol
				endif
			elseif !DigitDisplayAlignment == 0
				.ClearTiles
					LDA #!StatusBarBlankTile
					if !Default_PercentagePrecision == 1
						LDX.b #($06-1)*!StatusbarFormat		;&gt;[100.0%] is 6 characters. So we must clear out 6 tiles.
					elseif !Default_PercentagePrecision == 2
						LDX.b #($07-1)*!StatusbarFormat		;&gt;[100.00%] is 7 characters. So we must clear out 7 tiles.
					endif
					..Loop
						STA !StatusBarPosition,x
						DEX #!StatusbarFormat
						BPL ..Loop
				
				
				LDX #$00
				if !Default_PercentagePrecision == 1
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast2
				elseif !Default_PercentagePrecision == 2
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast3
				endif
				LDA #!TileNumb_PercentSymbol			;\Write percent symbol
				STA !Scratchram_CharacterTileTable,x		;/
				INX
				;Write to status bar
					LDA.b #!StatusBarPosition : STA $00
					LDA.b #!StatusBarPosition&gt;&gt;8 : STA $01
					LDA.b #!StatusBarPosition&gt;&gt;16 : STA $02
					if !StatusbarFormat == $01
						JSL HexDec_WriteStringDigitsToHUD
					else
						JSL HexDec_WriteStringDigitsToHUDFormat2
					endif
			endif
		endif
		;Percent symbol
			if !DigitDisplayAlignment != 0
				LDA #!TileNumb_PercentSymbol
				STA !StatusBarPosition+((4+!Default_PercentagePrecision)*!StatusbarFormat)
			endif
			.Done
	;Done
		RTL</pre></td></tr></table><br>
The calculation to find the percentage is handled in <kbd>ConvertToPercentage</kbd>. Depending on what is written to <kbd>!Scratchram_PercentageFixedPointPrecision</kbd> determines should the numerator be out of 100, 1000, or 10000,
which after the HexDec routine, you can write the first n digits, then the decimal point (tile <kbd>#$24</kbd>), and then the last n digits, example:
<table>
<tr><th>Fixed point (fraction it represents)</th><th>Intended Display</th><th>Precision Type</th><th>Where to place the decimal point</th></tr>
<tr><td>50 (50/100)</td><td>50%</td><td><kbd>!Default_PercentagePrecision = 0</kbd></td><td>No need to place decimal point, it is already the percentage value.</td></tr>
<tr><td>101 (101/1000)</td><td>10.1%</td><td><kbd>!Default_PercentagePrecision = 1</kbd></td><td>Write the decimal point between the 1s and 10s place of the fixed point number. This results in the 1s becoming the tenths, 10s become the 1s and so on.</td></tr>
<tr><td>2004 (2004/10000)</td><td>20.04%</td><td><kbd>!Default_PercentagePrecision = 2</kbd></td><td>Write the decimal point between the 10s and 100s of the fixed point number. This results in the 1s becoming the hundredths, 10s becomes the tenths, and so on.</td></tr>
</table><br>
I've made a left-aligned code that automatically writes the decimal point, so no worries if you wanted this format. That template code should have everything you need.<br><br>

You may be wondering, why am I using 16-bit on some areas (including within the <kbd>ConvertToPercentage</kbd>) when I don't need to? Well, this is designed to prevent potential overflows and displaying wrong values.

</p>
<hr>
<h2 id="RepeatedSymbol"><a href="#RepeatedSymbolBack">^</a>Displaying repeated symbols n times</h2>
<p>You probably have seen something like this in most video games that represents individual health using repeated collection of icons with none, some, or all of them &ldquo;filled&rdquo; and/or empty, for example
4/5 filled shows 5 symbols with 4 of them filled:<br>
<font size="10">&#9642;&#9642;&#9642;&#9642;&#9643;</font><br>
SMW actually does this with its yoshi coin counter (some or all of them shows a coin symbol with the rest showing tile $FC). This is often used whenever a number of something is a small amount. Code follows (make sure you insert
&ldquo;<kbd>RepeatedSymbols.asm</kbd>&rdquo; into uberasm tool's library as well):
<table><tr><td><pre>!MaxNumberOfSymbols = 5			;>Total number of symbols (maximum)
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar
!RAMToMeasure = $60			;>RAM address you what to show
!Leftwards = 0				;>0 = left-to-right when filling, 1 = right-to-left when filling.

incsrc "../StatusBarRoutinesDefines/Defines.asm"

;Tile numbers
	!EmptyTile = $26
	!FullTile = $2E

	main:
	LDA !RAMToMeasure
	STA $00
	LDA #!MaxNumberOfSymbols
	STA $01
	LDA #!EmptyTile
	STA $02
	LDA #!FullTile
	STA $03
	LDA.b #!StatusBarPosition
	STA $04
	LDA.b #!StatusBarPosition>>8
	STA $05
	LDA.b #!StatusBarPosition>>16
	STA $06
	if !StatusbarFormat == $01
		if !Leftwards == 0
			JSL RepeatedSymbols_WriteRepeatedSymbols
		else
			JSL RepeatedSymbols_WriteRepeatedSymbolsLeftwards
		endif
	else
		if !Leftwards == 0
			JSL RepeatedSymbols_WriteRepeatedSymbolsFormat2
		else
			JSL RepeatedSymbols_WriteRepeatedSymbolsLeftwardsFormat2
		endif
	endif
	RTL</pre></td></tr></table><br>
Using that code from above, the result is this with RAM $60 containing the value 3:<br>
<kbd>WriteRepeatedSymbols</kbd>: <img src="Readme_Files/RepeatedSymbol_3_5.png"> (SMW does not have a &ldquo;empty tile&rdquo; that is visible, so instead of using tile $FC, I used
tile $26, which is the &ldquo;X&rdquo; symbol.), when using <kbd>WriteRepeatedSymbolsLeftwards</kbd> (<kbd>!Leftwards = 1</kbd>): <img src="Readme_Files/RepeatedSymbolLeftwards_3_5.png"></p>

<h2 id="GraphicalBar"><a href="#GraphicalBarBack">^</a>Display a graphical bar</h2>

Graphical bar, as in this:<br>
<img src="Readme_Files/TransperentBackground.png"><br>

<p>Unlike the repeated symbols, this allows you to:
<ul>
	<li>
		<p>Have multiple values per symbol, instead of 1 unit per icon. Meaning, fractions of a symbol are displayed. In <i>Legend of zelda</i> series,
		before <i>Ocarina of Time</i>, Each heart have 2 values, therefore 1/2 a heart can be shown, <i>Ocarina of Time</i> and later games have 4
		units per heart, so 1/4 hearts displayed</p>
	</li>
	<li>
		<p>Display a value of something more &ldquo;continuous&rdquo;, or more precise, as the amount increases. Not only that, you don't need long bars
		just to represent huge amounts.</p>
	</li>
	<li>
		<p>Display an approximate percentage of something out of maximum, which is often used in most RPG games to display HP as a ratio of max HP towards
		a percentage.</p>
	</li>
</ul>


<a href="https://www.smwcentral.net/?p=section&a=details&id=19552">Resource here</a><sup><a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">[1]</a></sup>.
Reason this package not including this is because too much information to be had here.</p>
<hr>
<h2 id="OverworldBorder"><a href="#OverworldBorderBack">^</a>Displaying stuff on the overworld border</h2>
<p>You may be asking, how do I display information on the overworld border? Well, I have good news, because the only thing you have to do is convert the tile numbering for the status bar to
the tile numbering of the overworld border, if you are dealing with displaying digits, for non-digit based things like the repeated symbols, just use a different tile number. The graphical
bar to be used on the OWB is already covered in that package. So only the numerical display we'll discuss here.</p>

<p>Remember that I mentioned that the digit graphics are stored in page 1 at tile numbers <kbd>$22</kbd>-<kbd>$2B</kbd>? Well, I've also included OWB converters in the routines folder. Here are the examples
(run this code either as (obviously overworld) or gamemode <kbd>$0D-$0E</kbd> ($0D so the display happens during fade)). Also remember that the provided examples assumes you've installed the overworld border plus patch:<br>


8-bit 2-digit:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!OverworldBorderPosition = $7FEC00	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	init:
	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	CLC
	ADC #$22
	STA !OverworldBorderPosition+(1*2)		;>Write 1s place
	TXA						;>if you are using status bar patches, STX $xxxxxx will not work.
	CLC
	ADC #$22
	STA !OverworldBorderPosition			;>Write 10s place
	
	;Set properties:
		LDA.b #%00111001
		STA !OverworldBorderPosition+1
		STA !OverworldBorderPosition+1+(1*2)
	RTL</pre></td></tr></table>
8-bit 3-digit:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!OverworldBorderPosition = $7FEC00	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits			;>Obtain 3 digits in A, X and Y.
	CLC
	ADC #$22
	STA !OverworldBorderPosition+(2*!StatusbarFormat)	;>Write 1s place
	TXA							;\Write 10s place
	CLC
	ADC #$22
	STA !OverworldBorderPosition+(1*!StatusbarFormat)	;/
	TYA							;\Write 100s place.
	CLC
	ADC #$22
	STA !OverworldBorderPosition				;/
	
	;Set properties
		LDA.b #%00111001
		STA !OverworldBorderPosition+1
		STA !OverworldBorderPosition+1+(1*2)
		STA !OverworldBorderPosition+1+(2*2)
	RTL</pre></td></tr></table>
16-bit n-digit:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!OverworldBorderPosition = $7FEC00	;>Where to write on the overworld border
!NumberOfDigitsDisplayed = 5		;>How many digits, enter 1-5 (pointless if you enter less than 3).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	init:
	main:
	REP #$20
	LDA !RAMToMeasure
	STA $00
	SEP #$20
	JSL HexDec_SixteenBitHexDecDivision
	JSL HexDec_RemoveLeadingZeroes16Bit		;>Omit this if you want to display leading zeroes
	JSL HexDec_SixteenBitHexDecDivisionToOWB	;>Convert to OWB graphic.
	
	;Write to overworld border
		LDX.b #((!NumberOfDigitsDisplayed-1)*2)
		LDY.b #(!NumberOfDigitsDisplayed-1)
		-
		LDA.w (!Scratchram_16bitHexDecOutput)+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
		STA !OverworldBorderPosition,x
		LDA.b #%00111001								;\Page 1, Palette 6, and Priority ON
		STA.l !OverworldBorderPosition+1,x						;/
		DEY
		DEX #2
		BPL -
	RTL
</pre></td></tr></table>
32-bit n-digit:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!OverworldBorderPosition = $7FEC00	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;>How many digits, enter 1-10 (pointless if you enter less than 5).

	;Don't change this.
		if defined("sa1") == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif
	main:
	REP #$20
	LDA $60			;\Low word (example: $3344 -> [$44, $33] in $00, $01)
	STA $00			;/
	LDA $62			;\High word (example: $1122 -> [$22, $11] in $02, $03)
	STA $02			;/
	SEP #$20
	JSL HexDec_Convert32bitIntegerToDecDigits	;>Should Output example as: [$02, $08, $07, $04, $05, $04, $00, $02, $00] on !Scratchram_32bitHexDecOutput.
	JSL HexDec_RemoveLeadingZeroes32Bit		;>Again, remove to allow leading zeroes.
	JSL HexDec_ThirtyTwoBitHexDecDivisionToOWB
	
	;Write to overworld border:
		LDX #((!NumberOfDigitsDisplayed-1)*2)
		LDY #(!NumberOfDigitsDisplayed-1)
		-
		PHX
		TYX												;>Sigh, LDA $xxxxxx,y does not exist.
		LDA (!Scratchram_32bitHexDecOutput)+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
		PLX
		STA !OverworldBorderPosition,x
		LDA.b #%00111001
		STA.l !OverworldBorderPosition+1,x
		DEY
		DEX #2
		BPL -
	RTL</pre></td></tr></table>
Left and right aligned:
<table><tr><td><pre>!DisplayTwoNumbers = 1			;>0 = only the first number, 1 = display 2.
!RightAligned = 1			;>0 = left, 1 = right.
!RAMToMeasure = $60			;>RAM address you what to show
!RAMToMeasure2 = $62			;>Second number
if !RightAligned == 0
	!OverworldBorderPosition = $7FEC00	;>Where to write on the OWB (left aligned)
else
	!OverworldBorderPosition = $7FEC3E	;>Where to write on the OWB (right aligned)
endif
!NumberOfDigitsDisplayed = 5		;>How many digits, enter 1-5 (pointless if you enter less than 3).

;Note: Pointless and a waste of processing to use the digit alignment display if you plan on having
;!DisplayTwoNumbers set to 0 and !RightAligned set to 1, as calling the HexDec routine, replace leading
;zeroes with blank tiles, then writing to the status bar/OWB would do the exact same thing with less processing.

;What's stupid is that asar currently does not allow me to use Built-in Functions's logical operation with "assert".

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90"). Also set up the properties.
		if !DisplayTwoNumbers == 0
			LDX.b #(!NumberOfDigitsDisplayed-1)*2
		else
			LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*2
		endif
		-
		if !RightAligned == 0
			LDA #!OverWorldBorderBlankTile		;\Clear tiles
			STA !OverworldBorderPosition,x		;/
			LDA.b #%00111001			;\Set tile properties
			STA.l !OverworldBorderPosition+1,x	;/
		else
			LDA #!OverWorldBorderBlankTile
			STA !OverworldBorderPosition-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
			LDA.b #%00111001
			STA.l !OverworldBorderPosition+1-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
		endif
		DEX #2
		BPL -
	if !DisplayTwoNumbers == 0
		;Number to string.
			;Process HexDec
				REP #$20					;\Convert a given number to decimal digits.
				LDA !RAMToMeasure				;|
				STA $00						;|
				SEP #$20					;|
				JSL HexDec_SixteenBitHexDecDivision		;/
			;Remove leading zeroes and have it as a character table
				LDX #$00					;>Start at character position 0.
				JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
			;Prevent writing too much characters.
				CPX.b #!NumberOfDigitsDisplayed+1		;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits				;/not being cleared from the previous code.
			;Convert to OWB digits
				JSL HexDec_Convert16BitAlignedDigitToOWB	;>Convert to OWB digits (aligned digits)
	else
		;First number
			;Process HexDec
				REP #$20					;\Convert a given number to decimal digits.
				LDA !RAMToMeasure				;|
				STA $00						;|
				SEP #$20					;|
				JSL HexDec_SixteenBitHexDecDivision		;/
			;Remove leading zeroes and have it as a character table
				LDX #$00					;>Start at character position 0.
				JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
		;"/" symbol
				LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
				STA !Scratchram_CharacterTileTable,x		;/
				INX						;>Next character position.
		;Second number
			;Process HexDec
				PHX						;>Push X because it gets modified by the HexDec routine.
				REP #$20					;\Convert a given number to decimal digits.
				LDA !RAMToMeasure2				;|
				STA $00						;|
				SEP #$20					;|
				JSL HexDec_SixteenBitHexDecDivision		;/
				PLX						;>Restore.
			;Remove leading zeroes and have it as a character table
				JSL HexDec_SupressLeadingZeros			;>Write the digits (without leading zeroes) starting at position 0.
			;Prevent writing too much characters.
				CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)	;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits				;/not being cleared from the previous code.
			;Convert to OWB digits
				JSL HexDec_Convert16BitAlignedDigitToOWB	;>Convert to OWB digits (aligned digits)
	endif
	;Write to OWB
		LDA.b #!OverworldBorderPosition     : STA $00
		LDA.b #!OverworldBorderPosition>>8  : STA $01
		LDA.b #!OverworldBorderPosition>>16 : STA $02
		if !RightAligned != 0
			;Convert to right-aligned
				JSL HexDec_ConvertToRightAlignedFormat2
		endif
		JSL HexDec_WriteStringDigitsToHUDFormat2
	..TooMuchDigits
	RTL</pre></td></tr></table>
</p>
<hr>
<h2 id="OtherNotes"><a href="#OtherNotesBack">^</a>Other notes</h2>
<ul>
	<li>
		<p>When using SA-1 ROM, SMW's vanilla status bar RAM address is relocated to address bank <kbd>$40</kbd> while its absolute address ($12<u>3456</u>)
		are kept the same ($7E0EF9 &rightarrow; $400EF9).</p>
	</li>
	<li>
		<p>SMW does actually have a 32-bit (up to 999,999, but <abbr title="6 changeable digits, there are 7 displayed, but the rightmost 0 is static.">up to 6 digits</abbr>) HexDec handling routine, this is used for displaying the score and strangely, the bonus stars. Unlike the 2-digit simple HexDec,
		it is handled from left-to-right (just <a href="#Left2RightHexDec">like this</a>), and by subtracting by 10<sup>(NumberOfDigits-1) &rightarrow; 0</sup> repeatedly. Here is what I mean with the example of a number 123456 ($01E240).
		Note that the score is stored internally as the displayed number, divided by 10 (&ldquo;1234560&rdquo; is 123456, which that is $01E240 in hex, stored in little endian as
		<kbd>[$40, $E2, $01]</kbd>, not as $12D680/<kbd>[$80, $D6, $12]</kbd>.), here is an example showing that same number:
<table><tr><td><pre>;Subtract by 100000 ($0186A0) repeatedly to get the 100000s place
$01E240 (123456, SubtractCount = 0) -&gt; 
$005BA0 (023456, SubtractCount = <u>1</u>), cannot subtract anymore, so SubtractCount (1) is the correct 100000s place.

;Subtract by 10000 ($002710) to get the 10000s place:
$005BA0 (023456, SubtractCount = 0, notice that this number is used after the previous repeated subtraction) -&gt;
$003490 (013456, SubtractCount = 1) -&gt;
$000D80 (003456, SubtractCount = <u>2</u>), cannot subtract anymore, so SubtractCount (2) is the correct 10000s place.

;Subtract by 1000 ($0003E8) to get the 1000s place:
$000D80 (003456, SubtractCount = 0) -&gt;
$000998 (002456, SubtractCount = 1) -&gt;
$0005B0 (001456, SubtractCount = 2) -&gt;
$0001C8 (000456, SubtractCount = <u>3</u>), cannot subtract anymore, so SubtractCount (3) is the correct 1000s place.

;Subtract by 100 ($000064) to get the 100s place:
$0001C8 (000456, SubtractCount = 0) -&gt;
$000164 (000356, SubtractCount = 1) -&gt;
$000100 (000256, SubtractCount = 2) -&gt;
$00009C (000156, SubtractCount = 3) -&gt;
$000038 (000056, SubtractCount = <u>4</u>), cannot subtract anymore, so SubtractCount (4) is the correct 100s place.

;Subtract by 10 ($00000A) to get the 10s place:
$000038 (000056, SubtractCount = 0) -&gt;
$00002E (000046, SubtractCount = 1) -&gt;
$000024 (000036, SubtractCount = 2) -&gt;
$00001A (000026, SubtractCount = 3) -&gt;
$000010 (000016, SubtractCount = 4) -&gt;
$000006 (000006, SubtractCount = <u>5</u>), cannot subtract anymore, so SubtractCount (5) is the correct 10s place.

;Subtract by 1 ($000001) to get the 1s place:
;(Wow, you can just write the low byte of this 24-bit difference into the ones place, because after the MOD 10
;(subtract by 10 repeatedly), this difference is ALWAYS the 1s place since you are essentially dividing by 1.
$000006 (000006, SubtractCount = 0) -&gt;
$000005 (000005, SubtractCount = 1) -&gt;
$000004 (000004, SubtractCount = 2) -&gt;
$000003 (000003, SubtractCount = 3) -&gt;
$000002 (000002, SubtractCount = 4) -&gt;
$000001 (000001, SubtractCount = 5) -&gt;
$000000 (000000, SubtractCount = <u>6</u>), cannot subtract anymore, so SubtractCount (6) is the correct 1s place.
</pre></td></tr></table>
The routine is handled at address $009012-$009044, and the 10<sup>n</sup> table at $008FFA-$009011. This one is better
than doing digits from right to left using subtraction by 10 only (I mean, a number 999999 would take ages to finally get
the ones place, and then another ages to get the 10s, and so on. Which is why subtraction by <i>powers</i> of 10 from
left to right is much faster).</p>
	</li>
</ul>
<script>
	function Calculate() {
		//SMW status bar table
			var LoopCount = 0
			var CurrentRowYPos = 2
			var StartOfLineXPos = 2
			var OnSecondRow = 0
			var StatusBarAddress = parseInt("0EF9", 16)
			if (document.getElementById("SA1ROM").checked == true) {
				StatusBarAddress = parseInt("6EF9", 16)
			}
			var Output = ""
			Output += "<table>"
			Output += "<tr><th>Tile number/index</th><th>Coordinate</th><th>RAM address</th><th>default tiles and properties ROM address (%TTTTTTTT, %YXPCCCTT)</th></tr>"
			for (LoopCount = 0; LoopCount < 55; LoopCount++) {
				if (LoopCount == 28) {
					Output += "<tr><th colspan='4'>Second line</th></tr>"
					CurrentRowYPos = 3
					StartOfLineXPos = 3
					OnSecondRow = 28
				}
				Output += "<tr>"
				Output += "<td><kbd>" + LoopCount.toString(10) + "</kbd> (<kbd>$" + LoopCount.toString(16).toUpperCase() + "</kbd>)</td>"
				Output += "<td><kbd>(" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(10) + "," + CurrentRowYPos.toString(10) + ")</kbd> (<kbd>($" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(16).toUpperCase() + ",$" + CurrentRowYPos.toString(16).toUpperCase() + ")</kbd>)</td>"
				Output += "<td><kbd>$" + pad((StatusBarAddress+LoopCount).toString(16).toUpperCase(), 4) + "</kbd></td>"
				Output += "<td><kbd>$00" + (parseInt("8C89", 16)+(LoopCount*2)).toString(16).toUpperCase() + "</kbd>, <kbd>$00" + ((parseInt("8C89", 16)+(LoopCount*2))+1).toString(16).toUpperCase() + "</kbd></td>"
				Output += "</tr>"
			}
			Output += "<table>"
			document.getElementById("SMWStatusBarTable").innerHTML = Output
		
	}
	function pad(num, size) {
		var s = num+"";
		while (s.length < size) s = "0" + s;
		return s;
	}
</script>