<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
		</style>
	</head>
<body onload="Calculate()">
<center><h1>How to use the status bar</h1></center>
<hr>
<p>So you want to edit the HUD to display custom info to the player. Obviously, this requires at least basic ASM knowledge. Fear not! Once you got the pattern down, you'll understand how it works!</p>

<p>You should know these before doing this:</p>
<ul>

<li><p>Ersanio's tutorial<sup><a href="https://www.smwcentral.net/?p=section&a=details&id=15073">[1]</a><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">[2]</a></sup>
on something simple as how to write a value to memory. You should also know about binary and hexidecimal, since many data explained here store in memory are bitwise.</p></li>

<li><p>Understand the mechanics of <a href="https://www.smwcentral.net/?p=section&a=details&id=19043">Asar</a>, such as defines and labels.</p></li>

</ul>
<hr>
<h2>Javascript tools</h2>
<ul>
	<li>
		<a href="Readme_Files/TileDataAddr.html" id="QuickJSTools_TileDataAddr">S-PPU tile addressing tool</a>
	</li>
	<li>
		<a href="Readme_Files/JS_YXPCCCTT.html" id="QuickJSTools_JS_YXPCCCTT">Quick Hex &harr; Binary converter for YXPCCCTT bit format.</a>
	</li>
</ul>
<hr>
<h2>Quick navigation</h2>
<li><a href="#WarmUp" id="WarmUpBack">The warm-up: SMW's status bar.</a></li>
<li><a href="#TileFormat" id="TileFormatBack">Tile data format</a></li>
<li><a href="#SBPatches" id="SBPatchesBack">Other status bar patches</a></li>
<li><a href="#RoutineControl" id="RoutineControlBack">Adding routine-controlled display to the HUD.</a></li>
<ul>
	<li><a href="#DisplayNumbers" id="DisplayNumbersBack">Displaying decimal numbers</a></li>
	<ul>
		<li><a href="#RemoveLeadingZeroes" id="RemoveLeadingZeroesBack">Remove leading zeroes</a></li>
	</ul>
	<ul>
		<li><a href="#AlignedDigits" id="AlignedDigitsBack">Remove Leading zeros, with left/right-aligned digits</a></li>
	</ul>
	<li><a href="#RepeatedSymbol" id="RepeatedSymbolBack">Displaying repeated symbol n times.</a></li>
	<li><a href="#GraphicalBar" id="GraphicalBarBack">Display a graphical bar</a></li>
</ul>
<li><a href="#OtherNotes" id="OtherNotesBack">Other Notes</a></li>
<hr>
<p>I have provided several routines to make writing codes much user-friendly as possible. So lets begin.</p>
<h2 id="WarmUp"><a href="#WarmUpBack">^</a>The warm-up: SMW's status bar.</h2>
<p>Here, consider looking at this image:<br>
<img src="Readme_Files/StatusBarMap.png"><br>
RAM address <kbd>$7E0EF9-$7E0F2E</kbd> controls what tile to display. How do you modify it? Well you edit the
contents in the mentioned RAM address. There are 2 ways you can edit RAM addresses:
<ul>
<li>Most recommended: a debugger, specifically, <a href="https://www.smwcentral.net/?p=section&a=details&id=21616">Bsnes+</a>. This method applies temporary changes to your game for testing purposes,
it does not actually make &ldquo;permanent&rdquo; changes to your game. To make modifications, be at a level, and on the debugger, go to the menubar on the window, Tools &rightarrow; Debugger.
Now on the Debugger window: &rightarrow; Tools &rightarrow; Memory Editor, and enter on the search bar &ldquo;<kbd>7E0EF9</kbd>&rdquo; (or just &ldquo;<kbd>0EF9</kbd>&rdquo;, if using a SA-1 ROM, its
&ldquo;<kbd>6EF9</kbd>&rdquo;). It should now scroll to that address. From here, type in the hexidecimal number. At the time of making this, the memory editor lacks filtering features like entering a range. However, when you select a byte (a pair of hexidecimal digits), the info bar at the bottom shows what address you are on
to edit:<br>
<img src="Readme_Files/MemoryEditorAddress.png"></li>
<li>Create an ASM file to run under <a href="https://www.smwcentral.net/?p=section&a=details&id=19982">uberasm tool</a> as <kbd>level</kbd> under <kbd>main:</kbd> label, and just use <kbd>LDA #$xx : STA $xxxxxx</kbd>.</li>
</ul>

Now, for the RAM address, each byte is each 8x8 tile, meaning each time you go to the next address, its the next 8x8 tile number:<br>
<input type="radio" name="GameType" id="NormalROM" onclick="Calculate()" checked><label for="NormalROM">Normal game</label><br>
<input type="radio" name="GameType" id="SA1ROM" onclick="Calculate()"><label for="SA1ROM">SA-1</label>
<span id="SMWStatusBarTable"></span><br>
All of these bytes stored in RAM <kbd>$7E0EF9-$7E0F2E</kbd> are <kbd>TTTTTTTT</kbd>, which means you can only modify the tile number through RAM in-game. You may be wondering, if I wanted to edit the tiles here,
what value should I put? Well, <kbd>TTTTTTTT</kbd> is actually <i>what tile number to use</i>, from the tile data. When viewing the tile data stored in <kbd>GFX28</kbd> via <a href="https://www.smwcentral.net/?p=section&a=details&id=15671">YY-CHR</a>,
you can find what tile graphic to use by hovering your mouse over the 8x8 tile you want to use. After this, you should see on the bottom bar of the window showing what tile number that is:<br>
<img src="Readme_Files/TileNumber.png"><br>
Of course, you can view the tile &ldquo;number&rdquo; with bsnes+'s &ldquo;Tile Viewer&rdquo; (Debugger &rightarrow; S-PPU &rightarrow; Tile Viewer), it will only display its <i>tilemap address</i> (bottom bar of window).
I've made a conversion <a id="TileDataAddr" href="Readme_Files/TileDataAddr.html">cheatsheet here</a>.

Now you have the value you need. Just write that desired tile number to any tile number you want to write (either debugger or uberasm, if uberasm tool, you have to save, insert to your game, and run it to view the changes). For example, to write an
item box corner tile on the left of the top row, then it is tile number <kbd>$3A</kbd> to write at <kbd>$7E0EF9</kbd>, if using uberasm tool, its <kbd>LDA #$3A : STA $0EF9|!addr</kbd>.</p>

<p>Now hold up, when you play around with the tiles, many tiles will use the wrong palette, well, this is part of the tile properties (in binary, its <kbd>%YXPCCCTT</kbd>) that's hard-coded, that's right, there are actually 2 bytes of information
for each 8x8 tile with the tile numbers being in ROM and RAM and the properties all being hardcoded. When the level loads, the status bar routine will first transfer default tile number and properties from ROM addresses <kbd>$008C81-$008CFE</kbd>,
which contains all the tiles for the status bar, while the RAM itself only contain some of the tile numbers. To modify hardcoded tiles, I've already presented their addresses that directly correlates to the RAM addresses, for the top and bottom
lines of the item box:
<table>
<tr><th>Coordinate</th><th>Address (%TTTTTTTT, %YXPCCCTT)</th></tr>
<tr><th colspan="2">Top line of item box</th></tr>
<tr><td><kbd>(14,1)</kbd> (<kbd>($E,$1)</kbd>)</td><td><kbd>$008C81</kbd>, <kbd>$008C82</kbd></td></tr>
<tr><td><kbd>(15,1)</kbd> (<kbd>($F,$1)</kbd>)</td><td><kbd>$008C83</kbd>, <kbd>$008C84</kbd></td></tr>
<tr><td><kbd>(16,1)</kbd> (<kbd>($10,$1)</kbd>)</td><td><kbd>$008C85</kbd>, <kbd>$008C86</kbd></td></tr>
<tr><td><kbd>(17,1)</kbd> (<kbd>($11,$1)</kbd>)</td><td><kbd>$008C87</kbd>, <kbd>$008C88</kbd></td></tr>
<tr><th colspan="2">bottom line of item box</th></tr>
<tr><td><kbd>(14,4)</kbd> (<kbd>($E,$4)</kbd>)</td><td><kbd>$008CF7</kbd>, <kbd>$008CF8</kbd></td></tr>
<tr><td><kbd>(15,4)</kbd> (<kbd>($F,$4)</kbd>)</td><td><kbd>$008CF9</kbd>, <kbd>$008CFA</kbd></td></tr>
<tr><td><kbd>(16,4)</kbd> (<kbd>($10,$4)</kbd>)</td><td><kbd>$008CFB</kbd>, <kbd>$008CFC</kbd></td></tr>
<tr><td><kbd>(17,4)</kbd> (<kbd>($11,$4)</kbd>)</td><td><kbd>$008CFD</kbd>, <kbd>$008CFE</kbd></td></tr>
</table>
If you modify these hardcoded values through a debugger, the changes will only apply on the next level reload, since the hardcoded upload only occurs on level load.</p>

<p>You may be wondering, why did I include the tile coordinate in these tables? Well, is because of bsnes+'s ability to display the tile coordinates in the tilemap viewer (Debugger &rightarrow; S-PPU &rightarrow;
Tilemap Viewer, and select &ldquo;3&rdquo; on the BG.):<br>
<img src="Readme_Files/TileCoordinate.png"><br>
and then you can use that coordinate and CTRL+F here on this HTML file to locate what RAM/ROM address to modify, which is way easier than to trial-and-error modifying each address to find the desired location.</p>

<p>I've also provided a patch, <kbd>DefaultTiles.asm</kbd> which is intended to be an ASM patch version of the <a href="https://www.smwcentral.net/?p=section&a=details&id=4580">SMW status bar editor tool</a>.</p>
<hr>
<h2 id="TileFormat"><a href="#TileFormatBack">^</a>Tile data format</h2>
<p>As explained earlier about the palette issue, and that each 8x8 tile possess 2 tiles, I'll give you a summary of the entire tile data:
<ul>
	<li>
		<kbd>TTTTTTTT</kbd> is the tile number (previously explained already), refers to what tile to use from the tile stored in VRAM. Note that this alone is the tile number within a page.
	</li>
	<li>
		<kbd>YXPCCCTT</kbd> is the tile properties:
		<ul>
			<li>
				<kbd>TT</kbd> (ranges from 0-3): Page number. This is technically the upper bits of the tile number, which is why I use the same <kbd>T</kbd> instead
				another letter, therefore 10 bits used for the tile number (referred to as &ldquo;character&rdquo; in the debugger and the SNES dev manuel),
				but we refer the upper 2 bits as the page number, while the lower 8 bits as the tile number (within a page):<br>
				<img src="Readme_Files/PageNumberTT.png">
			</li>
			<li>
				<kbd>CCC</kbd> (ranges from 0-7): Palette number. This refers to what group-4 on the palette to use:<br>
				<img src="Readme_Files/PaletteCCC_0_7.png">
			</li>
			<li>
				<kbd>P</kbd> (0 or 1): Priority (1 is above everything or 0 is behind). Usually these are SET to prevent things (such as sprites,
				layer 1 or layer 2 (including those if they have priority)) from overlapping the HUD.
				For example, the bonus star symbol with and without priority against a cloud tile:<br>
				<img src="Readme_Files/PriorityP.png">
			</li>
			<li>
				<kbd>X</kbd> (0 or 1): X-flip. i.e: <img src="Readme_Files/HorizFlipX.png">
			</li>
			<li>
				<kbd>Y</kbd> (0 or 1): Y-flip. i.e: <img src="Readme_Files/VertiFlipY.png">
			</li>
		</ul>
	</li>
</ul>
I've made a <a href="Readme_Files/JS_YXPCCCTT.html" id="JS_YXPCCCTT">simple converter</a> since most debuggers only allow hex for editing and viewing values.

Now there are 2 formats on how a pair of bytes are being stored. SMW uses both, where default tiles are the &ldquo;2-bytes together&rdquo; format while RAM address <kbd>$7E0EF9-$7E0F2E</kbd>
are &ldquo;TileNumber and Props in their own table&rdquo; format but without the properties.
<table>
<tr>
<th>TileNumber and Props in their own table</th>
<th>2-bytes together</th>
</tr>
<tr>
<td><table><tr><td><pre>!TileNumbAddr: TTTTTTTT (tile 0)
!TileNumbAddr+1: TTTTTTTT (tile 1)
!TileNumbAddr+2: TTTTTTTT (tile 2)
!TileNumbAddr+3: TTTTTTTT (tile 3)
[...]</pre></td></tr></table>
On a separate table:
<table><tr><td><pre>!TilePropAddr: YXPCCCTT (tile 0)
!TilePropAddr+1: YXPCCCTT (tile 1)
!TilePropAddr+2: YXPCCCTT (tile 2)
!TilePropAddr+3: YXPCCCTT (tile 3)
[...]
;I refer this as "[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]"</pre></td></tr></table><br>
Tile numbers and properties are stored in 2 separate tables, one for each.
Every time you advance the next byte, you are on the next 8x8 tile.
</td>

<td><table><tr><td><pre>!TileAddr: TTTTTTTT (tile 0)
!TileAddr+1: YXPCCCTT (tile 0)
!TileAddr+2: TTTTTTTT (tile 1)
!TileAddr+3: YXPCCCTT (tile 1)
!TileAddr+4: TTTTTTTT (tile 2)
!TileAddr+5: YXPCCCTT (tile 2)
!TileAddr+6: TTTTTTTT (tile 3)
!TileAddr+7: YXPCCCTT (tile 3)
[...]

;I call refer this as "[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]"</pre></td></tr></table><br>
Every tile have 2 bytes placed one after another, so both tile numbers and properties are alternating
every byte. Therefore, to get to the next 8x8 tile, is a move of 2 bytes instead of one.

</td>
</tr>
</table>
</p>

<hr>
<h2 id="SBPatches"><a href="#SBPatchesBack">^</a>Other status bar patches</h2>
<p>Because SMW's status bar is extremely limited, other users decided to make status bar patches:
<ul>
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar</a>. This gives you a 32x5 8x8 tile area,
	therefore 160 8x8 tiles to edit.<sup>1</sup></p></li>
	
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld Border +</a>. Not a &ldquo;status bar&rdquo;, but similar
	in terms of editing the layer 3 8x8 tiles. This gives you 32x<kbd>!TopLines</kbd> (for the top of the screen) and 32x<kbd>!BottomLines</kbd> (for the bottom of the screen)
	8x8 tile area, therefore, up to 224 8x8 tiles you can edit.<sup>1</sup>. <kbd>!TopLines</kbd> is how many lines for the top of the screen, an integer 0-5.
	<kbd>!BottomLines</kbd> is same as previously mentioned, but for the bottom of the screen being an integer 0-2.</p></li>
	
<li><p><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>'s status bar patches<sup>2</sup></p></li>
	<ul>
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21562">Minimalist Status Bars</a>. This shrinks your status bar to 1 or
		2 lines of 8x8 tiles. Therefore, 32 or 64 tiles you can edit.</p></li>
		
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3 Status Bar</a>. True to the name, this replaces SMW's HUD with
		SMB3's HUD on the bottom of the screen. This gives you a 32x4 8x8 tile area, therefore 128 8x8 tiles to edit</p></li>
	</ul>
</ul>

<p>You may be wondering:
<ul>
<li><sup>1</sup>Uses the &ldquo;2-bytes together&rdquo; format, the <kbd>[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]</kbd></li>
<li><sup>2</sup>Uses the &ldquo;TileNumber and Props in their own table&rdquo; format, the <kbd>[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]</kbd></li>
</ul>
Therefore, many ASM patches that display on the status bar that I made are hybrid-support of these two formats. The define <kbd>!StatusbarFormat</kbd> is what
you need to edit to work with other status bar patches, set it to <kbd>$01</kbd> if &ldquo;TileNumber and Props in their own table&rdquo; otherwise set it to
<kbd>$02</kbd>.</p>

<p>Thankfully, I made HTML Javascript files for all of these ASM resources to enable you to search what RAM address of a given tile.</p>

</p>
<hr>
<h2 id="RoutineControl"><a href="#RoutineControlBack">^</a>Adding routine-controlled display to the HUD.</h2>
<p>This method assumes you are using uberasm tool to test your code to write to the status bar. The first thing you want to do is have all the ASM files in &ldquo;<kbd>StatusBarRoutines</kbd>&rdquo;
inserted into uberasm tool's &ldquo;<kbd>library</kbd>&rdquo; folder, and have the entire folder &ldquo;<kbd>StatusBarRoutinesDefines</kbd>&rdquo; be in the same directory as the uberasm tool exe program is at.</p>

<p>Before we start using the subroutines, we will demonstrate how to write tiles that change based on a given info <kbd>!RAMToMeasure</kbd>. It's very easy to write a tile that is different depending on
a condition using branches:
<table><tr><td><pre>!StatusBarPosition = $0EF9|!addr
!RAMToMeasure = $60
	main:
	LDA !RAMToMeasure
	BEQ +
	LDA #$00
	BRA ++
	+
	LDA #$01
	++
	STA !StatusBarPosition
	RTL</pre></td></tr></table><br>
and if you are tired of using branches, then an even simpler approach is to use tables:
<table><tr><td><pre>!StatusBarPosition = $0EF9|!addr
!RAMToMeasure = $60
	main:
	LDA !RAMToMeasure
	TAX
	LDA Table,x
	STA !StatusBarPosition
	RTL
	
	Table:
	db $xx ;&gt;When !RAMToMeasure = $00
	db $xx ;&gt;When !RAMToMeasure = $01
	db $xx ;&gt;When !RAMToMeasure = $02</pre></td></tr></table></p>
	
<p>But what about other not-so-simple displays? Well, the following shows you how to do that.</p>

<h3 id="DisplayNumbers"><a href="#DisplayNumbersBack">^</a>Displaying decimal numbers</h3>

<p>To display a single digit, just store the value directly to the tile RAM. Digits are correctly displayed if the value is 0-9. Any above that will display more than just digits.</p>

<p>But how do you display multi-digits on the status bar? Well, you use a routine that would wrap each digits just like how our real-world decimal number works
(ones place reset every 10s, 10s increases every 10th value, and the 10s resets every 100). The routine, <kbd>HexDec</kbd> converts a given number to
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal (BCD, unpacked)</a> to write each digit tiles onto the status bar. Thankfully,
the status bar graphic tiles on GFX28 starts with digits 0-9 so you don't have to convert digit numbers to digit graphics.</p>

<p>For the overworld border (<abbr title="So far, there isn't any other patches that lets you edit the overworld border similarly to the status bar.">assuming you're using the Overworld Border+ patch</abbr>),
which is stored in <kbd>GFX2A</kbd>, after calling the HexDec routine, you must add each digit by #$22 (<a href="Readme_Files/OWB_Digits.png" target="_blank">digit graphics are stored as tile numbers $22-$2B</a>),
and make sure you are using page 1 and not 0 on the tile properties (example, to display the number &ldquo;<font color="red">1</font><font color="blue">2</font>&rdquo;, the values must be <kbd><font color="red">$01</font>+$22 = $23</kbd>
for the tens and <kbd><font color="blue">$02</font>+$22 = $24</kbd> for the ones).</p>


<p>Create a text file, name it <kbd>StatusBarTest.asm</kbd>. Edit that text file to include this code:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	STA !StatusBarPosition				;&gt;Write 10s place
	RTL
</pre></td></tr></table></p>

<p>Now save, and insert in either as gamemode under number 14 (level), or level. Then run the tool to apply the changes.</p>

<p>Test the game (using a debugger, bsnes+) by going to the level that you inserted this created ASM file (or any level if using gamemode 14), you should see the
digits displayed on the HUD. Again, palettes, X/Y flips and other weird shenanigans can happen if you use SMW's vanilla status bar without
editing the default values. Now depending on what RAM to use set by <kbd>!RAMToMeasure</kbd>, it could display <kbd>00</kbd> or <kbd>[&lt;digits 0-9 or glitched tile here&gt;&lt;digits 0-9&gt;]</kbd>,
then on the debugger window, go to memory editor and search for the RAM you set for <kbd>!RAMToMeasure</kbd> (example: 60), edit the value in that byte to be any values $00-$63. It should
display their decimal version of the hex number:
<table>
<tr><th>Hex bytes</th><th>Displayed</th></tr>
<tr><td>$09</td><td>09</td></tr>
<tr><td>$0A</td><td>10</td></tr>
<tr><td>$0B</td><td>11</td></tr>
<tr><td colspan="2">...</td></tr>
<tr><td>$61</td><td>97</td></tr>
<tr><td>$62</td><td>98</td></tr>
<tr><td>$63</td><td>99</td></tr>
<tr><td bgcolor="red">$64</td><td bgcolor="red">A0</td></tr>
<tr><td bgcolor="red">$65</td><td bgcolor="red">A1</td></tr>
<tr><td bgcolor="red">$66</td><td bgcolor="red">A2</td></tr>
<tr><td colspan="2" bgcolor="red">(10s place digit cycles through the alphabet characters every 10th value until...)</td></tr>
<tr><td bgcolor="red">$FF</td><td bgcolor="red">P5</td></tr>
</table>
What happens if you enter numbers greater than $63? Well, when the routine is used like that, it is designed to display up to 2 digits. If the number is greater than $64, the 10s place digit start showing graphics
other than digits. This is because of how the routine works, is that the 10s place digit wasn't wrapped (wrapped, as in digits reset to 0 when going past 9: 8, 9, 0, 1 , 2...), so it can display
&ldquo;digits&rdquo; greater than 9 (98, 99, A0, A1, A2...).</p>

<p>You can fix this problem and make it allow the full range of the 8-bit value by after writing the ones digit, TXA, then call the routine again, and after that, A is the 10s, and X is the 100s place:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;Call again to get the 10s and 100s.
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 10s place
	TXA						;&gt;STX $xxxxxx don't exists.
	STA !StatusBarPosition				;&gt; Write 100s place
	RTL
</pre></td></tr></table><br>
The reason why this works is because A is the modulo result of A/10 of the input. Modulo is the division remainder and wraps a number
into a range of <kbd>0</kbd> to <kbd>Divisor-1</kbd> (in this case, 0-9). This is the same as repeated subtraction until the number cannot be subtracted any more (without going into the negatives).
To handle the higher digits, the loop also counts every successful subtractions by 10, which is how X increases every 10th value. When handling the 100s digit, you
basically divided the value by 10 again, which is <kbd>!RAMToMeasure/10/10</kbd>, which is the same as <kbd>!RAMToMeasure/(10^2)</kbd> which leads to <kbd>!RAMToMeasure/100</kbd>,
resulting A now being the 10s place wrapping every 100 and X increasing every 100. Because the maximum value stored in an 8-bit byte is 255, there is no way the hundreds place digit
will be able to glitch out at 1000. For more information how base conversion works, I found a wikipedia article on positional notation
<a href="https://en.wikipedia.org/wiki/Positional_notation#Base_conversion">on converting radixes</a>.</p>

<p id="Left2RightHexDec">Do note that this method have a cost: The higher the number to convert to BCD, the more subtractions by 10<sup>1 &rightarrow; (NumberOfDigits-1)</sup> it would take to get all the
digits outputted, not really harsh since this is 8-bit, so up to 25 iterations for a 2-digit (plus up to 2 more for 10s and 100s by calling the HexDec routine again). However, if you
DO want speed, do this instead. This works from left-to-right by repeatedly subtracting 100 until A is 0-99. The number of subtractions is now how many 100s for the 100s digit, after
that, with A being 0-99, we do the same but with 10s (how many 10s) instead of 100s to find how many 10s. After that, A is 0-9 which is already the ones place:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits		;&gt;Obtain 3 digits in A, X and Y.
	STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	TYA						;\Write 100s place.
	STA !StatusBarPosition				;/
	RTL
</pre></td></tr></table></p>

<p>What about if I wanted to convert 16-bit numbers (or if you have 3-4 digits and want to go above 255)? Well, good news for you, I've provided more than just 8-bit HexDec
converters. Here is the code in question (up to 65535). Example, RAM $60 contains the value <kbd>$1234</kbd> (in memory, its <kbd>$34, $12</kbd>), I call the routine <kbd>SixteenBitHexDecDivision</kbd>
after that, the digits of 4660 are stored. Note that this is ordered in decreasing significant decimal digits
(<abbr title="!HexDecDigitTable+4">last</abbr> byte = 1s, second-last = 10s...):
<table>
<tr><th>Define relative address</th><th>RAM address (normal/Sa-1)</th><th>Output value</th></tr>
<tr><td><kbd>!HexDecDigitTable+0</kbd></td><td><kbd>$02/$04</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 10000s place)</td></tr>
<tr><td><kbd>!HexDecDigitTable+1</kbd></td><td><kbd>$03/$05</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s place)</td></tr>
<tr><td><kbd>!HexDecDigitTable+2</kbd></td><td><kbd>$04/$06</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 100s place)</td></tr>
<tr><td><kbd>!HexDecDigitTable+3</kbd></td><td><kbd>$05/$07</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 10s place)</td></tr>
<tr><td><kbd>!HexDecDigitTable+4</kbd></td><td><kbd>$06/$08</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; 1s place)</td></tr>
</table><br>
Here is the code in question for you to test:</p>
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar
!NumberOfDigitsDisplayed = 5		;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	;Don't change this.
		if defined("sa1") == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif

		!HexDecDigitTable = $02
		if !sa1 != 0
			!HexDecDigitTable = $04
		endif
	main:
	REP #$20
	LDA !RAMToMeasure
	STA $00
	SEP #$20
	JSL HexDec_SixteenBitHexDecDivision
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !HexDecDigitTable+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBarPosition,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w (!HexDecDigitTable)+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBarPosition,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></td></tr></table><br>
	
	<p>Greater than 65535? (unlikely for other stuff besides a huge currency counter or custom score). This one is a 32-bit HexDec, up to
	4,294,967,295 ($FFFFFFFF) can be properly displayed. Remember, this is little endian, for example: a number
	<abbr title="287454020 in decimal">$11223344</abbr> must be inputted as
	<kbd>[$44, $33, $22, $11]</kbd> into <kbd>$00-$03</kbd> and should output as <kbd>[$02, $08, $07, $04, $05, $04, $00, $02, $00]</kbd> in
	<kbd>!Scratchram_32bitHexDecOutput</kbd>.<br>
	
	Here is an example using the previously mentioned number, with <kbd>!MaxNumberOfDigits</kbd> set to <kbd>9</kbd>, using default <kbd>!Scratchram_32bitHexDecOutput</kbd>.
	Again, the digits stored in each bytes are ordered in decreasing significant decimal digits (<abbr title="!Scratchram_32bitHexDecOutput+(!MaxNumberOfDigits-1)">last byte</abbr> is always
	the 1s place, regardless of <kbd>!MaxNumberOfDigits</kbd>'s value)
	<table>
	<tr><th>Define relative address</th><th>Default RAM address (normal/Sa-1)</th><th>Output value</th></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+0</kbd></td><td><kbd>$7F844E/$40019C</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 100000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+1</kbd></td><td><kbd>$7F844F/$40019D</kbd></td><td><kbd>$08</kbd> (represents &ldquo;8&rdquo; for 10000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+2</kbd></td><td><kbd>$7F8450/$40019E</kbd></td><td><kbd>$07</kbd> (represents &ldquo;7&rdquo; for 1000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+3</kbd></td><td><kbd>$7F8451/$40019F</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 100000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+4</kbd></td><td><kbd>$7F8452/$4001A0</kbd></td><td><kbd>$05</kbd> (represents &ldquo;5&rdquo; for 10000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+5</kbd></td><td><kbd>$7F8453/$4001A1</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+6</kbd></td><td><kbd>$7F8454/$4001A2</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 100s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+7</kbd></td><td><kbd>$7F8455/$4001A3</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 10s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+8</kbd></td><td><kbd>$7F8456/$4001A4</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 1s)</td></tr>
	
	</table><br>
	
	Code in question:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0F09|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;>How many digits, enter 1-10 (pointless if you enter less than 5).

	;Don't change this.
		if defined("sa1") == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif
	main:
	REP #$20
	LDA $60			;\Low word (example: $3344 -> [$44, $33] in $00, $01)
	STA $00			;/
	LDA $62			;\High word (example: $1122 -> [$22, $11] in $02, $03)
	STA $02			;/
	SEP #$20
	JSL HexDec_Convert32bitIntegerToDecDigits	;>Should Output example as: [$02, $08, $07, $04, $05, $04, $00, $02, $00] on !Scratchram_32bitHexDecOutput.
	
	;Write to status bar:
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA !Scratchram_32bitHexDecOutput+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBarPosition,x
			DEX
			BPL -
		else
			LDX #((!NumberOfDigitsDisplayed-1)*2)
			LDY #(!NumberOfDigitsDisplayed-1)
			-
			PHX
			TYX												;&gt;Sigh, LDA $xxxxxx,y does not exist.
			LDA (!Scratchram_32bitHexDecOutput)+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1)|!dp,x
			PLX
			STA !StatusBarPosition,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></td></tr></table><br>
	
Don't ask me to make an even larger number display, because not many games would ever display 10 digits at once, plus, it takes up space on the HUD.</p>

<p>Also note that <kbd>!NumberOfDigitsDisplayed</kbd> and <kbd>!MaxNumberOfDigits</kbd> are different. <kbd>!NumberOfDigitsDisplayed</kbd> refers to only the low (rightmost digits) n digits being
displayed, while <kbd>!MaxNumberOfDigits</kbd> is the fixed number of digits (uses leading zeroes if fewer digits) stored in the digit table (you can set this to a
<abbr title="If you have multiple number displays and they are using the 32-bit HexDec each with different maximums (example: 99,999 and 999,999), then set !MaxNumberOfDigits to whatever number using this routine uses the most digits
(in this case, 6, not 5).">lower number to save space</abbr>).
Having both in case if you want to only display up to n digits less than the routine can output. For example, a counter to display 6 digits, 0-999999. You wouldn't want display
unused digits always showing 0 on the millions (1000000s) and beyond (so don't display &ldquo;0000999999&rdquo;, those first 4 digits are always 0 and therefore redundant).</p>

<h4 id="RemoveLeadingZeroes"><a href="#RemoveLeadingZeroesBack">^</a>Removing leading zeroes</h4>
	<p>I've also provided routines that removes leading zeroes by simply replacing the first n digits with tile $FC in the digits table. After calling the the JSL routines to convert them into decimal
	digits, you then call <kbd>RemoveLeadingZeroes16Bit</kbd> or <kbd>RemoveLeadingZeroes32Bit</kbd> before writing to the status bar. Make sure you match the 16 and 32 bits. For the 8-bit versions,
	a routine isn't necessary:
	<ul>
		<li>For 2-digit numbers, just replace the 10s place digit with tile #$FC</li>
		<li>For 3-digit numbers, use this code template:
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec3Digits		;>Obtain 3 digits in A, X and Y.
	STA !StatusBarPosition+(2*!StatusbarFormat)	;>Write 1s place
	
	.HandleHundreds
	CPY #$00					;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
	BNE ..HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
	
	..NoHundreds
	LDY #$FC					;\Erase the 100s digit
	TYA						;|
	STA !StatusBarPosition				;/
	BRA .HandleTens					;>Check if the next digit is also part of the leading zero.
	
	..HundredsNonZero
	TYA
	STA !StatusBarPosition				;>Write 100s place
	BRA .HandleTens_WriteTens			;>If at least 100, 10s shouldn't be omitted.
	
	.HandleTens
	CPX #$00					;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
	BNE ..WriteTens					;/No, then erase the 10s.
	
	..NoTens
	LDX #$FC					;>If 0, replace 10s digit with blank.
	
	..WriteTens
	TXA						;\Write 10s place
	STA !StatusBarPosition+(1*!StatusbarFormat)	;/
	
	.Done
	RTL</pre></td></tr></table></li>
	</ul>
	</p>
<h3 id="AlignedDigits"><a href="#AlignedDigitsBack">^</a>Remove Leading zeros, with left/right-aligned digits</h3>
<p>Perhaps, the above method have a downside, leading zeros are actually replaced with leading spaces, giving a <i>right-aligned</i> look. If you are designing a HUD
with an icon (or a &ldquo;label&rdquo;) to the left of the number when the number have a small number of digits, you'll have a space in between the icon and the digits, which looks ugly, especially if the number
have a huge number of digits it can display up to. For example, a 5-digit number:<br>
<img src="Readme_Files/LeadingSpaces.png"><br><br>

The first routine, <kbd>SupressLeadingZeros</kbd> works like this: Search all the digits in <kbd>!HexDecDigitTable</kbd>, and copy all the digits on and after the first (leftmost) digit and paste them into
<kbd>!Scratchram_CharacterTileTable</kbd>. You've now have a left-aligned &ldquo;string&rdquo; table stored. After this routine, The X register now contains a number incremented for every character being written.
See picture below:<br>
<img src="Readme_Files/NoLeadingZeroesLeftAligned.png">
</p>
<h2 id="RepeatedSymbol"><a href="#RepeatedSymbolBack">^</a>Displaying repeated symbols n times</h2>
<p>You probably have seen something like this in most video games that represents individual health using repeated collection of icons with none, some, or all of them &ldquo;filled&rdquo; and/or empty, for example
4/5 filled shows 5 symbols with 4 of them filled:<br>
<font size="10">&#9642;&#9642;&#9642;&#9642;&#9643;</font><br>
SMW actually does this with its yoshi coin counter (some or all of them shows a coin symbol with the rest showing tile $FC). This is often used whenever a number of something is a small amount. Code follows (make sure you insert
&ldquo;<kbd>RepeatedSymbols.asm</kbd>&rdquo; into uberasm tool's library as well):
<table><tr><td><pre>!MaxNumberOfSymbols = 5			;>RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;>Where to write on the status bar
!RAMToMeasure = $60			;>RAM address you what to show

incsrc "../StatusBarRoutinesDefines/Defines.asm"

;Tile numbers
	!EmptyTile = $26
	!FullTile = $2E

	main:
	LDA $60
	STA $00
	LDA #!MaxNumberOfSymbols
	STA $01
	LDA #!EmptyTile
	STA $02
	LDA #!FullTile
	STA $03
	LDA.b #!StatusBarPosition
	STA $04
	LDA.b #!StatusBarPosition>>8
	STA $05
	LDA.b #!StatusBarPosition>>16
	STA $06
	JSL RepeatedSymbols_WriteRepeatedSymbols
	RTL</pre></td></tr></table><br>
To make it fill leftwards, just use <kbd>RepeatedSymbols_WriteRepeatedSymbolsLeftwards</kbd> instead of <kbd>RepeatedSymbols_WriteRepeatedSymbols</kbd>. Using that code from above,
the result is this with RAM $60 containing the value 3:<br>
<kbd>WriteRepeatedSymbols</kbd>: <img src="Readme_Files/RepeatedSymbol_3_5.png"> (SMW does not have a &ldquo;empty tile&rdquo; that is visible, so instead of using tile $FC, I used
tile $26, which is the &ldquo;X&rdquo; symbol.), <kbd>WriteRepeatedSymbolsLeftwards</kbd>: <img src="Readme_Files/RepeatedSymbolLeftwards_3_5.png"></p>

<h2 id="GraphicalBar"><a href="#GraphicalBarBack">^</a>Display a graphical bar</h2>

Graphical bar, as in this:<br>
<img src="Readme_Files/TransperentBackground.png"><br>

<p>Unlike the repeated symbols, this allows you to:
<ul>
	<li>
		<p>Have multiple values per symbol, instead of 1 unit per icon. Meaning, fractions of a symbol are displayed. In <i>Legend of zelda</i> series,
		before <i>Ocarina of Time</i>, Each heart have 2 values, therefore 1/2 a heart can be shown, <i>Ocarina of Time</i> and later games have 4
		units per heart, so 1/4 hearts displayed</p>
	</li>
	<li>
		<p>Display a value of something more &ldquo;continuous&rdquo;, or more precise, as the amount increases. Not only that, you don't need long bars
		just to represent huge amounts.</p>
	</li>
	<li>
		<p>Display an approximate percentage of something out of maximum, which is often used in most RPG games to display HP as a ratio of max HP towards
		a percentage.</p>
	</li>
</ul>


<a href="https://www.smwcentral.net/?p=section&a=details&id=19552">Resource here</a><sup><a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">[1]</a></sup>.
Reason this package not including this is because too much information to be had here.</p>
<hr>
<h2 id="OtherNotes"><a href="#OtherNotesBack">^</a>Other notes</h2>
<ul>
	<li>
		<p>When using SA-1 ROM, SMW's vanilla status bar RAM address is relocated to address bank <kbd>$40</kbd>. Meaning that instead of entering <kbd>$7E0EF9</kbd> or <kbd>$000EF9</kbd>, you enter <kbd>$400EF9</kbd>
		for routines that require 24-bit address (such as the repeated symbols display) for the input.</p>
	</li>
	<li>
		<p>SMW does actually have a 32-bit (up to 999,999) HexDec handling routine, this is used for displaying the score and strangely, the bonus stars. Unlike the 2-digit simple HexDec,
		it is handled from left-to-right (just <a href="#Left2RightHexDec">like this</a>), and by subtracting by 10<sup>(NumberOfDigits-1) &rightarrow; 0</sup> repeatedly. Here is what I mean with the example of a number 123456 ($01E240).
		Note that the score is stored internally as the displayed number, divided by 10 (&ldquo;1234560&rdquo; is 123456, which that is $01E240 in hex, stored in little endian as
		<kbd>[$40, $E2, $01]</kbd>, not as $12D680/<kbd>[$80, $D6, $12]</kbd>.), here is an example showing that same number:
<table><tr><td><pre>;Subtract by 100000 ($0186A0) repeatedly to get the 100000s place
$01E240 (123456, SubtractCount = 0) -&gt; 
$005BA0 (023456, SubtractCount = <u>1</u>), cannot subtract anymore, so SubtractCount (1) is the correct 100000s place.

;Subtract by 10000 ($002710) to get the 10000s place:
$005BA0 (023456, SubtractCount = 0, notice that this number is used after the previous repeated subtraction) -&gt;
$003490 (013456, SubtractCount = 1) -&gt;
$000D80 (003456, SubtractCount = <u>2</u>), cannot subtract anymore, so SubtractCount (2) is the correct 10000s place.

;Subtract by 1000 ($0003E8) to get the 1000s place:
$000D80 (003456, SubtractCount = 0) -&gt;
$000998 (002456, SubtractCount = 1) -&gt;
$0005B0 (001456, SubtractCount = 2) -&gt;
$0001C8 (000456, SubtractCount = <u>3</u>), cannot subtract anymore, so SubtractCount (3) is the correct 1000s place.

;Subtract by 100 ($000064) to get the 100s place:
$0001C8 (000456, SubtractCount = 0) -&gt;
$000164 (000356, SubtractCount = 1) -&gt;
$000100 (000256, SubtractCount = 2) -&gt;
$00009C (000156, SubtractCount = 3) -&gt;
$000038 (000056, SubtractCount = <u>4</u>), cannot subtract anymore, so SubtractCount (4) is the correct 100s place.

;Subtract by 10 ($00000A) to get the 10s place:
$000038 (000056, SubtractCount = 0) -&gt;
$00002E (000046, SubtractCount = 1) -&gt;
$000024 (000036, SubtractCount = 2) -&gt;
$00001A (000026, SubtractCount = 3) -&gt;
$000010 (000016, SubtractCount = 4) -&gt;
$000006 (000006, SubtractCount = <u>5</u>), cannot subtract anymore, so SubtractCount (5) is the correct 10s place.

;Subtract by 1 ($000001) to get the 1s place:
;(Wow, you can just write the low byte of this 24-bit difference into the ones place, because after the MOD 10
;(subtract by 10 repeatedly), this difference is ALWAYS the 1s place since you are essentially dividing by 1.
$000006 (000006, SubtractCount = 0) -&gt;
$000005 (000005, SubtractCount = 1) -&gt;
$000004 (000004, SubtractCount = 2) -&gt;
$000003 (000003, SubtractCount = 3) -&gt;
$000002 (000002, SubtractCount = 4) -&gt;
$000001 (000001, SubtractCount = 5) -&gt;
$000000 (000000, SubtractCount = <u>6</u>), cannot subtract anymore, so SubtractCount (6) is the correct 1s place.
</pre></td></tr></table>
The routine is handled at address $009012-$009044, and the 10<sup>n</sup> table at $008FFA-$009011. This one is better
than doing digits from right to left using subtraction by 10 only (I mean, a number 999999 would take ages to finally get
the ones place, and then another ages to get the 10s, and so on. Which is why subtraction by <i>powers</i> of 10 from
left to right is much faster).</p>
	</li>
</ul>
<script>
	function Calculate() {
		//SMW status bar table
			var LoopCount = 0
			var CurrentRowYPos = 2
			var StartOfLineXPos = 2
			var OnSecondRow = 0
			var StatusBarAddress = parseInt("0EF9", 16)
			if (document.getElementById("SA1ROM").checked == true) {
				StatusBarAddress = parseInt("6EF9", 16)
			}
			var Output = ""
			Output += "<table>"
			Output += "<tr><th>Tile number/index</th><th>Coordinate</th><th>RAM address</th><th>default tiles and properties ROM address (%TTTTTTTT, %YXPCCCTT)</th></tr>"
			for (LoopCount = 0; LoopCount < 55; LoopCount++) {
				if (LoopCount == 28) {
					Output += "<tr><th colspan='4'>Second line</th></tr>"
					CurrentRowYPos = 3
					StartOfLineXPos = 3
					OnSecondRow = 28
				}
				Output += "<tr>"
				Output += "<td><kbd>" + LoopCount.toString(10) + "</kbd> (<kbd>$" + LoopCount.toString(16).toUpperCase() + "</kbd>)</td>"
				Output += "<td><kbd>(" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(10) + "," + CurrentRowYPos.toString(10) + ")</kbd> (<kbd>($" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(16).toUpperCase() + ",$" + CurrentRowYPos.toString(16).toUpperCase() + ")</kbd>)</td>"
				Output += "<td><kbd>$" + pad((StatusBarAddress+LoopCount).toString(16).toUpperCase(), 4) + "</kbd></td>"
				Output += "<td><kbd>$00" + (parseInt("8C89", 16)+(LoopCount*2)).toString(16).toUpperCase() + "</kbd>, <kbd>$00" + ((parseInt("8C89", 16)+(LoopCount*2))+1).toString(16).toUpperCase() + "</kbd></td>"
				Output += "</tr>"
			}
			Output += "<table>"
			document.getElementById("SMWStatusBarTable").innerHTML = Output
		
	}
	function pad(num, size) {
		var s = num+"";
		while (s.length < size) s = "0" + s;
		return s;
	}
</script>