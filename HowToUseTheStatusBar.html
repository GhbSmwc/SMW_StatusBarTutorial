<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
		</style>
	</head>
<body onload="Calculate()">
<center><h1>How to use the status bar</h1></center>
<hr>
<p>So you want to edit the HUD to display custom info to the player. Obviously, this requires at least basic ASM knowledge. Fear not! Once you got the pattern down, you'll understand how it works!</p>

<p>You should know by now after reading Ersanio's tutorial<sup><a href="https://www.smwcentral.net/?p=section&a=details&id=15073">[1]</a><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">[2]</a></sup>
on something simple as how to write a value to memory. You should also know about binary and hexidecimal, since many data explained here store in memory are bitwise.</p>
<hr>
<h2>Javascript tools</h2>
<ul>
	<li>
		<a href="Readme_Files/TileDataAddr.html" id="QuickJSTools_TileDataAddr">S-PPU tile addressing tool</a>
	</li>
	<li>
		<a href="Readme_Files/JS_YXPCCCTT.html" id="QuickJSTools_JS_YXPCCCTT">Quick Hex &harr; Binary converter for YXPCCCTT bit format.</a>
	</li>
</ul>
<hr>
<h2>Quick navigation</h2>
<li><a href="#WarmUp" id="WarmUpBack">The warm-up: SMW's status bar.</a></li>
<li><a href="#TileFormat" id="TileFormatBack">Tile data format</a></li>
<li><a href="#SBPatches" id="SBPatchesBack">Other status bar patches</a></li>
<li><a href="#RoutineControl" id="RoutineControlBack">Adding routine-controlled display to the HUD.</a></li>
<ul>
	<li><a href="#DisplayNumbers" id="DisplayNumbersBack">Displaying decimal numbers</a></li>
	<li><a href="#RepatedSymbol" id="RepatedSymbolBack">Displaying repeated symbol n times.</a></li>
</ul>
<li></li>
<hr>
<p>I have provided several routines to make writing codes much user-friendly as possible. So lets begin.</p>
<h2 id="WarmUp"><a href="#WarmUpBack">^</a>The warm-up: SMW's status bar.</h2>
<p>Here, consider looking at this image:<br>
<img src="Readme_Files/StatusBarMap.png"><br>
RAM address <kbd>$7E0EF9-$7E0F2E</kbd> controls what tile to display. How do you modify it? Well you edit the
contents in the mentioned RAM address. There are 2 ways you can edit RAM addresses:
<ul>
<li>Most recommended: a debugger, specifically, <a href="https://www.smwcentral.net/?p=section&a=details&id=21616">Bsnes+</a>. This method applies temporary changes to your game for testing purposes,
it does not actually make &ldquo;permanent&rdquo; changes to your game. To make modifications, be at a level, and on the debugger, go to the menubar on the window, Tools &rightarrow; Debugger.
Now on the Debugger window: &rightarrow; Tools &rightarrow; Memory Editor, and enter on the search bar &ldquo;<kbd>7E0EF9</kbd>&rdquo; (or just &ldquo;<kbd>0EF9</kbd>&rdquo;, if using a SA-1 ROM, its
&ldquo;<kbd>6EF9</kbd>&rdquo;). It should now scroll to that address. From here, type in the hexidecimal number. At the time of making this, the memory editor lacks filtering features like entering a range. However, when you select a byte (a pair of hexidecimal digits), the info bar at the bottom shows what address you are on
to edit:<br>
<img src="Readme_Files/MemoryEditorAddress.png"></li>
<li>Create an ASM file to run under <a href="https://www.smwcentral.net/?p=section&a=details&id=19982">uberasm tool</a> as <kbd>level</kbd> under <kbd>main:</kbd> label, and just use <kbd>LDA #$xx : STA $xxxxxx</kbd>.</li>
</ul>

Now, for the RAM address, each byte is each 8x8 tile, meaning each time you go to the next address, its the next 8x8 tile number:<br>
<input type="radio" name="GameType" id="NormalROM" onclick="Calculate()" checked><label for="NormalROM">Normal game</label><br>
<input type="radio" name="GameType" id="SA1ROM" onclick="Calculate()"><label for="SA1ROM">SA-1</label>
<span id="SMWStatusBarTable"></span><br>
All of these bytes stored in RAM <kbd>$7E0EF9-$7E0F2E</kbd> are <kbd>TTTTTTTT</kbd>, which means you can only modify the tile number through RAM in-game. You may be wondering, if I wanted to edit the tiles here,
what value should I put? Well, <kbd>TTTTTTTT</kbd> is actually <i>what tile number to use</i>, from the tile data. When viewing the tile data stored in <kbd>GFX28</kbd> via <a href="https://www.smwcentral.net/?p=section&a=details&id=15671">YY-CHR</a>,
you can find what tile graphic to use by hovering your mouse over the 8x8 tile you want to use. After this, you should see on the bottom bar of the window showing what tile number that is:<br>
<img src="Readme_Files/TileNumber.png"><br>
Of course, you can view the tile &ldquo;number&rdquo; with bsnes+'s &ldquo;Tile Viewer&rdquo; (Debugger &rightarrow; S-PPU &rightarrow; Tile Viewer), it will only display its <i>tilemap address</i> (bottom bar of window).
I've made a conversion <a id="TileDataAddr" href="Readme_Files/TileDataAddr.html">cheatsheet here</a>.

Now you have the value you need. Just write that desired tile number to any tile number you want to write (either debugger or uberasm, if uberasm tool, you have to save, insert to your game, and run it to view the changes). For example, to write an
item box corner tile on the left of the top row, then it is tile number <kbd>$3A</kbd> to write at <kbd>$7E0EF9</kbd>, if using uberasm tool, its <kbd>LDA #$3A : STA $0EF9|!addr</kbd>.</p>

<p>Now hold up, when you play around with the tiles, many tiles will use the wrong palette, well, this is part of the tile properties (in binary, its <kbd>%YXPCCCTT</kbd>) that's hard-coded, that's right, there are actually 2 bytes of information
for each 8x8 tile with the tile numbers being in ROM and RAM and the properties all being hardcoded. When the level loads, the status bar routine will first transfer default tile number and properties from ROM addresses <kbd>$008C81-$008CFE</kbd>,
which contains all the tiles for the status bar, while the RAM itself only contain some of the tile numbers. To modify hardcoded tiles, I've already presented their addresses that directly correlates to the RAM addresses, for the top and bottom
lines of the item box:
<table>
<tr><th>Coordinate</th><th>Address (%TTTTTTTT, %YXPCCCTT)</th></tr>
<tr><th colspan="2">Top line of item box</th></tr>
<tr><td><kbd>(14,1)</kbd> (<kbd>($E,$1)</kbd>)</td><td><kbd>$008C81</kbd>, <kbd>$008C82</kbd></td></tr>
<tr><td><kbd>(15,1)</kbd> (<kbd>($F,$1)</kbd>)</td><td><kbd>$008C83</kbd>, <kbd>$008C84</kbd></td></tr>
<tr><td><kbd>(16,1)</kbd> (<kbd>($10,$1)</kbd>)</td><td><kbd>$008C85</kbd>, <kbd>$008C86</kbd></td></tr>
<tr><td><kbd>(17,1)</kbd> (<kbd>($11,$1)</kbd>)</td><td><kbd>$008C87</kbd>, <kbd>$008C88</kbd></td></tr>
<tr><th colspan="2">bottom line of item box</th></tr>
<tr><td><kbd>(14,4)</kbd> (<kbd>($E,$4)</kbd>)</td><td><kbd>$008CF7</kbd>, <kbd>$008CF8</kbd></td></tr>
<tr><td><kbd>(15,4)</kbd> (<kbd>($F,$4)</kbd>)</td><td><kbd>$008CF9</kbd>, <kbd>$008CFA</kbd></td></tr>
<tr><td><kbd>(16,4)</kbd> (<kbd>($10,$4)</kbd>)</td><td><kbd>$008CFB</kbd>, <kbd>$008CFC</kbd></td></tr>
<tr><td><kbd>(17,4)</kbd> (<kbd>($11,$4)</kbd>)</td><td><kbd>$008CFD</kbd>, <kbd>$008CFE</kbd></td></tr>
</table>
If you modify these hardcoded values through a debugger, the changes will only apply on the next level reload, since the hardcoded upload only occurs on level load.</p>

<p>You may be wondering, why did I include the tile coordinate in these tables? Well, is because of bsnes+'s ability to display the tile coordinates in the tilemap viewer (Debugger &rightarrow; S-PPU &rightarrow;
Tilemap Viewer, and select &ldquo;3&rdquo; on the BG.):<br>
<img src="Readme_Files/TileCoordinate.png"><br>
and then you can use that coordinate and CTRL+F here on this HTML file to locate what RAM/ROM address to modify, which is way easier than to trial-and-error modifying each address to find the desired location.</p>
<hr>
<h2 id="TileFormat"><a href="#TileFormatBack">^</a>Tile data format</h2>
<p>As explained earlier about the palette issue, and that each 8x8 tile possess 2 tiles, I'll give you a summary of the entire tile data:
<ul>
	<li>
		<kbd>TTTTTTTT</kbd> is the tile number (previously explained already), refers to what tile to use from the tile stored in VRAM. Note that this alone is the tile number within a page.
	</li>
	<li>
		<kbd>YXPCCCTT</kbd> is the tile properties:
		<ul>
			<li>
				<kbd>TT</kbd> (ranges from 0-3): Page number. This is technically the upper bits of the tile number, which is why I use the same <kbd>T</kbd> instead
				another letter, therefore 10 bits used for the tile number (referred to as &ldquo;character&rdquo; in the debugger and the SNES dev manuel),
				but we refer the upper 2 bits as the page number, while the lower 8 bits as the tile number (within a page):<br>
				<img src="Readme_Files/PageNumberTT.png">
			</li>
			<li>
				<kbd>CCC</kbd> (ranges from 0-7): Palette number. This refers to what group-4 on the palette to use:<br>
				<img src="Readme_Files/PaletteCCC_0_7.png">
			</li>
			<li>
				<kbd>P</kbd> (0 or 1): Priority (1 is above everything or 0 is behind). Usually these are SET to prevent things (such as sprites,
				layer 1 or layer 2 (including those if they have priority)) from overlapping the HUD.
				For example, the bonus star symbol with and without priority against a cloud tile:<br>
				<img src="Readme_Files/PriorityP.png">
			</li>
			<li>
				<kbd>X</kbd> (0 or 1): X-flip. i.e: <img src="Readme_Files/HorizFlipX.png">
			</li>
			<li>
				<kbd>Y</kbd> (0 or 1): Y-flip. i.e: <img src="Readme_Files/VertiFlipY.png">
			</li>
		</ul>
	</li>
</ul>
I've made a <a href="Readme_Files/JS_YXPCCCTT.html" id="JS_YXPCCCTT">simple converter</a> since most debuggers only allow hex for editing and viewing values.

Now there are 2 formats on how a pair of bytes are being stored. SMW uses both, where default tiles are the &ldquo;2-bytes together&rdquo; format while RAM address <kbd>$7E0EF9-$7E0F2E</kbd>
are &ldquo;TileNumber and Props in their own table&rdquo; format but without the properties.
<table>
<tr>
<th>TileNumber and Props in their own table</th>
<th>2-bytes together</th>
</tr>
<tr>
<td><table><tr><td><pre>!TileNumbAddr: TTTTTTTT (tile 0)
!TileNumbAddr+1: TTTTTTTT (tile 1)
!TileNumbAddr+2: TTTTTTTT (tile 2)
!TileNumbAddr+3: TTTTTTTT (tile 3)
[...]</pre></td></tr></table>
On a separate table:
<table><tr><td><pre>!TilePropAddr: YXPCCCTT (tile 0)
!TilePropAddr+1: YXPCCCTT (tile 1)
!TilePropAddr+2: YXPCCCTT (tile 2)
!TilePropAddr+3: YXPCCCTT (tile 3)
[...]
;I refer this as "[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]"</pre></td></tr></table><br>
Tile numbers and properties are stored in 2 separate tables, one for each.
Every time you advance the next byte, you are on the next 8x8 tile.
</td>

<td><table><tr><td><pre>!TileAddr: TTTTTTTT (tile 0)
!TileAddr+1: YXPCCCTT (tile 0)
!TileAddr+2: TTTTTTTT (tile 1)
!TileAddr+3: YXPCCCTT (tile 1)
!TileAddr+4: TTTTTTTT (tile 2)
!TileAddr+5: YXPCCCTT (tile 2)
!TileAddr+6: TTTTTTTT (tile 3)
!TileAddr+7: YXPCCCTT (tile 3)
[...]

;I call refer this as "[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]"</pre></td></tr></table><br>
Every tile have 2 bytes placed one after another, so both tile numbers and properties are alternating
every byte. Therefore, to get to the next 8x8 tile, is a move of 2 bytes instead of one.

</td>
</tr>
</table>
</p>

<hr>
<h2 id="SBPatches"><a href="#SBPatchesBack">^</a>Other status bar patches</h2>
<p>Because SMW's status bar is extremely limited, other users decided to make status bar patches:
<ul>
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar</a>. This gives you a 32x5 8x8 tile area,
	therefore 160 8x8 tiles to edit.<sup>1</sup></p></li>
	
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld Border +</a>. Not a &ldquo;status bar&rdquo;, but similar
	in terms of editing the layer 3 8x8 tiles. This gives you 32x<kbd>!TopLines</kbd> (for the top of the screen) and 32x<kbd>!BottomLines</kbd> (for the bottom of the screen)
	8x8 tile area, therefore, up to 224 8x8 tiles you can edit.<sup>1</sup>. <kbd>!TopLines</kbd> is how many lines for the top of the screen, an integer 0-5.
	<kbd>!BottomLines</kbd> is same as previously mentioned, but for the bottom of the screen being an integer 0-2.</p></li>
	
<li><p><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>'s status bar patches<sup>2</sup></p></li>
	<ul>
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21562">Minimalist Status Bars</a>. This shrinks your status bar to 1 or
		2 lines of 8x8 tiles. Therefore, 32 or 64 tiles you can edit.</p></li>
		
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3 Status Bar</a>. True to the name, this replaces SMW's HUD with
		SMB3's HUD on the bottom of the screen. This gives you a 32x4 8x8 tile area, therefore 128 8x8 tiles to edit</p></li>
	</ul>
</ul>

<p>You may be wondering:
<ul>
<li><sup>1</sup>Uses the &ldquo;2-bytes together&rdquo; format, the <kbd>[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]</kbd></li>
<li><sup>2</sup>Uses the &ldquo;TileNumber and Props in their own table&rdquo; format, the <kbd>[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]</kbd></li>
</ul>
Therefore, many ASM patches that display on the status bar that I made are hybrid-support of these two formats. The define <kbd>!StatusbarFormat</kbd> is what
you need to edit to work with other status bar patches, set it to <kbd>$01</kbd> if &ldquo;TileNumber and Props in their own table&rdquo; otherwise set it to
<kbd>$02</kbd>.</p>

<p>Thankfully, I made HTML Javascript files for all of these ASM resources to enable you to search what RAM address of a given tile.</p>

</p>
<hr>
<h2 id="RoutineControl"><a href="#RoutineControlBack">^</a>Adding routine-controlled display to the HUD.</h2>
<p>This method assumes you are using uberasm tool to test your code to write to the status bar.</p>

<p>It's pretty darn easy to write a tile that is different depending on a condition using branches:
<table><tr><td><pre>	LDA &lt;RAM_Address&gt;
	BEQ +
	LDA #$00
	BRA ++
	+
	LDA #$01
	++
	STA !StatusBarPosition</pre></td></tr></table></p>
	
<p>But what about other not-so-simple displays? Well, the following shows you how to do that.</p>

<h3 id="DisplayNumbers"><a href="#DisplayNumbersBack">^</a>Displaying decimal numbers</h3>

<p>To display a single digit, just store the value directly to the tile RAM.</p>

<p>How do you display multi-digits on the status bar? Well, first, copy/cut <kbd>HexDec.asm</kbd> (inside the StatusBarRoutines folder) to uberasm tool's library, this will
apply the routine to be used anywhere throughout uberasm tool-related code. HexDec routines converts a number to binary-coded decimal
to write each digit tiles onto the status bar. Thankfully, the status bar graphic on GFX28 starts with digits 0-9 so you don't have to
convert digit numbers to digit graphics (except for overworld border).</p>


<p>Create a text file, name it <kbd>StatusBarTest.asm</kbd>. Edit that text file to include this code:
<table><tr><td><pre>!RAMToMeasure = $60		;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar
!StatusbarFormat = $01		;&gt;$01 = [TTTTTTTT, TTTTTTTT,...], $02 = [TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	STA !StatusBarPosition				;&gt;Write 10s place
	RTL
</pre></td></tr></table></p>

<p>Now save, and insert in either as gamemode under number 14 (level), or level. Then run the tool to apply the changes.</p>

<p>Test the game (using a debugger, bsnes+) by going to the level that you inserted this created ASM file (or any level if using gamemode 14), you should see the
digits displayed on the HUD. Again, palettes, X/Y flips and other weird shenanigans can happen if you use SMW's vanilla status bar without
editing the default values. Now depending on what RAM to use set by <kbd>!RAMToMeasure</kbd>, it could display <kbd>00</kbd> or [<kbd>&lt;digits 0-9 or glitched tile here&gt;&lt;digits 0-9&gt;</kbd>],
then on the debugger window, go to memory editor and search for the RAM you set for <kbd>!RAMToMeasure</kbd> (example: 60), edit the value in that byte to be any values $00-$63. It should
display their decimal version of the hex number:
<table>
<tr><th>Hex bytes</th><th>Displayed</th></tr>
<tr><td>$09</td><td>09</td></tr>
<tr><td>$0A</td><td>10</td></tr>
<tr><td>$0B</td><td>11</td></tr>
<tr><td colspan="2">...</td></tr>
<tr><td>$61</td><td>97</td></tr>
<tr><td>$62</td><td>98</td></tr>
<tr><td>$63</td><td>99</td></tr>
<tr><td bgcolor="red">$64</td><td bgcolor="red">A0</td></tr>
</table>
What happens if you enter numbers greater than $63? Well, when the routine is used like that, it is designed to display 2 digits. If the number is greater than $64, the 10s place digit start showing graphics
other than digits. This is because of how the routine works, is that the 10s place digit wasn't wrapped (wrapped, as in digits reset to 0 when going past 9: 8, 9, 0, 1 , 2...), so it can display
&ldquo;digits&rdquo; greater than 9 (98, 99, A0, A1, A2...).</p>

<p>You can fix this problem and make it allow the full range of the 8-bit value by after writing the ones digit, TXA, then call the routine again, and after that, A is the 10s, and X is the 100s place:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar
!StatusbarFormat = $01			;&gt;$01 = [TTTTTTTT, TTTTTTTT,...], $02 = [TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]

	main:
	LDA !RAMToMeasure
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA						;&gt;Call again to get the 10s and 100s.
	JSL HexDec_EightBitHexDec
	STA !StatusBarPosition+(1*!StatusbarFormat)	;&gt;Write 10s place
	TXA						;&gt;STX $xxxxxx don't exists.
	STA !StatusBarPosition				;&gt; Write 100s place
	RTL
</pre></td></tr></table><br>
The reason why this works is because A is the modulo result of A/10 of the input. Modulo is the division remainder and wraps a number
into a range of <kbd>0</kbd> to <kbd>Divisor-1</kbd> (in this case, 0-9). This is the same as repeated subtraction until the number cannot be subtracted any more (when < 10).
To handle the higher digits, the loop also counts every sucessful subtractions by 10, which is how X increases every 10th value. When handling the 100s digit, you
basically divided the value by 10 again, which is <kbd>!RAMToMeasure/10/10</kbd>, which is the same as <kbd>!RAMToMeasure/(10^2)</kbd> which leads to <kbd>!RAMToMeasure/100</kbd>,
resulting A now being the 10s place wrapping every 100 and X increasing every 100. Because the maximum value stored in an 8-bit byte is 255, there is no way the hundreds place digit
will be able to glitch out at 1000. For more information how base conversion works, I found a wikipedia article on positional notation
<a href="https://en.wikipedia.org/wiki/Positional_notation#Base_conversion">on converting radixes</a>.</p>

<p>What about if I wanted to convert 16-bit numbers (or if you have 3-4 digits and want to go above 255)? Well, good news for you, I've provided more than just 8-bit hexdec
converters. Here is the code in question:
<table><tr><td><pre>!RAMToMeasure = $60			;&gt;RAM address you what to show
!StatusBarPosition = $0EF9|!addr	;&gt;Where to write on the status bar
!StatusbarFormat = $01			;&gt;$01 = [TTTTTTTT, TTTTTTTT,...], $02 = [TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]
!NumberOfDigitsDisplayed = 5		;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	;Don't change this.
		if defined(!sa1) == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif

		!HexDecDigitTable = $02
		if !sa1 != 0
			!HexDecDigitTable = $04
		endif
	main:
	REP #$20
	LDA !RAMToMeasure
	STA $00
	SEP #$20
	JSL HexDec_SixteenBitHexDec
	
	if !StatusbarFormat == $01
		LDX.b #(!NumberOfDigitsDisplayed-1)
		-
		LDA.b !HexDecDigitTable+$04-(!NumberOfDigitsDisplayed-1),x
		STA !StatusBarPosition,x
		DEX
		BPL -
	else
		LDX #((!NumberOfDigitsDisplayed-1)*2)
		LDY #(!NumberOfDigitsDisplayed-1)
		-
		LDA.w (!HexDecDigitTable)+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
		STA !StatusBarPosition,x
		DEY
		DEX #2
		BPL -
	endif
	RTL</pre></td></tr></table><br>
	
	Greater than 65535? (unlikely for other stuff besides a huge currency counter or custom score). This one is a 32-bit HexDec, up to
	4,294,967,295 can be properly displayed.
<table><tr><td><pre>!RAMToMeasure = $60			;>RAM address you what to show
!StatusBarPosition = $0F09|!addr	;>Where to write on the status bar
!StatusbarFormat = $01			;>$01 = [TTTTTTTT, TTTTTTTT,...], $02 = [TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]
;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;>How many digits, enter 1-10 (pointless if you enter less than 5).

	;Don't change this.
		if defined("sa1") == 0
			if read1($00FFD5) == $23
				!sa1 = 1
				sa1rom
			else
				!sa1 = 0
			endif
		endif
	;Copied defines from the routines in case of errors.
		!MaxNumberOfDigits = 9
		;^Number of digits to be stored. Up to 10 because maximum
		; 32-bit unsigned integer is 4,294,967,295.
		
		!Scratchram_32bitHexDecOutput = $7F844E
		;^[bytes_used = !MaxNumberOfDigits] The output
		; formatted each byte is each digit 0-9.
	main:
	REP #$20
	LDA $60
	STA $00
	LDA $62
	STA $02
	SEP #$20
	JSL HexDec_Convert32bitIntegerToDecDigits
	
	if !StatusbarFormat == $01
		LDX.b #(!NumberOfDigitsDisplayed-1)
		-
		LDA !Scratchram_32bitHexDecOutput+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
		STA !StatusBarPosition,x
		DEX
		BPL -
	else
		LDX #((!NumberOfDigitsDisplayed-1)*2)
		LDY #(!NumberOfDigitsDisplayed-1)
		-
		PHX
		TYX												;&gt;Sigh, LDA $xxxxxx,y does not exist.
		LDA (!Scratchram_32bitHexDecOutput)+(!MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1)|!dp,x
		PLX
		STA !StatusBarPosition,x
		DEY
		DEX #2
		BPL -
	endif
	RTL</pre></td></tr></table><br>
	
Don't ask me to make an even larger number display, because not many games would ever display 10 digits at once, plus, it takes up space on the HUD.</p>

<h4>Removing leading zeroes</h4>
<p>Perhaps, how these routines work is that if there are no more digits left, will output 0. However, you can erase these leading zeroes like so by adding
this code after the JSL routine and before writing them to the status bar:
<table><tr><td><pre>	RemoveLeadingZeroes:
	LDX #$00
	
	.Loop
	LDA !DigitTable,x		;\if current digit non-zero, don't omit trailing zeros
	BNE .NonZero			;/
	LDA #$FC			;\blank tile to replace leading zero
	STA !DigitTable,x		;/
	INX				;>next digit
	CPX #!NumberOfDigitsDisplayed-1	;>last digit to check. So that it can display a single 0.
	BCC .Loop			;>if not done yet, continue looping.
	
	.NonZero
	RTL</pre></td></tr></table>
	Replace &ldquo;<kbd>!DigitTable</kbd>&rdquo; with &ldquo;<kbd>!Scratchram_32bitHexDecOutput</kbd>&rdquo; if you are using the 32-bit HexDec.
	
</p>
<h2 id="RepatedSymbol"><a href="#RepatedSymbolBack">^</a>Displaying repeated symbols n times</h2>
<p>You probably have seen something like this that represents n/max number of things graphically:<br>
<font size="10">&#9642;&#9642;&#9642;&#9642;&#9643;</font><br>
This is often used to represent things that are small number of units. Code follows:
<table><tr><td><pre>!MaxNumberOfSymbols = 5
!StatusBarPosition = $0EF9|!addr
!RAMToMeasure = $60
!StatusbarFormat = $01

;Tile numbers
	!EmptyTile = $00
	!FullTile = $01

	main:
	LDX #$00
	
	.Loop
	TXA				;\If tile index is >= Amount (or Amount is less than index), write empty.
	CMP !RAMToMeasure		;/
	BCS ..Empty
	
	..Full
	LDA #!FullTile
	BRA +
	
	..Empty
	LDA #!EmptyTile
	
	+
	STA !StatusBarPosition,x
	INX #!StatusbarFormat
	TXA						;\Didn't use INX : BNE .Loop for failsafe should X goes past the max amount.
	CMP.b #!MaxNumberOfSymbols*!StatusbarFormat	;|
	BCC .Loop					;/
	RTL</pre></td></tr></table><br>
You can copy and paste this, and tweek the values if you want multiple repeated icons displays.</p>
<hr>
<h2>Further documentation</h2>
<p>SMW (or the SNES in general) have layer 3 stored as <kbd>2BPP</kbd> format. Meaning that each pixel will take 2 bits. 2 Bits will give you 4 possible values; 0-3</p>

<script>
	function Calculate() {
		//SMW status bar table
			var LoopCount = 0
			var CurrentRowYPos = 2
			var StartOfLineXPos = 2
			var OnSecondRow = 0
			var StatusBarAddress = parseInt("0EF9", 16)
			if (document.getElementById("SA1ROM").checked == true) {
				StatusBarAddress = parseInt("6EF9", 16)
			}
			var Output = ""
			Output += "<table>"
			Output += "<tr><th>Tile number/index</th><th>Coordinate</th><th>RAM address</th><th>default tiles and properties ROM address (%TTTTTTTT, %YXPCCCTT)</th></tr>"
			for (LoopCount = 0; LoopCount < 55; LoopCount++) {
				if (LoopCount == 28) {
					Output += "<tr><th colspan='4'>Second line</th></tr>"
					CurrentRowYPos = 3
					StartOfLineXPos = 3
					OnSecondRow = 28
				}
				Output += "<tr>"
				Output += "<td><kbd>" + LoopCount.toString(10) + "</kbd> (<kbd>$" + LoopCount.toString(16).toUpperCase() + "</kbd>)</td>"
				Output += "<td><kbd>(" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(10) + "," + CurrentRowYPos.toString(10) + ")</kbd> (<kbd>($" + (StartOfLineXPos+(LoopCount-OnSecondRow)).toString(16).toUpperCase() + ",$" + CurrentRowYPos.toString(16).toUpperCase() + ")</kbd>)</td>"
				Output += "<td><kbd>$" + pad((StatusBarAddress+LoopCount).toString(16).toUpperCase(), 4) + "</kbd></td>"
				Output += "<td><kbd>$00" + (parseInt("8C89", 16)+(LoopCount*2)).toString(16).toUpperCase() + "</kbd>, <kbd>$00" + ((parseInt("8C89", 16)+(LoopCount*2))+1).toString(16).toUpperCase() + "</kbd></td>"
				Output += "</tr>"
			}
			Output += "<table>"
			document.getElementById("SMWStatusBarTable").innerHTML = Output
		
	}
	function pad(num, size) {
		var s = num+"";
		while (s.length < size) s = "0" + s;
		return s;
	}
</script>