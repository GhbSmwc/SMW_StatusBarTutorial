<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			div.CodeBlock {
				overflow: auto;
				width: 1000px;
				height: 500px;
				border: 1px solid white;
				resize: both;
				background-color: #101010;
			}
			pre {
				margin-top: 0px;
			}
			
			abbr{cursor: help;}
		</style>
	</head>
<body onload="Calculate()" style="max-width: 1000px; margin: auto; padding: 15px">
<center><h1>How to use the status bar</h1></center>
<hr>
<p>So you want to edit the HUD to display custom info to the player. Obviously, this requires at least basic ASM knowledge. Fear not! Once you got the pattern down, you'll understand how it works!</p>

<p>You should know these before doing this:</p>
<ul>

<li><p>Ersanio's ASM tutorial<sup><a href="https://www.smwcentral.net/?p=section&a=details&id=15073">[1]</a><a href="https://www.smwcentral.net/?p=section&a=details&id=14268">[2]</a></sup>
on something simple as how to write a value to memory. You should also know about binary and hexidecimal, since many data explained here stored in memory are bitwise (mainly the tile properties).</p></li>

<li><p>Understand the mechanics of <a href="https://www.smwcentral.net/?p=section&a=details&id=19043">Asar</a>, such as defines and labels.</p></li>

</ul>

<p>If you want to easily copy codes (or any text displayed like a text editor) presented here, hold down CTRL and double-click them and CTRL+C.</p>
<hr>
<h2>Table of contents and other links</h2>
<h3>Quick navigation</h3>
<ul>
	<li><a href="#WarmUp" id="WarmUpBack">The warm-up: SMW's status bar.</a></li>
	<li><a href="#StuffYouMayNeed" id="StuffYouMayNeedBack">Stuff you may need</li>
	<li><a href="#TileFormat" id="TileFormatBack">Tile data format</a></li>
	<li><a href="#SBPatches" id="SBPatchesBack">Other status bar patches</a></li>
	<li><a href="#RoutineControl" id="RoutineControlBack">Adding routine-controlled display to the HUD.</a></li>
	<ul>
		<li><a href="#DisplayNumbers" id="DisplayNumbersBack">Displaying decimal numbers</a></li>
		<ul>
			<li><a href="#RemoveLeadingZeroes" id="RemoveLeadingZeroesBack">Remove leading zeroes (leading spaces)</a></li>
		</ul>
		<ul>
			<li><a href="#AlignedDigits" id="AlignedDigitsBack">Remove Leading zeros, with left/right-aligned digits</a></li>
			<ul>
				<li><a href="#RightAligned" id="RightAlignedBack">Right aligned display</a></li>
			</ul>
			<li><a href="#IncrementDecrementAnimation" id="IncrementDecrementAnimationBack">Counting animation</a></li>
			<li><a href="#Frames2Timer" id="Frames2TimerBack">Display a timer in Hours:Minutes:Seconds:Centiseconds format</a></li>
			<li><a href="#Percentage" id="PercentageBack">Display a percentage</li>
		</ul>
		<li><a href="#RepeatedSymbol" id="RepeatedSymbolBack">Displaying repeated symbol n times.</a></li>
		<li><a href="#GraphicalBar" id="GraphicalBarBack">Display a graphical bar</a></li>
	</ul>
	<li><a href="#OverworldBorder" id="OverworldBorderBack">Displaying stuff on the overworld border</a></li>
	<li><a href="#OAMHud" id="OAMHudBack">Sprite-based HUD</a></li>
	<ul>
		<li><a href="#PixiSprite" id="PixiSpriteBack">Pixi sprites</a></li>
		<li><a href="#HUDSprites" id="HUDSpritesBack">HUD-like sprites</a></li>
	</ul>
	<li><a href="#StripeHud" id="StripeHudBack">Stripe-based HUD</a></li>
	<li><a href="#OtherNotes" id="OtherNotesBack">Other Notes</a></li>
	<li><a href="#Credits" id="CreditsBack">Credits</a></li>
</ul>
<h3 id="StuffYouMayNeed"><a href="#StuffYouMayNeedBack">^</a>Stuff you may need</h3>
<p>These are resources that enhances the layer 3 HUD, usually if you need advanced stuff:</p>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super status bar</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld border +</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=21562">Minimalist status bar(s)</a></li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3 status bar</a></li>
</ul>

<p>Sprite OAM for HUD-related stuff:</p>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=26026">Pixi</a></li>
</ul>

<p>Patching tool:</p>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=25953">Asar</a>, for inserting various patches and the sprite HUD patch included.</li>
</ul>
<p>Other</p>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=19545">Shared Subroutines</a>, if you are running low on space in your hack. Currently, they work on its own without the shared subroutines. To migrate,
Here is the <a href="Readme_Files/GettingSharedSubToWork.html" id="SharedSubroutinesBackToTOC">template here you can copy</a>.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=24816">No More Sprite Tile Limits</a>, unless you installed SA-1. Vanilla SMW had horrible sprite tile limits resulting tiles going missing when having
certain sprite combinations on screen.</li>
</ul>

<h3>Javascript tools</h3>
<ul>
	<li>
		<a href="Readme_Files/TileDataAddr.html" id="QuickJSTools_TileDataAddr">S-PPU tile addressing tool</a>
	</li>
	<li>
		<a href="Readme_Files/JS_YXPCCCTT.html" id="QuickJSTools_JS_YXPCCCTT">Quick Hex &harr; Binary converter for YXPCCCTT bit format (layer 3).</a>
	</li>
	<li>
		<a href="Readme_Files/JS_YXPPCCCT.html" id="QuickJSTools_JS_YXPPCCCT">Quick Hex &harr; Binary converter for YXPPCCCT bit format (sprite OAM).</a>
	</li>
	<li>
		<a href="Readme_Files/JS_FrameToTimer.html" id="QuickJSTools_JS_FrameToTimer">Convert 32-bit frame to and from timer format.</a>
	</li>
	<li>
		<a href="Readme_Files/JS_32BitHexDecRAMUsage.html" id="32BitHexDec_BackTOC">32-bit Hexdec memory layout.</a>
	</li>
	<li>
		<a href="Readme_Files/JS_StripeHeaderConverter.html" id="Stripe_BackTOC">Stripe header reader</a>
	</li>
</ul>

<hr>
<p>I have provided several routines to make writing codes much user-friendly as possible. So lets begin.</p>
<h2 id="WarmUp"><a href="#WarmUpBack">^</a>The warm-up: SMW's status bar.</h2>
<p>Here, consider looking at this image:<br>
<img src="Readme_Files/StatusBarMap.png"><br>
RAM address <kbd>$7E0EF9-$7E0F2E</kbd> controls what tile to display. How do you modify it? Well you edit the
contents in the mentioned RAM address. There are 2 ways you can edit RAM addresses:
<ul>
<li>Most recommended: a debugger, specifically, <a href="https://github.com/SourMesen/Mesen2">Mesen</a>. After running your game on the emulator, go to the menu bar, &ldquo;Debug&rdquo; &rightarrow; &ldquo;Memory Viewer&rdquo;. On the
memory viewer window, go to &ldquo;Search&rdquo; &rightarrow; &ldquo;Go to Address&rdquo; It should now scroll to that address. From here, type in the hexadecimal number.<br>
<img src="Readme_Files/MemoryEditorAddress.png"></li>
<li>Create an ASM file to run under <a href="https://www.smwcentral.net/?p=section&a=details&id=19982">uberasm tool</a> as <kbd>level</kbd> under <kbd>main:</kbd> label, and just use <kbd>LDA #$&lt;Number_00_to_FF&gt; : STA $&lt;Number_0EF9_to_0F2F&gt;|!addr</kbd>.</li>
</ul>

Now, for the RAM address, each byte is each 8x8 tile, meaning each time you go to the next address, its the next 8x8 tile number:<br><br>
<table id="SMWStatusBarTable"></table><br>
All of these bytes stored in RAM <kbd>$7E0EF9-$7E0F2F</kbd> are <kbd>TTTTTTTT</kbd>, which means you can only modify the tile number through RAM in-game. You may be wondering, if I wanted to edit the tiles here,
what value should I put? Well, <kbd>TTTTTTTT</kbd> is actually <i>what tile number to use</i>, from the tile data. When viewing the tile data stored in <kbd>GFX28.bin</kbd> file via <a href="https://www.smwcentral.net/?p=section&a=details&id=15671">YY-CHR</a>,
you can find what tile graphic to use by hovering your mouse over the 8x8 tile you want to use. After this, you should see on the bottom bar of the window showing what tile number that is:<br>
<img src="Readme_Files/TileNumber.png"><br>
Of course, you can view the tile &ldquo;number&rdquo; with Mesen's &ldquo;Tile Viewer&rdquo; (Debugger &rightarrow; Tile viewer (not to be confused with tile<b>map</b> viewer)), it will only display its <i>tilemap address</i> on the right panel as well as the hover on your mouse cursor.
I've made a conversion <a id="TileDataAddr" href="Readme_Files/TileDataAddr.html">cheatsheet here</a>.

Now you have the value you need. Just write that desired tile number to any tile number you want to write (either debugger or uberasm, if uberasm tool, you have to save, insert to your game, and run it to view the changes). For example, to write an
item box corner tile on the left of the top row, then it is tile number <kbd>$3A</kbd> to write at <kbd>$7E0EF9</kbd>, if using uberasm tool, its <kbd>LDA #$3A : STA $0EF9|!addr</kbd>.</p>

<p>Please note that graphic files in these <kbd>.bin</kbd> covers half a page, and are always displayed at the top-half of that page on YY-CHR (assuming you have the &ldquo;Use Joined GFX files&rdquo; in the &ldquo;ROM Editing Options&rdquo; unchecked). And YY-CHR
always have the tile numbering start at <kbd>$00</kbd> on the top left of that page, even when that graphic file is used on the page's bottom half when used in the game. If that's the case, you can convert the YY-CHR's top-half-only numbering to bottom-half by
simply adding its tile number shown by the program by <kbd>$80</kbd>. For example, The big zero (used by the bonus stars counter) top-half is tile <kbd>$37</kbd> in <kbd>GFX2A.bin</kbd> in YY-CHR, but when loaded into the game, it is <kbd>$37 + $80 = $B7</kbd>.</p>

<p>Now hold up, when you play around with the tiles, many tiles will use the wrong palette, well, this is part of the tile properties (in binary, its <kbd>%YXPCCCTT</kbd>) that's hard-coded, that's right, there are actually 2 bytes of information
for each 8x8 tile with the tile numbers being in ROM and RAM and the properties all being hardcoded. When the level loads, the status bar routine will first transfer default tile number and properties from ROM addresses <kbd>$008C81-$008CFE</kbd>,
which contains all the tiles for the status bar, while the RAM itself only contain some of the tile numbers. To modify hardcoded tiles, I've already presented their addresses that directly correlates to the RAM addresses, for the top and bottom
lines of the item box:
<table>
<tr><th>Coordinate</th><th>Address (%TTTTTTTT, %YXPCCCTT)</th></tr>
<tr><th colspan="2">Top line of item box</th></tr>
<tr><td><kbd>(14,1)</kbd> (<kbd>($E,$1)</kbd>)</td><td><kbd>$008C81</kbd>, <kbd>$008C82</kbd></td></tr>
<tr><td><kbd>(15,1)</kbd> (<kbd>($F,$1)</kbd>)</td><td><kbd>$008C83</kbd>, <kbd>$008C84</kbd></td></tr>
<tr><td><kbd>(16,1)</kbd> (<kbd>($10,$1)</kbd>)</td><td><kbd>$008C85</kbd>, <kbd>$008C86</kbd></td></tr>
<tr><td><kbd>(17,1)</kbd> (<kbd>($11,$1)</kbd>)</td><td><kbd>$008C87</kbd>, <kbd>$008C88</kbd></td></tr>
<tr><th colspan="2">bottom line of item box</th></tr>
<tr><td><kbd>(14,4)</kbd> (<kbd>($E,$4)</kbd>)</td><td><kbd>$008CF7</kbd>, <kbd>$008CF8</kbd></td></tr>
<tr><td><kbd>(15,4)</kbd> (<kbd>($F,$4)</kbd>)</td><td><kbd>$008CF9</kbd>, <kbd>$008CFA</kbd></td></tr>
<tr><td><kbd>(16,4)</kbd> (<kbd>($10,$4)</kbd>)</td><td><kbd>$008CFB</kbd>, <kbd>$008CFC</kbd></td></tr>
<tr><td><kbd>(17,4)</kbd> (<kbd>($11,$4)</kbd>)</td><td><kbd>$008CFD</kbd>, <kbd>$008CFE</kbd></td></tr>
</table>
If you modify these hardcoded values through a debugger, the changes will only apply on the next level reload, since the hardcoded upload only occurs on level load.</p>

<p>You may be wondering, why did I include the tile coordinate in these tables? Well, is because of Mesen (or any emulator debugger)'s ability to display the tile coordinates (in this debugger, they're called &ldquo;Column, Row &rdquo; and are in decimal)
in the tilemap viewer (Debug &rightarrow; Tilemap viewer, and select &ldquo;Layer 3&rdquo;):<br>
<img src="Readme_Files/TileCoordinate.png"><br>
and then you can use that coordinate and CTRL+F here on this HTML file to locate what RAM/ROM address to modify, which is way easier than to trial-and-error modifying each address to find the desired location.</p>

<p>Furthermore, I also included a function for the asar assembler to auto-convert coordinates to tile data address: in <kbd>StatusBarDefines.asm</kbd>, at the bottom (<kbd>PatchedStatusBarXYToAddress</kbd> and
<kbd>VanillaStatusBarXYToAddress</kbd>). See for yourself.</p>

<p>I've also provided a patch, <kbd>DefaultTiles.asm</kbd> which is intended to be an ASM patch version of the <a href="https://www.smwcentral.net/?p=section&a=details&id=4580">SMW status bar editor tool</a>.</p>
<hr>
<h2 id="TileFormat"><a href="#TileFormatBack">^</a>Tile data format</h2>
<p>As explained earlier about the palette issue, and that each 8x8 tile possess 2 bytes, I'll give you a summary of the entire tile data:
<ul>
	<li>
		<kbd>TTTTTTTT</kbd> is the tile number (previously explained already), refers to what tile to use from the tile stored in VRAM. Note that this alone is the tile number within a page.
	</li>
	<li>
		<kbd>YXPCCCTT</kbd> is the tile properties:
		<ul>
			<li>
				<kbd>TT</kbd> (ranges from 0-3): Page number. This is technically the upper bits of the tile number, which is why I use the same <kbd>T</kbd> instead
				another letter, therefore 10 bits used for the tile number (referred to as &ldquo;character&rdquo; in the debugger and the SNES dev manuel),
				but we refer the upper 2 bits as the page number, while the lower 8 bits as the tile number (within a page):<br>
				<img src="Readme_Files/PageNumberTT.png">
			</li>
			<li>
				<kbd>CCC</kbd> (ranges from 0-7): Palette number. This refers to what group-4 on the palette to use:<br>
				<img src="Readme_Files/PaletteCCC_0_7.png">
			</li>
			<li>
				<kbd>P</kbd> (0 or 1): Priority (1 is above everything or 0 is behind). Usually these are SET to prevent things (such as sprites,
				layer 1 or layer 2 (including those if they have priority)) from overlapping the HUD.
				For example, the bonus star symbol with and without priority against a cloud tile:<br>
				<img src="Readme_Files/PriorityP.png">
			</li>
			<li>
				<kbd>X</kbd> (0 or 1): X-flip. i.e: <img src="Readme_Files/HorizFlipX.png">
			</li>
			<li>
				<kbd>Y</kbd> (0 or 1): Y-flip. i.e: <img src="Readme_Files/VertiFlipY.png">
			</li>
		</ul>
	</li>
</ul>
I've made a <a href="Readme_Files/JS_YXPCCCTT.html" id="JS_YXPCCCTT">simple converter</a> since most debuggers only allow hex for editing and viewing values.

Now there are 2 formats on how a pair of bytes are being stored. SMW uses both, where default tiles are the &ldquo;2-bytes together&rdquo; format while RAM address <kbd>$7E0EF9-$7E0F2E</kbd>
are &ldquo;TileNumber and Props in their own table&rdquo; format but without the properties.
<table>
<tr>
<th>TileNumber and Props in their own table</th>
<th>2-bytes together</th>
</tr>
<tr>
<td><div class="CodeBlock" style="width: 300px; height: 100px"><pre>!TileNumbAddr: TTTTTTTT (tile 0)
!TileNumbAddr+1: TTTTTTTT (tile 1)
!TileNumbAddr+2: TTTTTTTT (tile 2)
!TileNumbAddr+3: TTTTTTTT (tile 3)
[...]</pre></div>
On a separate table:
<div class="CodeBlock" style="width: 500px; height: 150px"><pre>!TilePropAddr: YXPCCCTT (tile 0)
!TilePropAddr+1: YXPCCCTT (tile 1)
!TilePropAddr+2: YXPCCCTT (tile 2)
!TilePropAddr+3: YXPCCCTT (tile 3)
[...]
;I refer this as "[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]"</pre></div><br>
Tile numbers and properties are stored in 2 separate tables, one for each.
Every time you advance the next byte, you are on the next 8x8 tile.
</td>

<td><div class="CodeBlock" style="width: 500px; height: 200px"><pre>!TileAddr: TTTTTTTT (tile 0)
!TileAddr+1: YXPCCCTT (tile 0)
!TileAddr+2: TTTTTTTT (tile 1)
!TileAddr+3: YXPCCCTT (tile 1)
!TileAddr+4: TTTTTTTT (tile 2)
!TileAddr+5: YXPCCCTT (tile 2)
!TileAddr+6: TTTTTTTT (tile 3)
!TileAddr+7: YXPCCCTT (tile 3)
[...]

;I call refer this as "[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]"</pre></div><br>
Every tile have 2 bytes placed one after another, so both tile numbers and properties are alternating
every byte. Therefore, to get to the next 8x8 tile, is a move of 2 bytes instead of one.

</td>
</tr>
</table>
</p>

<p>I've made a &ldquo;friendly hex-edit&rdquo; patch included in this package called <kbd>DefaultTiles.asm</kbd>, which is an alternative to
<a href="https://www.smwcentral.net/?p=section&a=details&id=4580">Smallhacker's status bar editor patch</a>.</p>

<hr>
<h2 id="SBPatches"><a href="#SBPatchesBack">^</a>Other status bar patches</h2>
<p>Because SMW's status bar is extremely limited, other users decided to make status bar patches:
<ul>
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=19247">Super Status Bar</a>. This gives you a 32x5 8x8 tile area,
	therefore 160 8x8 tiles to edit.<sup>1</sup> Most example ASM codes provided here assumes you are using this patch, so far, has the biggest editing zones available.</p></li>
	
	<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21665">Overworld Border +</a>. Not a &ldquo;status bar&rdquo;, but similar
	in terms of editing the layer 3 8x8 tiles. This gives you <kbd>32*!TopLines</kbd> (for the top of the screen) and <kbd>32*!BottomLines</kbd> (for the bottom of the screen)
	8x8 tile area, therefore, up to 224 8x8 tiles you can edit.<sup>1</sup> <kbd>!TopLines</kbd> is how many lines for the top of the screen, an integer 0-5.
	<kbd>!BottomLines</kbd> is same as previously mentioned, but for the bottom of the screen being an integer 0-2.</p></li>
	
<li><p><a href="https://www.smwcentral.net/?p=profile&id=4842">Ladida</a>'s status bar patches<sup>2</sup></p></li>
	<ul>
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21562">Minimalist Status Bars</a>. This shrinks your status bar to 1 or
		2 lines of 8x8 tiles. Therefore, 32 or 64 tiles you can edit.</p></li>
		
		<li><p><a href="https://www.smwcentral.net/?p=section&a=details&id=21573">SMB3 Status Bar</a>. True to the name, this replaces SMW's HUD with
		SMB3's HUD on the bottom of the screen. This gives you a 32x4 8x8 tile area, therefore 128 8x8 tiles to edit</p></li>
	</ul>
</ul>

<p>You may be wondering:
<ul>
<li><sup>1</sup>Uses the &ldquo;2-bytes together&rdquo; format, the <kbd>[TTTTTTTT, YXPCCCTT, TTTTTTTT, YXPCCCTT...]</kbd></li>
<li><sup>2</sup>Uses the &ldquo;TileNumber and Props in their own table&rdquo; format, the <kbd>[TTTTTTTT, TTTTTTTT,...], [YXPCCCTT, YXPCCCTT,...]</kbd></li>
</ul>
Therefore, many ASM patches that display on the status bar that I made are hybrid-support of these two formats. The define <kbd>!StatusbarFormat</kbd> is what
you need to edit to work with other status bar patches, set it to <kbd>$01</kbd> if &ldquo;TileNumber and Props in their own table&rdquo; otherwise set it to
<kbd>$02</kbd>. In case if you are wondering why there are duplicate routines (<abbr title="For &ldquo;TileNumber and Props in their own table">a normal version</abbr> and <abbr title="For &ldquo;2-bytes together&rdquo;">a version with &ldquo;Format2&rdquo; appended to the end of
the subroutine label</abbr>) in the ASM files is because in case if you are designing a hack that have the status bar patch using the &ldquo;TileNumber and Props in
their own table&rdquo; format and the overworld border plus patch, which your hack is now using BOTH formats.</p>

<p>Thankfully, I made HTML Javascript files for all of these ASM resources to enable you to search what RAM address of a given tile.</p>

</p>
<hr>
<h2 id="RoutineControl"><a href="#RoutineControlBack">^</a>Adding routine-controlled display to the HUD.</h2>
<p>Now we are REALLY into using the status bar and ASM.</p>

<p>This method assumes you are using uberasm tool to test your code to write to the status bar. The first thing you want to do is have all the ASM files, except &ldquo;<kbd>OAMBasedHUD.asm</kbd>&rdquo;, in &ldquo;<kbd>StatusBarRoutines</kbd>&rdquo;
inserted into uberasm tool's &ldquo;<kbd>library</kbd>&rdquo; folder, and have the entire folder &ldquo;<kbd>StatusBarRoutinesDefines</kbd>&rdquo; be in the same directory as the uberasm tool exe program is at.</p>

<p>Feel free to look into the library ASM files, since I added descriptions and comments to give a better understanding how they work.</p>

<p>NOTE: most codes provided here do not modify the tile properties in any way, since very unlikely that many hacks would ever modify the tile properties. If you happen to have 2+ displays using the same tile(s) (such as
the score gets covered by boss's heath bar that only shows up during bosses) and are using different tile properties, don't forget to switch the YXPCCCTT data back else you had whatever last written to the YXPCCCTT data.
(even better is to make any of the counters using that same space to always write their own YXPCCCTT when their TTTTTTTT is written).</p>

<p>You also need to insert the graphic file from this provided <kbd>ExGFX</kbd> folder (<kbd>ExGFX80.bin</kbd>) because many of the stuff here uses a graphic not provided by SMW, such as the &ldquo;/&rdquo; symbol when displaying
2 numbers, and the &ldquo;%&rdquo; symbol representing a percentage. It should be inserted as &ldquo;LG1&rdquo; on the layer 3 GFX.</p>

<p>Before we start using the subroutines, we will demonstrate how to write tiles that change based on a given info <kbd>!Freeram_ValueDisplay1_1Byte</kbd>. It's very easy to write a tile that is different depending on
a condition using branches:
<div class="CodeBlock" style="width: 500px; height: 210px"><pre>incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	BNE +
	LDA #$00
	BRA ++
	+
	LDA #$01
	++
	STA !StatusBar_TestDisplayElement_Pos_Tile
	RTL</pre></div><br>
and if you are tired of using branches, then an even simpler approach is to use tables:
<div class="CodeBlock" style="width: 700px; height: 300px"><pre>incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	TAX
	LDA Table,x
	STA !StatusBar_TestDisplayElement_Pos_Tile
	RTL
	
	Table:
	db $0A ;&gt;When !Freeram_ValueDisplay1_1Byte = $00
	db $0B ;&gt;When !Freeram_ValueDisplay1_1Byte = $01
	db $0C ;&gt;When !Freeram_ValueDisplay1_1Byte = $02
	
	;If !Freeram_ValueDisplay1_1Byte contains values greater than $02,
	;it will read past the last byte of the table into unrelated (garbage) data.</pre></div></p>
	
<p>But what about other not-so-simple displays? Well, the following shows you how to do that.</p>

<h3 id="DisplayNumbers"><a href="#DisplayNumbersBack">^</a>Displaying decimal numbers</h3>

<p>To display a single digit, just store the value directly to the tile RAM. Digits are correctly displayed if the value is 0-9. Any value greater than 9 will display other symbol or graphics besides digits.</p>

<p>But how do you display multi-digits on the status bar? Well, you need to have a code that obtain decimal digits that wraps at every 10<sup>n</sup> unit.
(ones place reset every 10s, 10s digit resets every 100th value, and the 1000s digit resets every 10000s, and so on). The routines, <kbd>HexDec</kbd> converts a given number to
<a href="https://en.wikipedia.org/wiki/Binary-coded_decimal">binary-coded decimal (BCD, unpacked)</a> to write each digit tiles onto the status bar. Thankfully,
the status bar graphic tiles on GFX28 starts with digits 0-9 so you don't have to convert digit numbers to digit graphics.</p>

<p>Note that all of them treats the number as unsigned (negatives don't exists, you'll
have to &ldquo;negate&rdquo; the number by EOR $FF/$FFFF, then INC it (for 32-bit number do EOR $FFFF twice in 16-bit mode for both low and high words, increment the low word by 1, and if it overflows past $FFFF, carry
should increment the highword), before calling the routine, and also write the minus sign (tile $27) to represent a negative number. However, this really isn't that necessary, negative numbers are RARELY used in video games).</p>

<p>Another note is that leading zeroes do exist, if there are fewer digits than the maximum number of digits of a given subroutine.</p>

<p>Here is a cheatsheet of all the HexDec routines in <kbd>HexDec.asm</kbd>:
<table>
	<tr>
		<th>Subroutine</th><th>Maximum number of digits</th><th>Input</th><th>Output</th>
	</tr>
	<tr>
		<td><kbd>EightBitHexDec</kbd></td>
		<td><kbd>2</kbd> (or <kbd>3</kbd> when called again for the hundreds)</td>
		<td>A (8-bit/1-byte)</td>
		<td>
			<table>
				<tr>
					<th>Output</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><kbd>A register</kbd> (8-bit)</td>
					<td>1s place</td>
				</tr>
				<tr>
					<td><kbd>X index</kbd> (8-bit)</td>
					<td>10s place, if the input <kbd>A register</kbd> is &gt;99, will start using values beyond 9, which picks graphics besides numbers.</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td><kbd>EightBitHexDec3Digits</kbd></td>
		<td><kbd>3</kbd></td>
		<td>A (8-bit/1-byte)</td>
		<td>
			<table>
				<tr>
					<th>Output</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><kbd>A register</kbd> (8-bit)</td>
					<td>1s place</td>
				</tr>
				<tr>
					<td><kbd>X index</kbd> (8-bit)</td>
					<td>10s place</td>
				</tr>
				<tr>
					<td><kbd>Y index</kbd> (8-bit)</td>
					<td>100s place</td>
				</tr>
			</table>
		</td>
	</tr>
	<tr>
		<td><kbd>SixteenBitHexDecDivision</kbd></td>
		<td><kbd>5</kbd></td>
		<td><kbd>$00</kbd>-<kbd>$01</kbd> (16-bit/2-byte)</td>
		<td>
			<table>
				<tr><th>Relative to RAM being defined</th><th>RAM used in LoROM</th><th>RAM used under SA-1</th><th>Place value</th></tr>
				<tr><td><kbd>!Scratchram_16bitHexDecOutput+0</kbd></td><td><kbd>$02</kbd></td><td><kbd>$04</kbd></td><td>10,000s place</td></tr>
				<tr><td><kbd>!Scratchram_16bitHexDecOutput+1</kbd></td><td><kbd>$03</kbd></td><td><kbd>$05</kbd></td><td>1,000s place</td></tr>
				<tr><td><kbd>!Scratchram_16bitHexDecOutput+2</kbd></td><td><kbd>$04</kbd></td><td><kbd>$06</kbd></td><td>100s place</td></tr>
				<tr><td><kbd>!Scratchram_16bitHexDecOutput+3</kbd></td><td><kbd>$05</kbd></td><td><kbd>$07</kbd></td><td>10s place</td></tr>
				<tr><td><kbd>!Scratchram_16bitHexDecOutput+4</kbd></td><td><kbd>$06</kbd></td><td><kbd>$08</kbd></td><td>1s place</td></tr>
			</table>
		</td>
	</tr>
	<tr>
		<td><kbd>ThirtyTwoBitHexDecDivision</kbd></td>
		<td><kbd>1</kbd>-<kbd>10</kbd> digits, defined as <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd></td>
		<td><kbd>$00</kbd>-<kbd>$03</kbd> (32-bit/4-byte)</td>
		<td>
			<kbd>!Scratchram_32bitHexDecOutput</kbd> to <kbd>!Scratchram_32bitHexDecOutput+(!Setting_32bitHexDec_MaxNumberOfDigits-1)</kbd>: Contains value 0-9 on every byte,
			in decreasing significant digits (last byte is always the 1s place). Formula to get what RAM of a given digit:<br><br><kbd>!Scratchram_32bitHexDecOutput+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(DigitIndex)</kbd><br><br>
			Where <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> indicates the largest number of digits in your entire hack, up to 10.<br>
			Where <kbd>DigitIndex</kbd>, ranging from 0 to <kbd>!Setting_32bitHexDec_MaxNumberOfDigits-1</kbd> represent which digit in positional notation:
			<ul>
				<li>DigitIndex = 0: 1s</li>
				<li>DigitIndex = 1: 10s</li>
				<li>DigitIndex = 2: 100s</li>
				<li>DigitIndex = 3: 1,000s</li>
				<li>DigitIndex = 4: 10,000s</li>
				<li>...</li>
				<li>DigitIndex = 9: 1,000,000,000s (maximum unsigned 32-bit integer is 4,294,967,295)</li>
			</ul>
			
			Due to the maximum number of digits giving out such a huge combinations, I provided <a href="Readme_Files/JS_32BitHexDecRAMUsage.html" id="32BitHexDec_Back">this JS tool</a> that you can adjust to find out its data layout.
		</td>
	</tr>
	<tr>
		<td><kbd>SupressLeadingZeros</kbd>, <kbd>SupressLeadingZerosPercentageLeaveLast2</kbd>, <kbd>SupressLeadingZerosPercentageLeaveLast3</kbd>, and <kbd>SupressLeadingZeros32Bit</kbd></td>
		<td>
			<ul>
			<li>5 digits for <kbd>SupressLeadingZeros</kbd>, <kbd>SupressLeadingZerosPercentageLeaveLast2</kbd>, <kbd>SupressLeadingZerosPercentageLeaveLast3</kbd></li><br>
			<li>N digits, with N equal to <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> for <kbd>SupressLeadingZeros32Bit</kbd></li>
			</ul>
		</td>
		<td>
			<table>
				<tr>
					<th>Input</th>
					<th>Description</th>
				</tr>
				<tr>
					<td>
						<ul>
							<li>For <kbd>SupressLeadingZeros</kbd>, <kbd>SupressLeadingZerosPercentageLeaveLast2</kbd>, and <kbd>SupressLeadingZerosPercentageLeaveLast3</kbd>:
							<kbd>!Scratchram_16bitHexDecOutput</kbd> to <kbd>!Scratchram_16bitHexDecOutput+4</kbd> (5 bytes)
							</li><br>
							<li>For <kbd>SupressLeadingZeros32Bit</kbd>:
							<kbd>!Scratchram_32bitHexDecOutput</kbd> to <kbd>!Scratchram_32bitHexDecOutput+(!Setting_32bitHexDec_MaxNumberOfDigits-1)</kbd> (<kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> bytes)
							</li>
						</ul>
					</td>
					<td>A string of characters.</td>
				</tr>
				<tr>
					<td><kbd>X index</kbd> (8-bit)</td>
					<td>The starting location within the table to place the string in. X=$00 means the starting byte.</td>
				</tr>
				<tr>
					<td><kbd>$09</kbd> (1 byte)</td>
					<td>For only <kbd>SupressLeadingZerosPercentageLeaveLast2</kbd> and <kbd>SupressLeadingZerosPercentageLeaveLast3</kbd>, Character number for decimal point. By default status bar, it must be <kbd>#$24</kbd> to represent the decimal point, for sprite OAM, it must be <kbd>#$0D</kbd>.</td>
				</tr>
			</table>
			
			
		</td>
		<td>
			<table>
				<tr>
					<th>Output</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><kbd>!Scratchram_CharacterTileTable</kbd> to <kbd>!Scratchram_CharacterTileTable+(NumberOfChar-1)</kbd> (NumberOfChar bytes)</td>
					<td>A string (without leading zeroes)</td>
				</tr>
				<tr>
					<td><kbd>X index</kbd> (8-bit)</td>
					<td>
						The location to place string AFTER the numbers (increments every character written). Also use for indicating the last digit (or
						any tile) number for how many tiles to be written to the status bar, overworld border, etc.
					</td>
				</tr>
			</table>
		</td>
	</tr>
</table>
</p>
<p>Lets start with something very simple with small number of digits.</p>
<p>Do note that all subroutines here will always have leading zeroes stored (either as in the registers for 2-3 digits or as an array of digits for 4+ digit displays) when there are fewer
digits than the maximum by default. If you wanted to remove leading zeroes, I will explain that in the next section.</p>

<p>For the overworld border (<abbr title="So far, there isn't any other patches that lets you edit the overworld border similarly to the status bar.">assuming you're using the Overworld Border+ patch</abbr>),
which is stored in <kbd>GFX2A</kbd>, after calling the HexDec routine, you must add each digit by #$22 (<a href="Readme_Files/OWB_Digits.png" target="_blank">digit graphics are stored as tile numbers $22-$2B</a>),
and make sure you are using page 1 and not 0 on the tile properties (example, to display the number &ldquo;<span style="color: red">1</span><span style="color: blue">2</span>&rdquo;, the values must be <kbd><span style="color: red">$01</span>+$22 = $23</kbd>
for the tens and <kbd><span style="color: blue">$02</span>+$22 = $24</kbd> for the ones). I'll later explain how to display digits on the overworld border later on this document.</p>


<p>Create a text file, name it <kbd>StatusBarTest.asm</kbd>. Edit that text file to include only this code:
<div class="CodeBlock" style="width: 1000px; height: 210px"><pre>incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec					;&gt;Get digits, A = 1s, X = 10s
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	STA !StatusBar_TestDisplayElement_Pos_Tile			;&gt;Write 10s place
	RTL
</pre></div></p>

<p>Now save, and insert in either as gamemode under number 14 (level), or level. Then run the tool to apply the changes.</p>

<p>Test the game (using a debugger) by going to the level that you inserted this created ASM file (or any level if using gamemode 14), you should see the
digits displayed on the HUD. Again, palettes, X/Y flips and other weird shenanigans can happen if you use SMW's vanilla status bar without
editing the default values. Now depending on what RAM to use set by <kbd>!Freeram_ValueDisplay1_1Byte</kbd>, it could display <kbd>00</kbd> or <kbd>[&lt;digits 0-9 or glitched tile here&gt;&lt;digits 0-9&gt;]</kbd>,
then on the debugger window, go to memory editor and search for the RAM you set for <kbd>!Freeram_ValueDisplay1_1Byte</kbd> (example: <kbd>$60</kbd>, <kbd>$3060</kbd> for SA-1), edit the value in that byte to be any values $00-$63. It should
display their decimal version of the hex number:
<table>
<tr><th>Hex bytes</th><th>Displayed</th></tr>
<tr><td>$09</td><td>09</td></tr>
<tr><td>$0A</td><td>10</td></tr>
<tr><td>$0B</td><td>11</td></tr>
<tr><td colspan="2">...</td></tr>
<tr><td>$61</td><td>97</td></tr>
<tr><td>$62</td><td>98</td></tr>
<tr><td>$63</td><td>99</td></tr>
<tr><td bgcolor="red">$64</td><td bgcolor="red">A0</td></tr>
<tr><td bgcolor="red">$65</td><td bgcolor="red">A1</td></tr>
<tr><td bgcolor="red">$66</td><td bgcolor="red">A2</td></tr>
<tr><td colspan="2" bgcolor="red">(10s place digit cycles through the alphabet characters every 10th value until...)</td></tr>
<tr><td bgcolor="red">$FF</td><td bgcolor="red">P5</td></tr>
</table>
What happens if you enter numbers greater than $63? Well, when the routine is used like that, it is designed to display up to 2 digits. If the number is greater than $64, the 10s place digit start showing graphics
other than digits. This is because of how the routine works, is that the 10s place digit wasn't wrapped (wrapped, as in digits reset to 0 when going past 9: 8, 9, 0, 1 , 2...), so it can display
&ldquo;digits&rdquo; greater than 9 (98, 99, A0, A1, A2...).</p>

<p>You can fix this problem and make it allow the full range of the 8-bit value by after writing the ones digit, TXA, then call the routine again, and after that, A is the 10s, and X is the 100s place:
<div class="CodeBlock" style="width: 1000px; height: 210px"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec
	STA !StatusBar_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;&gt;Call again to get the 10s and 100s.
	JSL HexDec_EightBitHexDec
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;&gt;Write 10s place
	TXA								;&gt;STX $xxxxxx don't exists.
	STA !StatusBar_TestDisplayElement_Pos_Tile			;&gt; Write 100s place
	RTL
</pre></div><br>
How this works is that it uses <a href="https://en.wikipedia.org/wiki/Euclidean_division">euclidean division</a>. The subroutine <kbd>HexDec_EightBitHexDec</kbd>
subtract the input A by 10 repeatedly until A is less than 10, it also counts how many times it subtracted, and have that value in the X register. Because euclidean division
is essentially repeated subtraction, the output X is the quotient (rounded down) and A is the remainder. With the X register increasing every 10th value, this can represent the
10s place (since in decimal, 10s place increases at every 10th unit), and with the A register being in the 0-9 range, can represent the ones place (since real-world decimal will wrap when exceeding 9).
When handling the 100s digit, you basically divided the value by 10 again, which is <kbd>!Freeram_ValueDisplay1_1Byte/10/10</kbd>, which is the same as <kbd>!Freeram_ValueDisplay1_1Byte/(10^2)</kbd> which leads to <kbd>!Freeram_ValueDisplay1_1Byte/100</kbd>,
resulting A now being the 10s place wrapping every 100 and X increasing every 100. Because the maximum value stored in an 8-bit byte is 255, there is no way the hundreds place digit
will be able to glitch out at 1000. For more information how base conversion works, I found a wikipedia article on positional notation <a href="https://en.wikipedia.org/wiki/Positional_notation#Base_conversion">on converting radixes</a>.</p>

<p id="Left2RightHexDec">Do note that this method have a cost: The higher the number to convert to BCD, the more subtractions by 10<sup>1 &rightarrow; (NumberOfDigits-1)</sup> it would take to get all the
digits outputted, not really harsh since this is 8-bit, so up to 25 iterations for a 2-digit (plus up to 2 more for 10s and 100s by calling the HexDec routine again). However, if you
DO want speed/performance, do this instead. This works the digits from left-to-right by repeatedly subtracting 100 until A is 0-99. The number of subtractions is now how many 100s for the 100s digit, after
that, with A being 0-99, we do the same but with 10s (how many 10s) instead of 100s to find how many 10s. After that, A is 0-9 which is already the ones place:
<div class="CodeBlock" style="width: 1000px; height: 200px"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec3Digits				;&gt;Obtain 3 digits in A (1s), X (10s) and Y (100s).
	STA !StatusBar_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;\Write 10s place
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;/
	TYA								;\Write 100s place.
	STA !StatusBar_TestDisplayElement_Pos_Tile			;/
	RTL
</pre></div></p>

<p>What about if I wanted to convert 16-bit numbers (or if you have 3-5 digits and want to go above 255)? Well, good news for you, I've provided more than just 8-bit HexDec
converters. Introducing <kbd>SixteenBitHexDecDivision</kbd>. Here is the following code in question (up to 65535). Example, RAM $60 contains the value <kbd>$1234</kbd>
(in memory, its <kbd>$34, $12</kbd>), I write my 16-bit number to address <kbd>$00-$01</kbd>, then call the subroutine <kbd>SixteenBitHexDecDivision</kbd> after that,
the digits of 4660 are stored. Note that this is ordered in decreasing significant decimal digits (<abbr title="!Scratchram_16bitHexDecOutput+4">last</abbr> byte = 1s, second-last = 10s...):
<table>
<tr><th>Define relative address</th><th>RAM address (normal/Sa-1)</th><th>Output value</th></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+0</kbd></td><td><kbd>$02/$04</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 10000s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+1</kbd></td><td><kbd>$03/$05</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+2</kbd></td><td><kbd>$04/$06</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 100s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+3</kbd></td><td><kbd>$05/$07</kbd></td><td><kbd>$06</kbd> (represents &ldquo;6&rdquo; for 10s place)</td></tr>
<tr><td><kbd>!Scratchram_16bitHexDecOutput+4</kbd></td><td><kbd>$06/$08</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; 1s place)</td></tr>
</table><br>
As a side note, all &ldquo;bigger number&rdquo; (handles more bytes to handle larger values) hexdec subroutines can work with &ldquo;smaller numbers&rdquo; (less bytes) hexdec subroutines by masking out
the higher byte(s). For example: using a 16-bit hexdec, an 8-bit number #$FF, when supplied into the input, you then zero out the high byte (<kbd>STZ $01</kbd>) so that it treats the value as <kbd>#$00FF</kbd>.

Here is the code in question for you to test:</p>
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 5						;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	REP #$20
	LDA !Freeram_ValueDisplay1_2Bytes			;\Submit the value into $00-$01, the input to convert the raw binary value into BCD, unpacked.
	STA $00							;/
	SEP #$20
	JSL HexDec_SixteenBitHexDecDivision
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></div><br>
	
	<p>Greater than 65535? (unlikely for other stuff besides a huge currency counter or custom score). This one is a 32-bit (4 bytes) HexDec, up to
	4,294,967,295 (<kbd>$FFFFFFFF</kbd>) can be properly displayed. Remember, this is little endian, for example: a number
	<abbr title="287454020 in decimal">$11223344</abbr> must be inputted as
	<kbd>[$44, $33, $22, $11]</kbd> into <kbd>$00-$03</kbd> and should output as <kbd>[$02, $08, $07, $04, $05, $04, $00, $02, $00]</kbd> in
	<kbd>!Scratchram_32bitHexDecOutput</kbd>.<br>
	
	Here is an example using the previously mentioned number, with <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> set to <kbd>9</kbd>, using default <kbd>!Scratchram_32bitHexDecOutput</kbd>.
	Again, the digits stored in each byte are ordered in decreasing significant decimal digits (<abbr title="!Scratchram_32bitHexDecOutput+(!Setting_32bitHexDec_MaxNumberOfDigits-1)">last byte</abbr> is always
	the 1s place, regardless of <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd>'s value)
	<table>
	<tr><th>Define relative address</th><th>Default RAM address (normal/Sa-1)</th><th>Output value</th></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+0</kbd></td><td><kbd>$7F844E/$404140</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 100000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+1</kbd></td><td><kbd>$7F844F/$404141</kbd></td><td><kbd>$08</kbd> (represents &ldquo;8&rdquo; for 10000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+2</kbd></td><td><kbd>$7F8450/$404142</kbd></td><td><kbd>$07</kbd> (represents &ldquo;7&rdquo; for 1000000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+3</kbd></td><td><kbd>$7F8451/$404143</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 100000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+4</kbd></td><td><kbd>$7F8452/$404144</kbd></td><td><kbd>$05</kbd> (represents &ldquo;5&rdquo; for 10000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+5</kbd></td><td><kbd>$7F8453/$404145</kbd></td><td><kbd>$04</kbd> (represents &ldquo;4&rdquo; for 1000s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+6</kbd></td><td><kbd>$7F8454/$404146</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 100s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+7</kbd></td><td><kbd>$7F8455/$404147</kbd></td><td><kbd>$02</kbd> (represents &ldquo;2&rdquo; for 10s)</td></tr>
	<tr><td><kbd>!Scratchram_32bitHexDecOutput+8</kbd></td><td><kbd>$7F8456/$404148</kbd></td><td><kbd>$00</kbd> (represents &ldquo;0&rdquo; for 1s)</td></tr>
	
	</table><br>
	
	Code in question:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !Setting_32bitHexDec_MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 10		;&gt;How many digits, enter 1-10 (pointless if you enter less than 5).
	

	main:
	REP #$20
	LDA !Freeram_ValueDisplay1_4Bytes				;\Low word (example: $3344 -&gt; [$44, $33] in $00, $01)
	STA $00								;/
	LDA !Freeram_ValueDisplay1_4Bytes+2				;\High word (example: $1122 -&gt; [$22, $11] in $02, $03)
	STA $02								;/
	SEP #$20
	JSL HexDec_ThirtyTwoBitHexDecDivision	;&gt;Should Output example as: [$02, $08, $07, $04, $05, $04, $00, $02, $00] on !Scratchram_32bitHexDecOutput.
	
	;Write to status bar:
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA !Scratchram_32bitHexDecOutput+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEX
			BPL -
		else
			LDX #((!NumberOfDigitsDisplayed-1)*2)
			LDY #(!NumberOfDigitsDisplayed-1)
			-
			PHX
			TYX						;&gt;Sigh, LDA $xxxxxx,y does not exist.
			LDA (!Scratchram_32bitHexDecOutput)+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
			PLX
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></div><br>
	
Don't ask me to make an even larger number display, because not many games would ever display 10 digits at once, plus, it takes up space on the HUD.</p>

<p>Also note that <kbd>!NumberOfDigitsDisplayed</kbd> and <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> are different. <kbd>!NumberOfDigitsDisplayed</kbd> refers to only the low (rightmost digits) n digits being
displayed, while <kbd>!Setting_32bitHexDec_MaxNumberOfDigits</kbd> is the fixed number of digits (uses leading zeroes if fewer digits) stored in the digit table (you can set this to a
<abbr title="If you have multiple number displays and they are using the 32-bit HexDec each with different maximums (example: 99,999 and 999,999), then set !Setting_32bitHexDec_MaxNumberOfDigits to whatever number using this routine uses the most digits
(in this case, 6, not 5).">lower number to save space</abbr>).
Having both in case if you want to only display up to n digits less than the routine can output. For example, a counter to display 6 digits, 0-999999. You wouldn't want display
unused digits always showing 0 on the millions (1000000s) and beyond (so don't display &ldquo;0000999999&rdquo;, those first 4 digits are always 0 and therefore redundant).</p>

<p>Funnily enough, I wrote this tutorial before
<a href="https://www.youtube.com/watch?v=v3-a-zqKfgA">this video</a> came out on how to convert binary to decimal for display.</p>

<h4 id="RemoveLeadingZeroes"><a href="#RemoveLeadingZeroesBack">^</a>Removing leading zeroes (leading spaces)</h4>
	<p>I've also provided routines that removes leading zeroes by simply replacing the first n digits with tile $FC in the digits table (I call these &ldquo;leading spaces&rdquo;). After calling the the JSL routines to convert them into decimal
	digits, you then call <kbd>RemoveLeadingZeroes16Bit</kbd> or <kbd>RemoveLeadingZeroes32Bit</kbd> before writing to the status bar. Make sure you match the 16 and 32 bits between hexdec and removing leading zeroes routines. For the 8-bit versions,
	a routine isn't necessary:
	<ul>
		<li>For 2-digit numbers, just replace the 10s place digit with tile #$FC (defined as <kbd>!StatusBarBlankTile</kbd>) if it is 0:
<div class="CodeBlock" style="width: 1000px; height: 300px"><pre>incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;&gt;if you are using status bar patches, STX $xxxxxx will not work.
	BNE .NotLeadingZero
	
	.LeadingZero
	LDA #!StatusBarBlankTile				;&gt;Blank tile
	
	.NotLeadingZero
	STA !StatusBar_TestDisplayElement_Pos_Tile			;&gt;Write 10s place
	RTL</pre></div>
		</li>
		<li>For 3-digit numbers, use this code template:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	.DisplayNumbers
		LDA !Freeram_ValueDisplay1_1Byte
		JSL HexDec_EightBitHexDec3Digits					;&gt;Obtain 3 digits in A (1s), X (10s) and Y (100s).
		STA !StatusBar_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)		;&gt;Write 1s place (will always show)
	
		..HandleHundreds
			CPY #$00							;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
			BNE ...HundredsNonZero						;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
		
			...NoHundreds
				LDA #!StatusBarBlankTile				;\Erase the 100s digit
				STA !StatusBar_TestDisplayElement_Pos_Tile		;/
				BRA ..HandleTens					;&gt;Check if the next digit is also part of the leading zero.
		
			...HundredsNonZero
				TYA
				STA !StatusBar_TestDisplayElement_Pos_Tile		;&gt;Write 100s place
				BRA ..HandleTens_WriteTens				;&gt;If at least 100, 10s shouldn't be omitted.
		
		..HandleTens
			CPX #$00							;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
			BNE ...WriteTens						;/No, then erase the 10s.
			...NoTens
				LDX #!StatusBarBlankTile				;&gt;If 0, replace 10s digit with blank.
			...WriteTens
				TXA								;\Write 10s place
				STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;/
	.Done
	RTL</pre></div></li>
	</ul>
	</p>
<h3 id="AlignedDigits"><a href="#AlignedDigitsBack">^</a>Remove Leading zeros, with left/right-aligned digits</h3>
<p>Perhaps, in actuality, leading zeros are replaced with leading spaces, giving a <i>right-aligned</i> look. If you are designing a HUD
with an icon (or a &ldquo;label&rdquo;) to the left of the number when the number have a small number of digits, you'll have a space in between the icon and the digits, which looks ugly, especially if the number
have a huge number of digits it can display up to. Or, if you wanted the number display to look more compact. For example, a 5-digit, 16-bit number:<br>
<img src="Readme_Files/LeadingSpaces.png"><br><br>
The first routine, <kbd>SupressLeadingZeros</kbd> works like this: Search all the digits in <kbd>!Scratchram_16bitHexDecOutput</kbd> from left-to-right, and copy all the non-leading zero digits
on and after the first (leftmost) digit and paste them into <kbd>!Scratchram_CharacterTileTable</kbd>. You've now have a &ldquo;compressed string&rdquo; table stored. After this routine, The X register now contains a number incremented for every character being written.
See picture below:<br>
<img src="Readme_Files/NoLeadingZeroesLeftAligned.png"><br>
When written to the status bar:<br>
<img src="Readme_Files/StatusBarStringTransfer.png">
</p>

<p>The subroutine <kbd>WriteStringDigitsToHUD</kbd> (including the <kbd>Format2</kbd> variant) transfers the string stored in <kbd>!Scratchram_CharacterTileTable</kbd> to the status bar:
<table>
	<tr>
		<th>Input</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>
			<table>
				<tr>
					<td><kbd>$00</kbd> to <kbd>$02</kbd> (3 bytes)</td>
					<td>24-bit address location to write tile numbere here and tiles after</td>
				</tr>
				<tr>
					<td><kbd>$03</kbd> to <kbd>$05</kbd> (3 bytes, used when <kbd>!StatusBar_UsingCustomProperties != 0</kbd>)</td>
					<td>Same as above but for tile properties</td>
				</tr>
				<tr>
					<td><kbd>$06</kbd> (1 byte, used when <kbd>!StatusBar_UsingCustomProperties != 0</kbd>)</td>
					<td>Tile properties to use for all tiles of the string.</td>
				</tr>
				<tr>
					<td><kbd>X register</kbd> (1 byte, not stored)</td>
					<td>Number of character to write.</td>
				</tr>
			</table>
		</td>
		<td>
			Tile data are written at an address stored in <kbd>$00-$02</kbd> and <kbd>$03-$05</kbd> (latter applies when using custom properties)
		</td>
	</tr>
</table>

</p>

<p>To use the routine, here is the code template:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90"). Also setup tile properties when enabled.
		LDX.b #(!NumberOfDigitsDisplayed-1)*!StatusbarFormat
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_Pos_Tile,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TileProp
			STA !StatusBar_TestDisplayElement_Pos_Prop,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;Number to string.
		;Process HexDec
			REP #$20						;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_2Bytes			;|
			STA $00							;|
			SEP #$20						;|
			JSL HexDec_SixteenBitHexDecDivision			;/
		;Remove leading zeroes and have it as a character table
			LDX #$00					;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
		;Prevent writing too much characters.
			CPX.b #!NumberOfDigitsDisplayed+1		;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits				;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile : STA $00
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;8 : STA $01
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;16 : STA $02
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop : STA $03
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;8 : STA $04
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;16 : STA $05
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div>
32-bit? Here you go:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 10							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90"). Also setup tile properties when enabled.
		LDX.b #(!NumberOfDigitsDisplayed-1)*!StatusbarFormat
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_Pos_Tile,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TileProp
			STA !StatusBar_TestDisplayElement_Pos_Prop,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;Number to string.
		;Process HexDec
			REP #$20							;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_4Bytes				;|
			STA $00								;|
			LDA !Freeram_ValueDisplay1_4Bytes+2				;|
			STA $02								;|
			SEP #$20							;|
			JSL HexDec_ThirtyTwoBitHexDecDivision				;/
		;Remove leading zeroes and have it as a character table
			LDX #$00					;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros32Bit		;&gt;Write the digits (without leading zeroes) starting at position 0.
		;Prevent writing too much characters.
			CPX.b #!NumberOfDigitsDisplayed+1		;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits				;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile : STA $00
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;8 : STA $01
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;16 : STA $02
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop : STA $03
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;8 : STA $04
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;16 : STA $05
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div><br>

But what if I wanted to display 2 numbers &ldquo;X/Y&rdquo; (for example: &ldquo;260/300&rdquo;)? Well, you just have the codes be (loosely) called twice under &ldquo;<kbd>Number to string</kbd>&rdquo; but like this instead:
<ol>
	<li>
		<p>The number of tiles to clear uses <kbd>LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat</kbd>, 2 numbers, plus 1 (because of the &ldquo;/&rdquo; symbol), minus 1 (because indexing ranges from 0 to
		<kbd>NumberOfItems-1</kbd>), its then multiplied by 1 or 2 to adjust the status bar data formatting.</p>
	</li>
	<li>
		<p>You have codes <kbd>Process HexDec</kbd> and <kbd>Remove leading zeroes and have it as a character table</kbd> be the same for the first number (using previous example, the 260). We will not use the failsafe
		of too many digits until after we write the second number.</p>
	</li>
	<li>
		<p>After writing the first number, you then write a character that will be in between the 2 numbers (in this case, the &ldquo;/&rdquo; symbol), after this, you <kbd>INX</kbd> so you will place the second
		number after it.</p>
	</li>
	<li>
		<p>You do the same thing as the first number, but use <kbd>PHX</kbd>, then the code that uses HexDec, without <kbd>LDX #$00</kbd>, then <kbd>PLX</kbd>, because X needs to continue counting the characters, and that HexDec routine modifies
		this to handle each of the 5 digits. After this, then you DO need that failsafe, using <kbd>CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)</kbd>, 2 numbers, plus 1 for the &ldquo;/&rdquo; symbol, plus 1 AGAIN because BCS branches if
		<kbd>X &ge; ComparedValue</kbd></p>
	</li>
</ol>
Here is an example using 2 16-bit numbers:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;&gt;2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_Pos_Tile,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TileProp
			STA !StatusBar_TestDisplayElement_Pos_Prop,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20						;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_2Bytes			;|
			STA $00							;|
			SEP #$20						;|
			JSL HexDec_SixteenBitHexDecDivision			;/
		;Remove leading zeroes and have it as a character table
			LDX #$00						;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros				;&gt;Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb			;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x			;/
			INX							;&gt;Next character position.
	;Second number
		;Process HexDec
			PHX							;&gt;Push X because it gets modified by the HexDec routine.
			REP #$20						;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay2_2Bytes			;|
			STA $00							;|
			SEP #$20						;|
			JSL HexDec_SixteenBitHexDecDivision			;/
			PLX							;&gt;Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros				;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
		;Prevent writing too much characters.
			CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)		;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits					;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile : STA $00			;\Set address to write at a given status bar position.
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;8 : STA $01		;|
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;16 : STA $02		;/
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop : STA $03		;\Set address to write at a given status bar position.
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;8 : STA $04	;|
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;16 : STA $05	;/
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div>
...and 2 32-bit numbers (Debugging for SA-1 remapped default RAM addresses: <kbd>!RAMToMeasure = $3060</kbd>, <kbd>!RAMToMeasure2 = $6F3A</kbd>):
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 10							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).


	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;&gt;2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_Pos_Tile,x
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TileProp
			STA !StatusBar_TestDisplayElement_Pos_Prop,x
		endif
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20							;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_4Bytes				;|
			STA $00								;|
			LDA !Freeram_ValueDisplay1_4Bytes+2				;|
			STA $02								;|
			SEP #$20							;|
			JSL HexDec_ThirtyTwoBitHexDecDivision				;/
		;Remove leading zeroes and have it as a character table
			LDX #$00							;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb				;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x				;/
			INX								;&gt;Next character position.
	;Second number
		;Process HexDec
			PHX								;&gt;Push X because it gets modified by the HexDec routine.
			REP #$20							;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay2_4Bytes				;|
			STA $00								;|
			LDA !Freeram_ValueDisplay2_4Bytes+2				;|
			STA $02								;|
			SEP #$20							;|
			JSL HexDec_ThirtyTwoBitHexDecDivision				;/
			PLX								;&gt;Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
		;Prevent writing too much characters.
			CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)			;\Failsafe to avoid writing more characters than intended would write onto tiles
			BCS ..TooMuchDigits						;/not being cleared from the previous code.
	;Write to status bar
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile : STA $00			;\Set address to write at a given status bar position.
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;8 : STA $01		;|
		LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;16 : STA $02		;/
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop : STA $03		;\Set address to write at a given status bar position.
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;8 : STA $04	;|
			LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;16 : STA $05	;/
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div>
Again, use the debugger if you wanted to test the values using the memory editor and editing the RAM address defined by <kbd>!RAMToMeasure</kbd>, and this time, also <kbd>!RAMToMeasure2</kbd>.</p>

<h4 id="RightAligned"><a href="#RightAlignedBack">^</a>Right aligned display</h3>

<p>But what about right-aligned number display? First things first, if you are displaying a single number, this routine isn't necessary as calling the HexDec routines and replacing leading zeroes with leading spaces
is automatically right-aligned, therefore only use these routines (below) if you are displaying X/Y. Here is how you do it: After checking if there are too many characters, you then store the RAM address of the <i>rightmost tile position</i>
into $00-$02 (little endian), call <kbd>HexDec_ConvertToRightAligned</kbd> (<kbd>HexDec_ConvertToRightAlignedFormat2</kbd> if using the [TTTTTTTT, YXPCCCTT] format), which will modify the position of where to write the digits based
on how long the string are (loop-writes are based on the starting byte of an array, not the last) by taking the position, subtract by the number of characters minus 1 tile, then that is the leftmost tile position, then call the
routine to write to the HUD.<br><br>

16-bit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;&gt;2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile-((((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat),x
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20								;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_2Bytes					;|
			STA $00									;|
			SEP #$20								;|
			JSL HexDec_SixteenBitHexDecDivision					;/
		;Remove leading zeroes and have it as a character table
			LDX #$00								;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros						;&gt;Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb					;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x					;/
			INX									;&gt;Next character position.
	;Second number
		;Process HexDec
			PHX									;&gt;Push X because it gets modified by the HexDec routine.
			REP #$20								;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay2_2Bytes					;|
			STA $00									;|
			SEP #$20								;|
			JSL HexDec_SixteenBitHexDecDivision					;/
			PLX									;&gt;Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros						;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
	;Prevent writing too much characters.
		CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)					;\Failsafe to avoid writing more characters than intended would write onto tiles
		BCS ..TooMuchDigits								;/not being cleared from the previous code.
	;Calculate where to write for right-aligned 2-number display
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile : STA $00		;\Set address to write at a given status bar position.
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile&gt;&gt;8 : STA $01		;|
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile&gt;&gt;16 : STA $02		;/
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop : STA $03	;\Set address to write at a given status bar position.
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop&gt;&gt;8 : STA $04	;|
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop&gt;&gt;16 : STA $05	;/
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01							;\These offset the write position based on how many
			JSL HexDec_ConvertToRightAligned					;|characters so that it is right-aligned.
		else
			JSL HexDec_ConvertToRightAlignedFormat2					;|$00-$02 will now contain the location of the leftmost tile.
		endif										;/
	;Write to status bar
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div>
	It should result like this:<br>
	<img src="Readme_Files/RightAligned2Numbers.png"></p>
	32-bit version:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 10							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat	;&gt;2 NumberOfDigitsDisplayed due to 2 numbers displayed, plus 1 because of the "/" symbol.
		-
		LDA #!StatusBarBlankTile
		STA !StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile-((((!NumberOfDigitsDisplayed*2)+1)-1)*!StatusbarFormat),x
		DEX #!StatusbarFormat
		BPL -
	;First number
		;Process HexDec
			REP #$20							;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay1_4Bytes				;|
			STA $00								;|
			LDA !Freeram_ValueDisplay1_4Bytes+2				;|
			STA $02								;|
			SEP #$20							;|
			JSL HexDec_ThirtyTwoBitHexDecDivision				;/
		;Remove leading zeroes and have it as a character table
			LDX #$00							;&gt;Start at character position 0.
			JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at position 0.
	;"/" symbol
			LDA #!StatusBarSlashCharacterTileNumb				;\Slash symbol.
			STA !Scratchram_CharacterTileTable,x				;/
			INX								;&gt;Next character position.
	;Second number
		;Process HexDec
			PHX								;&gt;Push X because it gets modified by the HexDec routine.
			REP #$20							;\Convert a given number to decimal digits.
			LDA !Freeram_ValueDisplay2_4Bytes				;|
			STA $00								;|
			LDA !Freeram_ValueDisplay2_4Bytes+2				;|
			STA $02								;|
			SEP #$20							;|
			JSL HexDec_ThirtyTwoBitHexDecDivision				;/
			PLX								;&gt;Restore.
		;Remove leading zeroes and have it as a character table
			JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
	;Prevent writing too much characters.
		CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)				;\Failsafe to avoid writing more characters than intended would write onto tiles
		BCS ..TooMuchDigits							;/not being cleared from the previous code.
	;Calculate where to write for right-aligned 2-number display
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile : STA $00		;\Set address to write at a given status bar position.
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile&gt;&gt;8 : STA $01		;|
		LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile&gt;&gt;16 : STA $02		;/
		if !StatusBar_UsingCustomProperties != 0
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop : STA $03	;\Set address to write at a given status bar position.
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop&gt;&gt;8 : STA $04	;|
			LDA.b #!StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop&gt;&gt;16 : STA $05	;/
			LDA.b #!StatusBar_TileProp
			STA $06
		endif
		if !StatusbarFormat == $01							;\These offset the write position based on how many
			JSL HexDec_ConvertToRightAligned					;|characters so that it is right-aligned.
		else
			JSL HexDec_ConvertToRightAlignedFormat2					;|$00-$02 will now contain the location of the leftmost tile.
		endif										;/
	;Write to status bar
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL</pre></div>
<h3 id="IncrementDecrementAnimation"><a href="#IncrementDecrementAnimationBack">^</a>Counting animation</h3>
<p>In many video games, when a number is displayed on the HUD and is added or subtracted by another value (that is greater than 1), the number will gradually increase or decrease,
then stops, instead of instantly displaying the new result value. SMW does have that with the bonus stars and score when completing the level. SMW also does this with the coins,
but most of the time increment by 1 in the main game (an unused flying red coin, sprite $7E increments by 5). This is done by using $13CC as an &ldquo;adder&rdquo;, for every
value in this RAM, increments the coin count, and decreases itself once per frame. See this code here from its code:
<div class="CodeBlock" style="width: 1000px; height: 80px"><pre>CODE_008F1D:        AD CC 13      LDA.W $13CC               ; \ If Coin increase isn't x00, 
CODE_008F20:        F0 19         BEQ CODE_008F3B           ; / branch to $8F3B 
CODE_008F22:        CE CC 13      DEC.W $13CC               ; Decrease "Coin increase" 
CODE_008F25:        EE BF 0D      INC.W RAM_StatusCoins     ; Increase coins by 1 </pre></div>

There are two types of increment animation:
<ul>
	<li><p><b>Actual amount counting:</b> Your actual value is gradually counting, for example:
	SMW's coin is an example of this, if you were to check the player's coin count
	(<kbd>LDA $0DBF : CMP #$XX : &lt;BEQ/BNE/BCC/BCS&gt;</kbd>) while it's counting,
	it will take the current value instead of the added total value. You also don't
	write towards the actual counter directly, you just write how much to add to the adder.</p></li>
	
	<li><p><b>Mere display counting:</b> A number displayed on the HUD does the
	counting animation (therefore, the display uses the gradual-counting) upwards
	or downwards towards the actual value (the actual amount can instantly change,
	while the display counts gradually). This is done by have 2 numbers stored in
	memory: one for display that counts gradually and the other that can add and
	subtract &ldquo;instantly&rdquo; which that is the actual amount. Here, you have
	more control, you can write any value towards the actual amount, and the counting animation
	will play, even when you set it to a specific value (no adding/subtracting).</p></li>
</ul>
I usually call this a &ldquo;record effect&rdquo; on my older ASM works, but this sounds kinda misleading, Here is the example code:
<table>
<tr><th>Actual amount counting</th><th>Mere display counting</th></tr>
<tr>
<td>
<div class="CodeBlock" style="width: 500px; height: 125px"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	.Adder
	LDA !StatusBar_TestDisplayElement_CountAnimation1_1Byte
	BEQ ..Done
	
	..Increment
	DEC							;\Decrement on every step (frame)
	STA !StatusBar_TestDisplayElement_CountAnimation1_1Byte	;|for every adder value.
	LDA !Freeram_ValueDisplay1_1Byte			;|
	CMP #$FF						;|\If maxed, stop incrementing
	BEQ ..Cancel						;|/
	INC							;|
	STA !Freeram_ValueDisplay1_1Byte			;/
	BRA ..Done
	
	..Cancel
	;Prevent overflow. Note: Merely capping the number by writing to !Freeram_ValueDisplay1_1Byte will not cancel
	;how much remaining to add, so if you happen to hit this maximum, while the adder is nonzero,
	;then set !Freeram_ValueDisplay1_1Byte to a lower value, it will still increase from that lower value. Same
	;thing applies to subtraction when it bottoms out at 0 with !StatusBar_TestDisplayElement_CountAnimation2_1Byte being nonzero
	;when !Freeram_ValueDisplay1_1Byte is &gt; 0.
		LDA #$00		;&gt;STZ $xxxxxx does not exist.
		STA !StatusBar_TestDisplayElement_CountAnimation1_1Byte
	..Done
	
	.Subtracter
	LDA !StatusBar_TestDisplayElement_CountAnimation2_1Byte
	BEQ ..Done
	
	..Decrement
	DEC
	STA !StatusBar_TestDisplayElement_CountAnimation2_1Byte
	LDA !Freeram_ValueDisplay1_1Byte
	BEQ ..Cancel
	DEC
	STA !Freeram_ValueDisplay1_1Byte
	BRA ..Done
	
	..Cancel
	;Prevent underflow
		LDA #$00
		STA !StatusBar_TestDisplayElement_CountAnimation2_1Byte
	..Done

	.DisplayStatusBar
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec3Digits
	STA !StatusBar_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;\Write 10s place
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;/
	TYA								;\Write 100s place.
	STA !StatusBar_TestDisplayElement_Pos_Tile			;/
	RTL
	;Also note that if you have both adder and subtractor nonzero, they will cancel
	;each other out as both will increase and decrease together (results !Freeram_ValueDisplay1_1Byte
	;will stay the same), until one or the other is zero and starts adding or subtracting,
	;whatever is greater. For example, Adder is 30 and Subtracter is 5, results 5 frames
	;of no change, then increments by 1 25 times.</pre></div>
Note that if you want to stack values (say you want to add by 30 twice individually), it is a better idea to not set <kbd>!Freeram_Adder</kbd> to <kbd>#$1E</kbd>, rather to
take <kbd>!Freeram_Adder</kbd>, then add <kbd>CLC : ADC.b &lt;AdderAmount&gt;</kbd>, and then write back to <kbd>!Freeram_Adder</kbd>, otherwise it will not add properly (the second increase amount would be
<kbd>SetToAmount - AdderAmountLeft</kbd> instead where in this example that <kbd>SetToAmount = 30</kbd> and <kbd>AdderAmountLeft</kbd> is the current amount to add up to <kbd>!RAMToMeasure</kbd>).
</td>
<td>
<div class="CodeBlock" style="width: 500px; height: 125px"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

	main:
	.CountingAnimation
	LDA !Freeram_ValueDisplay2_1Byte
	CMP !Freeram_ValueDisplay1_1Byte
	BEQ ..NoChange
	BCC ..LessThan
	
	..GreaterThan
	LDA !Freeram_ValueDisplay2_1Byte
	DEC
	BRA ..Write
	
	..LessThan
	LDA !Freeram_ValueDisplay2_1Byte
	INC
	
	..Write
	STA !Freeram_ValueDisplay2_1Byte
	
	..NoChange
	
	.DisplayStatusBar
	LDA !Freeram_ValueDisplay2_1Byte
	JSL HexDec_EightBitHexDec3Digits
	STA !StatusBar_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)	;&gt;Write 1s place
	TXA								;\Write 10s place
	STA !StatusBar_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;/
	TYA								;\Write 100s place.
	STA !StatusBar_TestDisplayElement_Pos_Tile			;/
	RTL</pre></div><br>
If you want the counter to count even slower instead of once per frame, under the sublabel
<kbd>.CountingAnimation</kbd>, and before the first <kbd>LDA</kbd> add this code:
<div class="CodeBlock" style="width: 500px; height: 70px"><pre>	LDA $13
	AND.b #%00000011
	BNE ..NoChange</pre></div><br>
The AND values must be powers of 2, minus 1 (value_for_AND = (2^n)-1) where n is how much delay, in powers of 2 of frames.
What will happen is that the number will change by 1 every 2<sup>n</sup> frames. If you want the display to freeze when $9D is set, use this code instead:
<div class="CodeBlock" style="width: 500px; height: 140px"><pre>	LDA $9D
	ORA $13D4|!addr
	BNE ..NoChange

	LDA $14
	AND.b #%00000011		;&gt;Again, this is value_for_AND = (2^n)-1 where n is powers of 2 delay.
	BNE ..NoChange
</pre></div>
</td>
</tr>
</table>
Note that there are a major drawback:
<ul>
<li><p>If the amount adds or subtract by a very large value, the counting animation will take a very long time to finally display the final amount.</p></li>
<li><p>Make sure when you do things that would &ldquo;clear memory&rdquo; (or simply &rdquo;reset/initialize values&rdquo;) such as going to another level, make sure when using &ldquo;Actual amount counting&rdquo;, not to have the
adder/subtractor be reset during transitions, otherwise the amount change gets cut off, which stops the counter prematurely and therefore not get the total or difference properly. You can &ldquo;skip the
animation&rdquo; (&ldquo;fast-foward&rdquo;, instantly add) by taking the current value, add by the remaining values to be added (like taking the coin counter (<kbd>$0DBF</kbd>), add <kbd>CLC : ADC</kbd> by <kbd>$13CC</kbd>, store the total back to <kbd>$0DBF</kbd>) and then
set the adder to zero (since it is already added and we do not want to add even more):
<div class="CodeBlock" style="width: 1000px; height: 90px"><pre>LDA $0DBF		;\Instantly add
CLC			;|
ADC $13CC		;|
STA $0DBF		;/
STZ $13CC		;&gt;And stop adding even more (one coin count up is one adder down, until adder is zero).
</pre></div>
Now note that the above is just a mock up, and does not handle a 100-coin rollover (going over 100 would subtract by 100 simulating a wraparound). Use this code instead for real coin handling (has a strong failsafe measure) (<kbd>JSL</kbd> to it during fade outs, like gamemode <kbd>$0F<kbd> for example):
<div class="CodeBlock"><pre>AddNCoinsWithRollOver:
	LDA $0DBF|!addr		;\Instantly add
	CLC			;|
	ADC $13CC|!addr		;|
	STA $0DBF|!addr		;/
	STZ $13CC|!addr		;&gt;And stop adding even more (one coin count up is one adder down, until adder is zero).

	.CheckEnoughCoinsForLife
		LDA $0DBF|!addr
		SEC
		SBC.b #100		;\If coins subtracted by 100 results negative (or if coins is less than 100), then do nothing
		BCC .NotEnoughCoins	;/(CMP and SBC are the same except SBC modifies the accumulator register, A - B and it underflows, carry clear)

	.EnoughCoinsForLife
		STA $0DBF|!addr			;&gt;Wrap the coin count to 0-99 (MOD by 100)
		INC $18E4|!addr			;&gt;Increase life + sound effect (again if over 200 coins). Note that this also can get cut off, therefore the coin count would be right while the lives may be canceled.
		BRA .CheckEnoughCoinsForLife	;&gt;Check back again if after deducting 100 coins for extra life still have at least 100 coins (e.g if you get 200 coins instantly, grant another extra life)

	.NotEnoughCoins
AddLivesInstantly:
	LDA $0DBE|!addr		;\Instantly add
	CLC			;|
	ADC $18E4|!addr		;|
	STA $0DBE|!addr		;/
	STZ $18E4|!addr		;&gt;And stop adding even more (one life count up is one adder down, until adder is zero).
	
	.CheckIfLivesMaxed
		LDA.b #99
		CMP $0DBE|!addr
		BCS ..NotMaxed	;&gt;If 99 is greater than lives (or Lives less than 99), skip
		..Maxed
			STA $0DBE|!addr
		..NotMaxed
	Done:
	RTL</pre></div>

</p></li>
</ul>
</p>
For the &ldquo;Mere display counting&rdquo; you can alleviate the lengthy counting animation by taking the absolute difference of the display amount and actual amount, and check if the difference is too big, would
subtract/add by a larger amount, therefore instead of subtracting by a set amount per frame, you subtract by the proportion of the difference size. Here is an example using 16-bit number:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

;!Freeram_ValueDisplay1_2Bytes is the actual amount that you can write to.
;!Freeram_ValueDisplay2_2Bytes is the display animation, something you most likely won't touch.

!NumberOfDigitsDisplayed = 5						;&gt;Number of digits shown.
!ChangeDivisorRate = 60							;&gt;Scaling of increment/decrement rate. Higher number = slower.


	main:
	.CountingAnimation
	REP #$20
	LDA !Freeram_ValueDisplay2_2Bytes
	SEC
	SBC !Freeram_ValueDisplay1_2Bytes
	BEQ ..Done							;&gt;Safty check just in case it increments/decrements when it doesn't need to
	BCS ..Positive							;&gt;Unsigned check of difference (alternative to BPL), making use of the 16-bit's carry flag as an extra bit, allowing 0-65535 instead of 0-32768
	
	..Negative
	;Add upwards towards !Freeram_ValueDisplay1_2Bytes.
	EOR #$FFFF							;\Invert sign of number
	INC								;/
	STA $00								;\ChangePerFrame = floor(Difference/60) + 1
	LDA.w #!ChangeDivisorRate					;|
	STA $02								;|
	SEP #$20							;|
	JSL HexDec_MathDiv						;/
	REP #$20
	INC $00								;&gt;Shouldn't add by 0
	LDA !Freeram_ValueDisplay2_2Bytes				;\The bigger the difference, the faster it increments.
	CLC								;|
	ADC $00								;/
	BRA ..Write
	
	..Positive
	;Subtract downwards towards !Freeram_ValueDisplay1_2Bytes.
	STA $00								;\ChangePerFrame = floor(Difference/60) + 1
	LDA.w #!ChangeDivisorRate					;|
	STA $02								;|
	SEP #$20							;|
	JSL HexDec_MathDiv						;/
	REP #$20
	INC $00								;&gt;Shouldn't subtract by 0
	LDA !Freeram_ValueDisplay2_2Bytes				;\The bigger the difference, the faster it decrements.
	SEC								;|
	SBC $00								;/
	
	..Write
	STA !Freeram_ValueDisplay2_2Bytes
	
	..Done
	
	.DisplayStatusBar
	LDA !Freeram_ValueDisplay2_2Bytes
	STA $00
	JSL HexDec_SixteenBitHexDecDivision
	JSL HexDec_RemoveLeadingZeroes16Bit
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></div><br>
	
Alternatively, I developed a subroutine that you can supply any RAM addresses as the input for the subroutine <kbd>CountingAnimation16Bit</kbd> (both RAMs must be 16-bit) and it will increment/decrement
the display value for you:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!NumberOfDigitsDisplayed = 5						;&gt;Number of digits shown.
!ChangeDivisorRate = 60							;&gt;Scaling of increment/decrement rate. Higher number = slower.

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	main:
	.ChangeAnimation
		LDA.b #!Freeram_ValueDisplay1_2Bytes		;\$04-$06: A RAM address containing the Actual number
		STA $04						;|
		LDA.b #!Freeram_ValueDisplay1_2Bytes&gt;&gt;8		;|
		STA $05						;|
		LDA.b #!Freeram_ValueDisplay1_2Bytes&gt;&gt;16	;|
		STA $06						;/
		
		LDA.b #!Freeram_ValueDisplay2_2Bytes		;\$07-$09: A RAM address containing the gradually changing number
		STA $07						;|
		LDA.b #!Freeram_ValueDisplay2_2Bytes&gt;&gt;8		;|
		STA $08						;|
		LDA.b #!Freeram_ValueDisplay2_2Bytes&gt;&gt;16	;|
		STA $09						;/
		
		LDA #!ChangeDivisorRate				;\$0A: Rate
		STA $0A						;/
		
		JSL HexDec_CountingAnimation16Bit		;&gt;Perform gradual counting animation (This uses $00-$03 for division routine, therefore destroyed)
	.DisplayStatusBar
		REP #$20
		LDA !Freeram_ValueDisplay2_2Bytes
		STA $00
		SEP #$20
		JSL HexDec_SixteenBitHexDecDivision
		JSL HexDec_RemoveLeadingZeroes16Bit				;&gt;Remove if you want leading zeroes.
	
	;Write to status bar
		if !StatusbarFormat == $01
			LDX.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.b !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEX
			BPL -
		else
			LDX.b #((!NumberOfDigitsDisplayed-1)*2)
			LDY.b #(!NumberOfDigitsDisplayed-1)
			-
			LDA.w !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
			STA !StatusBar_TestDisplayElement_Pos_Tile,x
			DEY
			DEX #2
			BPL -
		endif
	RTL</pre></div>
<hr>
<h2 id="Frames2Timer"><a href="#Frames2TimerBack">^</a>Display a timer in Hours:Minutes:Seconds:Centiseconds format</h2>
Perhaps, if you wanted to display a timer on the HUD in HH:MM:SS.CC (or MM:SS.CC) format, I've provided a routine for that and a code to use it, see <a href="UberasmTool_HudTest/Level_Timer.asm"><kbd>UberasmTool_HudTest/Level_Timer.asm</kbd></a>
	
<p>The routine that converts the total number of frames into units of time, <kbd>Frames2Timer</kbd>:
<table>
	<tr>
		<th>Subroutine</th>
		<th>Input</th>
		<th>Output</th>
	</tr>
	<tr>
		<td><kbd>Frames2Timer</kbd></td>
		<td><kbd>$00</kbd>-<kbd>$03</kbd> (32-bit/4-byte): Total number of frames, little endian as always.</td>
		<td><kbd>Scratchram_Frames2TimeOutput+0</kbd> to <kbd>!Scratchram_Frames2TimeOutput+3</kbd> (4 bytes):<br><br>
			<table>
				<tr>
					<th>!Scratchram_Frames2TimeOutput data</th>
					<th>Units of time</th>
				</tr>
				<tr>
					<td><kbd>!Scratchram_Frames2TimeOutput+0</kbd></td>
					<td>Hour</td>
				</tr>
				<tr>
					<td><kbd>!Scratchram_Frames2TimeOutput+1</kbd></td>
					<td>Minute (value ranges from 0-59 (<kbd>#$00</kbd>-<kbd>#$3B</kbd>))</td>
				</tr>
				<tr>
					<td><kbd>!Scratchram_Frames2TimeOutput+2</kbd></td>
					<td>Seconds (value ranges from 0-59 (<kbd>#$00</kbd>-<kbd>#$3B</kbd>))</td>
				</tr>
				<tr>
					<td><kbd>!Scratchram_Frames2TimeOutput+3</kbd></td>
					<td>Approximate centiseconds, calculated via <kbd><abbr title="Rounds nearest to integer; 0&le;X&lt;0.5 rounds down, 0.5&le;X&lt;1 rounds up.">RoundHalfUp</abbr>((Frames MOD 60)*100/60)</kbd>. The value ranges from 0-98 (<kbd>#$00</kbd>-<kbd>#$62</kbd>)), supposedly should be 0-99, but 59/60 is  0.98[3] (bracketed means repeating digits) would round to .98.</td>
				</tr>
			</table>
		</td>
	</tr>
</table>
</p>
<p>This works by taking a 32-bit frame counter (it must increment by 1 every 1/60th of a second, which is the NTSC SNES's game loop speed) and doing repeated divisions by 60:
<div class="CodeBlock" style="width: 1000px; height: 60px"><pre>Frames / 60 = Q: Seconds R: Frames		;&gt;We have seconds (not wrapped 0-59 yet), and frames (wrapped 0-59, then displayed as 0-<abbr title="Actually 98, due to 59/60 = 0.98[3]">99</abbr>)
Seconds / 60 = Q: Minutes R: Seconds		;&gt;We have minutes (not wrapped 0-59 yet), and seconds (wrapped 0-59)
Minutes / 60 = Q: Hours R: Minutes		;&gt;We have hours (not wrapped 0-59), and minutes (wrapped 0-59)</pre></div>


This is an entirely different format from <a href="https://www.smwcentral.net/?p=section&a=details&id=16365">Imamelia's timer</a>
that mine have a 32-bit frame counter as a single number while Imamelia have his with each byte being stored containing each units of time
(one byte containing the frames, another being seconds, the final containing the minutes) and increments and decrements individually.
As of the time of writing this, the rightmost number on Imamelia's timer isn't the centiseconds but rather jiffyseconds that display numbers 0-59.</p>

<p>The biggest advantages of mine is that you can add/subtract time much more easily (an item increases the timer by 5 seconds). Remember that how
65c816's addition and subtraction with carry (CLC/SEC/ADC/SBC) works? Well:
<ul>
	<li>
		ADC:
			<ul>
				<li>
					Before: If the carry is clear, will add normally. If the carry is set, will add an additional 1. For example: [<kbd>LDA #$01 : CLC : ADC #$01, Now A = #$02</kbd>],
					[<kbd>LDA #$01 : SEC : ADC #$01, Now A = #$03</kbd>]
				</li>
				<li>
					After: If A overflows (goes greater than 255 in 8-bit, 65535 in 16-bit, unsigned), the carry will be SET, otherwise if not, will be CLEAR. Example:
					[<kbd>LDA #$FF : CLC : ADC #$01, now carry is set (#$FF+#$01 = #$100 &rightarrow; #$00)</kbd>], [<kbd>LDA #$FE : CLC : ADC #$01, now carry is clear (A = #$FF)</kbd>].
				</li>
			</ul>
	</li>
	<li>
		SBC
			<ul>
				<li>
					Before: If the carry is set, will subtract normally. If the carry is clear, will subtract an additional 1. Example: [<kbd>LDA #$05 : SEC : SBC #$01, now A = #$04</kbd>]
					[<kbd>LDA #$05 : CLC : SBC #$01, now A = #$03</kbd>].
				</li>
				<li>
					After: If A underflows (goes under 0 on both 8-bit and 16-bit, unsigned), the carry will be CLEARED. Otherwise is SET. Example:
					[<kbd>LDA #$03 : SEC : SBC #$03, Now A = #$00 and carry set</kbd>], [<kbd>LDA #$03 : SEC : SBC #$04, Now A = -#$01 &rightarrow; #$FF and carry clear</kbd>].
				</li>
			</ul>
	</li>
	This is commonly done in pseudo 8-bit math to produce a potentially 16-bit number, for example with addition:
<div class="CodeBlock" style="width: 1000px; height: 350px"><pre>
	;Made-up example: #$<span style="color: blue">12</span><span style="color: red">34</span> + #$<span style="color: blue">56</span><span style="color: red">78</span> without carry set.
		LDA <span style="color: red">#$34</span>	;\Low byte
		CLC		;|#$34 + #$78 = #$AC
		ADC <span style="color: red">#$78</span>	;|
		STA $00		;/
		LDA <span style="color: blue">#$12</span>	;\High byte
		ADC <span style="color: blue">#$56</span>	;|>If this second number is 8-bit, (for example, $78, you treat it as it has leading zeroes: $0078)
		STA $01		;/(#$12 + #$56 = #$68)
		
		;$00 to $01 = #$68AC
	;Another example: #$<span style="color: blue">FE</span><span style="color: red">FF</span> + #$<span style="color: blue">02</span><span style="color: red">01</span>, when the carry are set when they overflow
		LDA <span style="color: red">#$FF</span>	;\Low byte, #$FF + #$01 = #$0100, carry set and A as 8-bit = #$00.
		CLC		;|
		ADC <span style="color: red">#$01</span>	;|
		STA $00		;/
		LDA <span style="color: blue">#$FE</span>	;\High byte, #$FE + #$02 + 1 (+1 because of the carry set) = #$0101, A as 8-bit = #$01
		ADC <span style="color: blue">#$02</span>	;|carry set after this since A went above #$FF.
		STA $01		;/
		
		;$00 to $01 = #$0100, carry set. The actual correct math is #$FEFF + #$0201 = #$10100 but the low 2 bytes are stored in $00-$01.</pre></div>
	The exact same thing can be done using 16-bit numbers to produce values that are bigger than the maximum register size (bigger than 16-bit, like 32-bit mode). Off-topic note: this also works with bit shifting as well, by using ASL/LSR, and then ROL/ROR.
	The carry flag is essentially a &ldquo;bridge&rdquo; to numbers bigger than the register size. To detect an overflow/underflow, just use BCC/BCS (branch if carry clear/set) AFTER all the bytes are added/subtracted/shifted. Also another off-topic is that
	SBC is very similar to CMP, but without affecting the A register.
</ul>
</p>

<p>For debugging purposes, or if you are planning to have items that would increase/decrease the timer, I've provided <a href="Readme_Files/JS_FrameToTimer.html" id="DebugTimerValue">a javascript converter between the total frames and timer format</a>
in case if you need to check their values stored in memory or needed to put direct frame values in there for adding/subtracting.</p>

<p>Protip: most video games never have a countdown timer of over 10 minutes, so you don't need a 32-bit number, you can simply use a smaller number of bytes (preferably 16-bit, 65535 frames is about 18 minutes, see table below) and mask the high n bytes with zeroes. For example:
<div class="CodeBlock" style="height: 150px;"><pre>	..StopTimer
	REP #$20			;\Get timer format
	LDA !RAMToMeasure		;|
	STA $00				;|
	LDA #$0000			;|\High words (upper 2 bytes of the 4-byte 32-bit input masked)
	STA $02				;|/Alternative, you can replace these 2 lines with STZ $02.
	SEP #$20			;|
	JSL HexDec_Frames2Timer		;/</pre></div>
Here are the maximums values of the frame value and their timer equivalents:
<table>
	<tr><th>Number of bytes (max value/hex)</th><th>How long</th></tr>
	<tr><td>1 (255/$FF)</td><td>00:00:04.25</td></tr>
	<tr><td>2 (65535/$FFFF)</td><td>00:18:12.25</td></tr>
	<tr><td>3 (16777215/$FFFFFF)</td><td>77:40:20.25</td></tr>
	<tr><td>4 (4294967295/$FFFFFFFF)</td><td>19884:06:28.25 (hours will display incorrectly)</td></tr>
</table><br>
</p>
<hr>
<h2 id="Percentage"><a href="#PercentageBack">^</a>Display a percentage</h2>
<p>This tutorial displays a number representing a percentage of something. Because we are dealing with integers here (The SNES does not support floating point numbers), we have to multiply first before we divide, as every
arithmetic operation <a href="https://en.wikipedia.org/wiki/Rounding">rounds</a> (specifically, division) the number to an integer:
<div class="CodeBlock"><pre>Improper way of dividing integers:
	Percentage = (Amount / TotalAmount) * PercentagePrecision
	
	Result: Only values 0% and 100% are possible results, values in between are not.
	
	This is because when you take a number, and divide by a larger number, it will land between 0 and 1, which
	cannot be represented in integers, so it will round down or up (the division routine alone rounds downwards).
	When multiplied afterwards, how much the value is off will scale dramatically.
Proper way of dividing integers:
	Percentage = (Amount * PercentagePrecision) / TotalAmount
	
	Result: Any (integer) values between 0% and 100%, both inclusive.
	
	Because this is multiplied (which always results the correct number unless an overflow occurs) before losing some
	precision from division, therefore minimizing the loss via having the arithmetic operations do so that the
	last operation is the only one that rounds the result. Rounding anytime before the last operation can accumulate
	errors.
	
	Technically, this actually treats the division as if it's a fraction while focusing on the integers on the
	numerator and denominator.
Example:
	2/3 = 66.[6]% (bracketed means repeating digits)
		(2/3) * 100 causes this to happen:
			2/3 would result:
				0 = 0 * 100 when rounded down: off by 0.[6] (2/3 becomes 0, then multiply by 100)
				1 = 1 * 100 when rounded up: off by 0.[3] (2/3 becomes 1, then multiply by 100)
			and then when multiplied by 100 afterwards:
				When rounded down: 0 is off by a whopping 66.[6]
				When rounded up: 100 is off by a whopping 33.[3]
		(2 * 100)/3 causes this to happen
			2*100 will result exactly 200. No rounding have occurred.
			and after division:
				66 when rounded down, off by a meager 0.[6]
				67 when rounded up, off by a meager 0.[3]
</pre></div><br>
<kbd>PercentagePrecision</kbd> is 100, 1000, or 10000. The reason of this is to allow a more precise display by showing decimal fractions of a percentage (example: 50.03%). This works by using
<a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point arithmetic</a>. Meaning that a value <kbd>5003</kbd> stored in memory means 50.03 when using 10000 scaling. Here is a sample template
code to display a percentage:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!Default_PercentagePrecision = 0
 ;^0 = show whole number precisions, 1 = 1/10 of a percentage, 2 = 1/100. Not to be confused
 ; with !Scratchram_PercentageFixedPointPrecision.
!CapAt100 = 1								;&gt;0 = allow percentage to display values greater than 100, 1 = cap at 100.
!RightAligned = 0							;&gt;0 = left-aligned, 1 = right-aligned.


;Don't touch unless you know what you're doing
	if !RightAligned == 0
		!StatusBarAddressTile = !StatusBar_TestDisplayElement_Pos_Tile				;&gt;Where to write on the status bar, tile numbers (left aligned)
		!StatusBarAddressProps = !StatusBar_TestDisplayElement_Pos_Prop				;&gt;Same as above, but tile properties (left aligned)
	else
		!StatusBarAddressTile = !StatusBar_TestDisplayElement_RightAlignedText_Pos_Tile		;&gt;Where to write on the status bar, tile numbers (right aligned)
		!StatusBarAddressProps = !StatusBar_TestDisplayElement_RightAlignedText_Pos_Prop		;&gt;Same as above, but tile properties (right aligned)
	endif

;Code below
main:
	if !CPUMode != 0
		%invoke_sa1(mainSA1)
		RTL
		mainSA1:
	endif
	;Submit fraction
		REP #$20
		LDA !Freeram_ValueDisplay1_2Bytes
		STA !Scratchram_PercentageQuantity
		LDA !Freeram_ValueDisplay2_2Bytes
		STA !Scratchram_PercentageMaxQuantity
		SEP #$20
		LDA #!Default_PercentagePrecision
		STA !Scratchram_PercentageFixedPointPrecision
		JSL HexDec_ConvertToPercentage
	;Prevent display percentages greater than 100%.
	;Note to self:
	;100				= $00000064
	;1000 (display as ***.*)	= $000003E8
	;10000 (display as ***.**)	= $00002710
		if !CapAt100 != 0
			.CheckExceed100
				REP #$30
				LDX.w #(10**(!Default_PercentagePrecision+2))
				;Check the high word of the XXXX (RAM_00-RAM_03 = $XXXXYYYY)
					LDA $02			;\Any nonzero digits in the high word would mean at least
					BNE ..Cap100		;/65536 ($00010000), which is guaranteed over 100/1000/10000.
				;Check low word
					TXA
					CMP $00			;\Max compares with RAM_00
					BCS ..Under		;/If Max &gt;= RAM_00 or RAM_00 is lower, don't set it to max.
				
				..Cap100
					TXA
					STA $00
				..Under
				SEP #$30
		endif
	;Avoid displaying 0% and 100% misleadingly if close to them.
		CPY #$00
		BEQ .Normal
		CPY #$01
		BEQ .RoundTo1Percent
		CPY #$02
		BCS .RoundTo99Percent		;&gt;Just in case somehow Y is a value $03 or more
		
		.RoundTo1Percent
			REP #$20
			LDA.w #1
			STA $00
			STZ $02
			SEP #$20
			BRA .Normal
		.RoundTo99Percent
			REP #$20
			LDA.w #(10**(!Default_PercentagePrecision+2)-1)		;&gt;99%, 99.9%, or 99.99%.
			STA $00
			STZ $02
			SEP #$20
		.Normal
	;Display the number.
		if !Default_PercentagePrecision == 0
			;Since it is very unlikely you display percentage greater than 100 (assuming you set !Default_PercentagePrecision to 0), you mostly
			;likely just need to use $00 (8-bit) alone.
			if !RightAligned == 1
				.DisplayNumbers
					LDA $00
					JSL HexDec_EightBitHexDec3Digits
					STA !StatusBarAddressTile-(1*!StatusbarFormat)		;&gt;Write 1s place
					..HandleHundreds
						CPY #$00					;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
						BNE ...HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
					...NoHundreds
						LDA #!StatusBarBlankTile			;\Erase the 100s digit
						STA !StatusBarAddressTile-(3*!StatusbarFormat)	;/
						BRA ..HandleTens				;&gt;Check if the next digit is also part of the leading zero.
					...HundredsNonZero
						TYA
						STA !StatusBarAddressTile-(3*!StatusbarFormat)	;&gt;Write 100s place
						BRA ..HandleTens_WriteTens			;&gt;If at least 100, 10s shouldn't be omitted.
					..HandleTens
						CPX #$00					;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
						BNE ...WriteTens				;/No, then erase the 10s.
						...NoTens
							LDX #!StatusBarBlankTile			;&gt;If 0, replace 10s digit with blank.
						...WriteTens
							TXA						;\Write 10s place
							STA !StatusBarAddressTile-(2*!StatusbarFormat)	;/
					if !StatusBar_UsingCustomProperties != 0
						LDA #!StatusBar_TileProp
						STA !StatusBarAddressProps-(0*!StatusbarFormat)
						STA !StatusBarAddressProps-(1*!StatusbarFormat)
						STA !StatusBarAddressProps-(2*!StatusbarFormat)
						STA !StatusBarAddressProps-(3*!StatusbarFormat)
					endif
					LDA #!StatusBarPercentTile
					STA !StatusBarAddressTile-(0*!StatusbarFormat)
			elseif !RightAligned == 0
				STZ $01
				JSL HexDec_SixteenBitHexDecDivision
				
				.ClearTiles
				;Clear the tiles. To prevent leftover "ghost" tiles that should've
				;disappear when the number of digits decreases (so when "10" becomes "9",
				;won't display "90"). Also setup tile properties when enabled.
					LDX.b #(4-1)*!StatusbarFormat
					..Loop
						LDA #!StatusBarBlankTile
						STA !StatusBarAddressTile,x
						if !StatusBar_UsingCustomProperties != 0
							LDA.b #!StatusBar_TileProp
							STA !StatusBarAddressProps,x
						endif
						DEX #!StatusbarFormat
						BPL ..Loop
				.StatusBarString
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
				;Prevent writing too much characters.
					CPX.b #4+1					;\Failsafe to avoid writing more characters than intended would write onto tiles
					BCS ..TooMuchDigits				;/not being cleared from the previous code.
				;Write percent symbol after the number
					LDA #!StatusBarPercentTile			;\Write percent symbol
					STA !Scratchram_CharacterTileTable,x		;/
					INX
				;Write to status bar
					LDA.b #!StatusBarAddressTile : STA $00
					LDA.b #!StatusBarAddressTile&gt;&gt;8 : STA $01
					LDA.b #!StatusBarAddressTile&gt;&gt;16 : STA $02
					if !StatusBar_UsingCustomProperties != 0
						LDA.b #!StatusBarAddressProps : STA $03
						LDA.b #!StatusBarAddressProps&gt;&gt;8 : STA $04
						LDA.b #!StatusBarAddressProps&gt;&gt;16 : STA $05
						LDA #!StatusBar_TileProp : STA $06
					endif
					if !StatusbarFormat == $01
						JSL HexDec_WriteStringDigitsToHUD
					else
						JSL HexDec_WriteStringDigitsToHUDFormat2
					endif
					..TooMuchDigits
			endif
		else
			JSL HexDec_SixteenBitHexDecDivision
			if !RightAligned == 1
				if !Default_PercentagePrecision == 1
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast2
					;XXX.X%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/10s place
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !StatusBarAddressTile-(5*!StatusbarFormat)	;&gt;100s
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !StatusBarAddressTile-(4*!StatusbarFormat)	;&gt;10s
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !StatusBarAddressTile-(3*!StatusbarFormat)	;&gt;1s
					LDA #$24 : STA !StatusBarAddressTile-(2*!StatusbarFormat)				;&gt;.
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !StatusBarAddressTile-(1*!StatusbarFormat)	;&gt;1/10ths
					LDA #!StatusBarPercentTile : STA !StatusBarAddressTile-(0*!StatusbarFormat)		;&gt;%
					if !StatusBar_UsingCustomProperties != 0
						LDA #!StatusBar_TileProp
						STA !StatusBarAddressProps-(5*!StatusbarFormat)	;&gt;100s
						STA !StatusBarAddressProps-(4*!StatusbarFormat)	;&gt;10s
						STA !StatusBarAddressProps-(3*!StatusbarFormat)	;&gt;1s
						STA !StatusBarAddressProps-(2*!StatusbarFormat)	;&gt;.
						STA !StatusBarAddressProps-(1*!StatusbarFormat)	;&gt;1/10s
						STA !StatusBarAddressProps-(0*!StatusbarFormat)	;&gt;%
					endif
				elseif !Default_PercentagePrecision == 2
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast3
					;XXX.XX%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$00 (10000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1/10s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/100s place
					LDA !Scratchram_16bitHexDecOutput+$00 : STA !StatusBarAddressTile-(6*!StatusbarFormat)	;&gt;100s
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !StatusBarAddressTile-(5*!StatusbarFormat)	;&gt;10s
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !StatusBarAddressTile-(4*!StatusbarFormat)	;&gt;1s
					LDA #$24 : STA !StatusBarAddressTile-(3*!StatusbarFormat)				;&gt;.
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !StatusBarAddressTile-(2*!StatusbarFormat)	;&gt;1/10s
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !StatusBarAddressTile-(1*!StatusbarFormat)	;&gt;1/100s
					LDA #!StatusBarPercentTile : STA !StatusBarAddressTile-(0*!StatusbarFormat)		;&gt;%
					if !StatusBar_UsingCustomProperties != 0
						LDA #!StatusBar_TileProp
						STA !StatusBarAddressProps-(6*!StatusbarFormat)	;&gt;100s
						STA !StatusBarAddressProps-(5*!StatusbarFormat)	;&gt;10s
						STA !StatusBarAddressProps-(4*!StatusbarFormat)	;&gt;1s
						STA !StatusBarAddressProps-(3*!StatusbarFormat)	;&gt;.
						STA !StatusBarAddressProps-(2*!StatusbarFormat)	;&gt;1/10s
						STA !StatusBarAddressProps-(1*!StatusbarFormat)	;&gt;1/100s
						STA !StatusBarAddressProps-(0*!StatusbarFormat)	;&gt;%
					endif
				endif
			elseif !RightAligned == 0
				.ClearTiles
					LDA #!StatusBarBlankTile
					if !Default_PercentagePrecision == 1
						LDX.b #($06-1)*!StatusbarFormat		;&gt;[100.0%] is 6 characters. So we must clear out 6 tiles.
					elseif !Default_PercentagePrecision == 2
						LDX.b #($07-1)*!StatusbarFormat		;&gt;[100.00%] is 7 characters. So we must clear out 7 tiles.
					endif
					..Loop
						STA !StatusBarAddressTile,x
						DEX #!StatusbarFormat
						BPL ..Loop
				
				
				LDX #$00
				if !Default_PercentagePrecision == 1
					LDA #$24		;\Decimal point
					STA $09			;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast2
				elseif !Default_PercentagePrecision == 2
					LDA #$24		;\Decimal point
					STA $09			;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast3
				endif
				LDA #!StatusBarPercentTile			;\Write percent symbol
				STA !Scratchram_CharacterTileTable,x		;/
				INX
				;Write to status bar
					LDA.b #!StatusBarAddressTile : STA $00
					LDA.b #!StatusBarAddressTile&gt;&gt;8 : STA $01
					LDA.b #!StatusBarAddressTile&gt;&gt;16 : STA $02
					if !StatusBar_UsingCustomProperties != 0
						LDA.b #!StatusBarAddressProps : STA $03
						LDA.b #!StatusBarAddressProps&gt;&gt;8 : STA $04
						LDA.b #!StatusBarAddressProps&gt;&gt;16 : STA $05
						LDA #!StatusBar_TileProp : STA $06
					endif
					if !StatusbarFormat == $01
						JSL HexDec_WriteStringDigitsToHUD
					else
						JSL HexDec_WriteStringDigitsToHUDFormat2
					endif
			endif
		endif
			.Done
	;Done
		RTL</pre></div><br>
The calculation to find the percentage is handled in <kbd>ConvertToPercentage</kbd>. Depending on what is written to <kbd>!Scratchram_PercentageFixedPointPrecision</kbd> determines should the numerator be out of 100, 1000, or 10000,
which after the HexDec routine, you can write the first n digits, then the decimal point (tile <kbd>#$24</kbd>), and then the last n digits, example:
<table>
<tr><th>Fixed point (fraction it represents)</th><th>Intended Display</th><th>Precision Type</th><th>Where to place the decimal point</th></tr>
<tr><td>50 (50/100)</td><td>50%</td><td><kbd>!Default_PercentagePrecision = 0</kbd></td><td>No need to place decimal point, it is already the percentage value.</td></tr>
<tr><td>101 (101/1000)</td><td>10.1%</td><td><kbd>!Default_PercentagePrecision = 1</kbd></td><td>Write the decimal point between the 1s and 10s place of the fixed point number. This results in the 1s becoming the tenths, 10s become the 1s and so on.</td></tr>
<tr><td>2004 (2004/10000)</td><td>20.04%</td><td><kbd>!Default_PercentagePrecision = 2</kbd></td><td>Write the decimal point between the 10s and 100s of the fixed point number. This results in the 1s becoming the hundredths, 10s becomes the tenths, and so on.</td></tr>
</table><br>
The function <kbd>ConvertToPercentage</kbd>, <kbd>ConvertToPercentageRoundDown</kbd>, and <kbd>ConvertToPercentageRoundUp</kbd>:
<table>
	<tr>
		<th>Input</th>
		<th>Output</th>
	</tr>
	<tr>
		<td>
			<table>
				<tr><th>RAM</th><th>Description</th></tr>
				<tr><td><kbd>!Scratchram_PercentageQuantity</kbd> to <kbd>!Scratchram_PercentageQuantity+1</kbd> (2 bytes)</td><td>Numerator of the fraction</td></tr>
				<tr><td><kbd>!Scratchram_PercentageMaxQuantity</kbd> to <kbd>!Scratchram_PercentageMaxQuantity+1</kbd> (2 bytes)</td><td>Denominator of the fraction</td></tr>
				<tr>
					<td>
						<kbd>Scratchram_PercentageFixedPointPrecision</kbd> (1 byte)
					</td>
					<td>Number of digits after decimal point, ranges from <kbd>#$00</kbd> to <kbd>#$02</kbd><br><br>
						<table>
							<tr>
								<th>Value</th>
								<th>description</th>
							</tr>
							<tr>
								<td><kbd>#$00</kbd></td>
								<td>Whole percentages. A scaling of 1</td>
							</tr>
							<tr>
								<td><kbd>#$01</kbd></td>
								<td>1/10th of percentage. A scaling of 1/10</td>
							</tr>
							<tr>
								<td><kbd>#$02</kbd></td>
								<td>1/100th of percentage. A scaling of 1/100</td>
							</tr>
						</table>
					</td>
				</tr>
			</table>
		</td>
		<td>
			<table>
				<tr><th>RAM</th><th>Description</th></tr>
				<tr><td><kbd>$00</kbd>-<kbd>$03</kbd> (4 bytes)</td><td>Percentage, using fixed point (e.g. 100.00% with <kbd>!Scratchram_PercentageFixedPointPrecision == #$02</kbd> would be 10000 (<kbd>#$2710</kbd>) would be stored here). Why is this 32-bit? To prevent potential overflows.
				This result is rounded to <kbd>10<sup style="white-space: nowrap">-(!Scratchram_PercentageFixedPointPrecision)</sup></kbd> (let's call this interval a "unit") depending on what variant of this subroutine being used:
				<ul>
					<li><kbd>ConvertToPercentage</kbd>: Rounds 1/2 up to nearest unit</li>
					<li><kbd>ConvertToPercentageRoundDown</kbd>: Always round down.</li>
					<li><kbd>ConvertToPercentageRoundUp</kbd>: Round up (if during division there is a remainder).</li>
				</ul>
				
				</td></tr>
				<tr><td><kbd>Y register (8-bit/1-byte, not stored)</kbd></td><td>Rounding to 0% (Y=$01) or 100% (Y=$02) detection. Use to prevent misleading displays.</td></tr>
			</table>
		</td>
	</tr>
</table>
<table>
	<tr><th>Destroyed</th><th>description</th></tr>
	<tr>
		<td>
			<kbd>$06</kbd>-<kbd>$07</kbd> (2 bytes)
		</td>
		<td>
			Needed to compare the remainder with half the denominator (for rounding).
		</td>
	</tr>
</table>
I've made a left-aligned code that automatically writes the decimal point, so no worries if you wanted this format. That template code should have everything you need.<br><br>

You may be wondering, why am I using 16-bit on some areas (including within the <kbd>ConvertToPercentage</kbd>) when I don't need to? Well, this is designed to prevent potential overflows and displaying wrong values.

</p>
<hr>
<h2 id="RepeatedSymbol"><a href="#RepeatedSymbolBack">^</a>Displaying repeated symbols n times</h2>
<p>You probably have seen something like this in most video games that represents individual health using repeated collection of icons with none, some, or all of them &ldquo;filled&rdquo; and/or empty, for example
4/5 filled shows 5 symbols with the first 4 of them filled:<br>
<font size="10">&#9642;&#9642;&#9642;&#9642;&#9643;</font><br>
SMW actually does this with its yoshi coin counter (some or all of them shows a coin symbol with the rest showing tile $FC). This is often used whenever a number of something is a small amount. Code follows (make sure you insert
&ldquo;<kbd>RepeatedSymbols.asm</kbd>&rdquo; into uberasm tool's library as well):
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!MaxNumberOfSymbols = 5								;&gt;Total number of symbols (maximum)
!Leftwards = 0									;&gt;0 = left-to-right when filling, 1 = right-to-left when filling.

	main:
	LDA !Freeram_ValueDisplay1_1Byte			;\$00: How many filled icons
	STA $00							;/
	LDA #!MaxNumberOfSymbols				;\$01: How many total icons
	STA $01							;/
	LDA #!StatusBar_RepeatedSymbols_EmptyTile		;\$02: Empty tile number
	STA $02							;/
	LDA #!StatusBar_RepeatedSymbols_FullTile		;\$03: Full tile number
	STA $03							;/
	LDA.b #!StatusBar_TestDisplayElement_Pos_Tile		;\$04-$06: Address of tile numbers to write to the HUD
	STA $04							;|
	LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;8	;|
	STA $05							;|
	LDA.b #!StatusBar_TestDisplayElement_Pos_Tile&gt;&gt;16	;|
	STA $06							;/
	if !StatusBar_UsingCustomProperties
		LDA #!StatusBar_RepeatedSymbols_EmptyProp		;\$07: Empty tile properties
		STA $07							;/
		LDA.b #!StatusBar_RepeatedSymbols_FullProp		;\$08: Full tile properties
		STA $08							;/
		LDA.b #!StatusBar_TestDisplayElement_Pos_Prop		;\$09-$0B: Address of tile properties to write to the HUD
		STA $09							;|
		LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;8	;|
		STA $0A							;|
		LDA.b #!StatusBar_TestDisplayElement_Pos_Prop&gt;&gt;16	;|
		STA $0B							;/
	endif
	if !StatusbarFormat == $01
		if !Leftwards == 0
			JSL RepeatedSymbols_WriteRepeatedSymbols
		else
			JSL RepeatedSymbols_WriteRepeatedSymbolsLeftwards
		endif
	else
		if !Leftwards == 0
			JSL RepeatedSymbols_WriteRepeatedSymbolsFormat2
		else
			JSL RepeatedSymbols_WriteRepeatedSymbolsLeftwardsFormat2
		endif
	endif
	RTL</pre></div><br>
Using that code from above, the result is this with RAM $60 containing the value 3:<br>
<kbd>WriteRepeatedSymbols</kbd>: <img src="Readme_Files/RepeatedSymbol_3_5.png"> (SMW does not have a &ldquo;empty tile&rdquo; that is visible, so instead of using tile $FC, I used
tile $26, which is the &ldquo;X&rdquo; symbol.), when using <kbd>WriteRepeatedSymbolsLeftwards</kbd> (<kbd>!Leftwards = 1</kbd>): <img src="Readme_Files/RepeatedSymbolLeftwards_3_5.png"></p>

<p>I also included vertical version, <kbd>WriteRepeatedSymbolsWriteVertically</kbd>. Example code:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!MaxNumberOfSymbols = 5								;&gt;Total number of symbols (maximum).
!VerticalDirection = 0								;&gt;0 = up, 2 = down, don't use any other values

;Don't touch anything below here
	if !VerticalDirection == 0
		;Upwards
		!StatusBarPosition = !StatusBar_TestDisplayElement_VerticalRepeatedIconsUpwards_Pos_Tile	;&gt;Where to write on the status bar (the first tile to fill when increased)
		!StatusBarPositionProps = !StatusBar_TestDisplayElement_VerticalRepeatedIconsUpwards_Pos_Prop	;&gt;Same as above but for tile properties
	else
		;Downwards
		!StatusBarPosition = !StatusBar_TestDisplayElement_VerticalRepeatedIconsDownwards_Pos_Tile	;&gt;Where to write on the status bar (the first tile to fill when increased)
		!StatusBarPositionProps = !StatusBar_TestDisplayElement_VerticalRepeatedIconsDownwards_Pos_Prop	;&gt;Same as above but for tile properties
	endif
;Code below
	main:
	LDA !Freeram_ValueDisplay1_1Byte				;\$00: How many filled icons
	STA $00								;/
	LDA #!MaxNumberOfSymbols					;\$01: How many total icons
	STA $01								;/
	LDA #!StatusBar_RepeatedSymbols_EmptyTile			;\$02: Empty tile number
	STA $02								;/
	LDA #!StatusBar_RepeatedSymbols_FullTile			;\$03: Full tile number
	STA $03								;/
	LDA.b #!StatusBarPosition					;\$04-$06: Address of tile numbers to write to the HUD
	STA $04								;|
	LDA.b #!StatusBarPosition&gt;&gt;8					;|
	STA $05								;|
	LDA.b #!StatusBarPosition&gt;&gt;16					;|
	STA $06								;/
	if !StatusBar_UsingCustomProperties
		LDA #!StatusBar_RepeatedSymbols_EmptyProp		;\$07: Empty tile properties
		STA $07							;/
		LDA.b #!StatusBar_RepeatedSymbols_FullProp		;\$08: Full tile properties
		STA $08							;/
		LDA.b #!StatusBarPositionProps				;\$09-$0B: Address of tile properties to write to the HUD
		STA $09							;|
		LDA.b #!StatusBarPositionProps&gt;&gt;8			;|
		STA $0A							;|
		LDA.b #!StatusBarPositionProps&gt;&gt;16			;|
		STA $0B							;/
	endif
	LDA.b #!VerticalDirection
	STA $0C
	if !StatusbarFormat == $01
		JSL RepeatedSymbols_WriteRepeatedSymbolsWriteVertically
	else
		JSL RepeatedSymbols_WriteRepeatedSymbolsWriteVerticallyFormat2
	endif
	RTL</pre></div>
Please note that this only supports status bars whose rows are all 32 tiles each, with each rows are lined up vertically, and each row are contiguous to each other, else your tiles will not line up vertically.
Only Super status bar patch, SMB3 status bar, and OWB+ patch have these at the time of writing this. Also note that this is not to be used for stripe images, as stripe images have their own dedicated vertical version
of tile writes.<br><br>

The functions:

<table>
	<tr>
		<th>Subroutine name</th>
		<th>Input</th>
		<th>Output</th>
		<th>Notes</th>
	</tr>
	<tr>
		<td>
			<kbd>WriteRepeatedSymbols</kbd> / <kbd>WriteRepeatedSymbolsLeftwards</kbd> (including <kbd>Format2</kbd>)
		</td>
		<td>
			<table>
				<tr>
					<th>Input</th>
					<th>description</th>
				</tr>
				<tr><td><kbd>$00</kbd></td><td>Amount filled</td></tr>
				<tr><td><kbd>$01</kbd></td><td>Total amount (Maximum)</td></tr>
				<tr><td><kbd>$02</kbd></td><td>Tile number for empty</td></tr>
				<tr><td><kbd>$03</kbd></td><td>Tile number for full</td></tr>
				<tr><td><kbd>$04</kbd>-<kbd>$06</kbd> (3 bytes)</td><td>Status bar address to write tile numbers (this is the leftmost tile, regardless if filling rightwards or leftwards)</td></tr>
				<tr><td><kbd>$07</kbd></td><td>Tile properties for empty*</td></tr>
				<tr><td><kbd>$08</kbd></td><td>Tile properties for full*</td></tr>
				<tr><td><kbd>$09</kbd>-<kbd>$0B</kbd> (3 bytes)</td><td>Status bar address to write tile properties*</td></tr>
			</table><br>
		</td>
		<td>
			<table>
				<tr>
					<th>Output</th>
					<th>description</th>
				</tr>
				<tr><td><kbd>RAM_In_Addr04</kbd> to <kbd>[RAM_In_Addr04 + ((ValueIn01-1) * !StatusbarFormat)]</kbd></td><td>Repeated tiles in question</td></tr>
				<tr><td><kbd>RAM_In_Addr09</kbd> to <kbd>[RAM_In_Addr09 + ((ValueIn01-1) * !StatusbarFormat)]</kbd></td><td>Repeated tile properties in question.*</td></tr>
				<tr><td><kbd>$00</kbd></td><td>How much extra fills if exceeding max, otherwise 0; <kbd>FillsLeft = <abbr title="Picks highest number; e.g. max(-1, 0) returns 0">max</abbr>(AmountFilled - TotalAmount, 0)</kbd></td></tr>
				<tr><td><kbd>$01</kbd></td><td>Will be zero, used as a count down how many tiles left to write.</td></tr>
			</table>
		</td>
		<td>You can use this for stripe images, both vertical and horizontal. If using leftwards on a vertical stripe, it goes upwards, otherwise (rightwards) it goes downwards.</td>
	</tr>
	<tr>
		<td>
			<kbd>WriteRepeatedSymbolsWriteVertically</kbd> (again, including <kbd>Format2</kbd>)
		</td>
		<td>
			<table>
				<tr><th>Input</th><th>description</th></tr>
				<tr><td><kbd>$00</kbd></td><td>Amount filled</td></tr>
				<tr><td><kbd>$01</kbd></td><td>Total amount (Maximum)</td></tr>
				<tr><td><kbd>$02</kbd></td><td>Tile number for empty</td></tr>
				<tr><td><kbd>$03</kbd></td><td>Tile number for full</td></tr>
				<tr><td><kbd>$04</kbd>-<kbd>$06</kbd> (3 bytes)</td><td>Status bar address to write tile numbers (where the first tile fills up when increasing; the bottom tile for upwards, top tile for downwards)</td></tr>
				<tr><td><kbd>$07</kbd></td><td>Tile properties for empty*</td></tr>
				<tr><td><kbd>$08</kbd></td><td>Tile properties for full*</td></tr>
				<tr><td><kbd>$09</kbd>-<kbd>$0B</kbd> (3 bytes)</td><td>Status bar address to write tile properties* (where the first tile fills up when increasing; the bottom tile for upwards, top tile for downwards)</td></tr>
				<tr><td><kbd>$0C</kbd></td><td>Direction: <kbd>#$00 = upwards</kbd>, <kbd>#$02 = downwards</kbd>. Don't use any other values.</td></tr>
			</table><br>
		</td>
		<td>
			<table>
				<tr><th>Output</th><th>Description</th></tr>
				<tr><td><kbd>[RAM_In_Addr04]-(X*32*!StatusbarFormat)</kbd> where X increases from 0 to <kbd>NumberOfTiles-1</kbd>
				for upwards, <kbd>[RAM_In_Addr04]+(X*32*!StatusbarFormat)</kbd> where X increases from 0 to
				<kbd>NumberOfTiles-1</kbd> for downwards.</td><td>Tiles written to the status bar.</td></tr>
				<tr><td><kbd>[RAM_In_Addr09]-(X*32*!StatusbarFormat)</kbd> where X increases from 0 to <kbd>NumberOfTiles-1</kbd>
				for upwards, <kbd>[RAM_In_Addr09]+(X*32*!StatusbarFormat)</kbd> where X increases from 0 to
				<kbd>NumberOfTiles-1</kbd> for downwards.</td><td>Tiles properties written to the status bar.*</td></tr>
				<tr><td><kbd>$00</kbd></td><td>How much extra fills if exceeding max, otherwise 0; <kbd>FillsLeft = max(AmountFilled - TotalAmount, 0)</kbd></td></tr>
				<tr><td><kbd>$01</kbd></td><td>Will be zero, used as a count down how many tiles left to write.</td></tr>
			</table><br>
		</td>
		<td>Don't use this for stripe. Only supports <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major</a>-based layer 3 tilemaps for status bar and OWB, whose tiles are all 32 tiles wide</td>
	</tr>
</table>
<br>
*If <kbd>!StatusBar_UsingCustomProperties</kbd> set to 1.
</p>

<h2 id="GraphicalBar"><a href="#GraphicalBarBack">^</a>Display a graphical bar</h2>

Graphical bar, as in this:<br>
<img src="Readme_Files/TransperentBackground.png"><br>

<p>Unlike the repeated symbols, this allows you to:
<ul>
	<li>
		<p>Have multiple values per symbol, instead of 1 unit per icon. Meaning, fractions of a symbol are displayed. In <i>Legend of zelda</i> series,
		before <i>Ocarina of Time</i>, Each heart have 2 values, therefore 1/2 a heart can be shown, <i>Ocarina of Time</i> and later games have 4
		units per heart, so 1/4 hearts displayed</p>
	</li>
	<li>
		<p>Display a value of something more &ldquo;continuous&rdquo;, or more precise, as the amount increases. Not only that, you don't need long bars
		just to represent huge amounts.</p>
	</li>
	<li>
		<p>Display an approximate percentage of something out of maximum, which is often used in most RPG games to display HP as a ratio of max HP towards
		a percentage.</p>
	</li>
</ul>


<a href="https://www.smwcentral.net/?p=section&a=details&id=19552">Resource here</a><sup><a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">[1]</a></sup>.
Reason this package not including this is because too much information to be had here.</p>
<hr>
<h2 id="OverworldBorder"><a href="#OverworldBorderBack">^</a>Displaying stuff on the overworld border</h2>
<p>You may be asking, how do I display information on the overworld border? Well, I have good news, because the only thing you have to do is convert the tile numbering for the status bar to
the tile numbering of the overworld border, if you are dealing with displaying digits. For non-digit based things like the repeated symbols, just use a different tile number. The graphical
bar to be used on the OWB is already covered in that package. So only the numerical display we'll discuss here.</p>

<p>Please note that for testing some codes below, specifically ones that call subroutines that at least write tile properties into the status bar/OWB+, <b>requires</b> having <kbd>!StatusBar_UsingCustomProperties</kbd>
set to <kbd>1</kbd> because SMW's OWB and OWB+ patch have a default tile property page number being <kbd>0</kbd>, and by simply writing just the tile number will write garbage numbers on there due to being on the wrong
GFX page (numbers graphics are on page 1, not 0).</p>

<p>Remember that I mentioned that the digit graphics are stored in page 1 at tile numbers <kbd>$22</kbd>-<kbd>$2B</kbd>? Well, I've also included OWB converters in the routines folder. Here are the examples
(Create an ASM file, <kbd>OWBDisplayTest.asm</kbd>, with the following code, have it under &ldquo;overworld&rdquo; or gamemode <kbd>$0D-$0E</kbd> ($0D so the display happens during fade)). Also remember
that the provided examples assumes you've installed the overworld border plus patch:</p>

<p>Note: If you are displaying 2 numbers and/or a percentage here, you need to insert the graphics for LG4, because the 2-number and percentage display uses a slash and percent character that SMW does not have that
graphic. The filename in <kbd>ExGFX</kbd> should be obvious.</p>


<p>8-bit 2-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!RemoveLeadingZeroes = 0							;&gt;0 = Always show 10s digit, 1 = If value less than 10, replace 10s with blank.


	init:
	main:
	LDA !Freeram_ValueDisplay1_1Byte
	JSL HexDec_EightBitHexDec
	CLC
	ADC #$22
	STA !OverworldBorder_TestDisplayElement_Pos_Tile+(1*2)	;&gt;Write 1s place
	if !RemoveLeadingZeroes == 0
		TXA						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
		CLC						;\Convert digits to OWB digits
		ADC #$22					;/
	else
		
		TXA
		BEQ +					;&gt;If 10s place is zero, write a blank tile
		CLC					;\Convert digits to OWB digits
		ADC #$22				;/
		BRA ++
		+
		LDA #!OverWorldBorderBlankTile		;&gt;OWB Blank tile.
		++
	endif
	STA !OverworldBorder_TestDisplayElement_Pos_Tile	;&gt;Write 10s place
	
	;Set properties:
		LDA.b #!OverWorldBorder_TileProp
		STA !OverworldBorder_TestDisplayElement_Pos_Prop
		STA !OverworldBorder_TestDisplayElement_Pos_Prop+(1*2)
	RTL</pre></div></p>

<p>8-bit 3-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0							;&gt;0 = Have leading zeroes, 1 = no (leading spaces)


	main:
	.Display8Bit3Digits
		LDA !Freeram_ValueDisplay1_1Byte
		JSL HexDec_EightBitHexDec3Digits					;&gt;Obtain 3 digits in A (1s), X (10s) and Y (100s).
		CLC									;\Write 1s place (always written)
		ADC #$22								;|
		STA !OverworldBorder_TestDisplayElement_Pos_Tile+(2*!StatusbarFormat)	;/
		if !RemoveLeadingZeroes == 0
			TXA									;\Write 10s place
			CLC									;|
			ADC #$22								;|
			STA !OverworldBorder_TestDisplayElement_Pos_Tile+(1*!StatusbarFormat)	;/
			TYA									;\Write 100s place.
			CLC									;|
			ADC #$22								;|
			STA !OverworldBorder_TestDisplayElement_Pos_Tile			;/
		else
			..HandleHundreds
				CPY #$00
				BNE ...HundredsNonZero
				...NoHundreds
					LDA #!OverWorldBorderBlankTile
					STA !OverworldBorder_TestDisplayElement_Pos_Tile
					BRA ..HandleTens
				...HundredsNonZero
					TYA
					CLC
					ADC #$22
					STA !OverworldBorder_TestDisplayElement_Pos_Tile
					BRA ..HandleTens_WriteTens				;&gt;If 100+ then 10s should never be a blank tile
			..HandleTens
				CPX #$00
				BNE ...WriteTens
				...NoTens
					LDA #!OverWorldBorderBlankTile
					STA !OverworldBorder_TestDisplayElement_Pos_Tile+(1*2)
					BRA ..DigitsDone
				...WriteTens
					TXA
					CLC
					ADC #$22
					STA !OverworldBorder_TestDisplayElement_Pos_Tile+(1*2)
			..DigitsDone
		endif
		
		;Set properties
			LDA.b #!OverWorldBorder_TileProp
			STA !OverworldBorder_TestDisplayElement_Pos_Prop
			STA !OverworldBorder_TestDisplayElement_Pos_Prop+(1*2)
			STA !OverworldBorder_TestDisplayElement_Pos_Prop+(2*2)
		RTL</pre></div></p>
<p>16-bit N-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).
!RemoveLeadingZeroes = 0							;&gt;0 = Have leading zeroes, 1 = no (leading spaces)


	init:
	main:
	REP #$20
	LDA !Freeram_ValueDisplay1_2Bytes
	STA $00
	SEP #$20
	JSL HexDec_SixteenBitHexDecDivision
	if !RemoveLeadingZeroes != 0
		JSL HexDec_RemoveLeadingZeroes16Bit
	endif
	JSL HexDec_SixteenBitHexDecDivisionToOWB	;&gt;Convert to OWB graphic.
	
	;Write to overworld border
		LDX.b #((!NumberOfDigitsDisplayed-1)*2)
		LDY.b #(!NumberOfDigitsDisplayed-1)
		-
		LDA.w !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1)|!dp,y
		STA !OverworldBorder_TestDisplayElement_Pos_Tile,x
		LDA.b #!OverWorldBorder_TileProp						;\Page 1, Palette 6, and Priority ON
		STA.l !OverworldBorder_TestDisplayElement_Pos_Prop,x				;/
		DEY
		DEX #2
		BPL -
	RTL
</pre></div></p>
<p>32-bit n-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0							;&gt;0 = Have leading zeroes, 1 = no (leading spaces)

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !Setting_32bitHexDec_MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;&gt;How many digits, enter 1-10 (pointless if you enter less than 5).

incsrc "../StatusBarRoutinesDefines/Defines.asm"

	;Don't change this.
	main:
	REP #$20
	LDA !Freeram_ValueDisplay1_4Bytes				;\Low word (example: $3344 -&gt; [$44, $33] in $00, $01)
	STA $00								;/
	LDA !Freeram_ValueDisplay1_4Bytes+2				;\High word (example: $1122 -&gt; [$22, $11] in $02, $03)
	STA $02								;/
	SEP #$20
	JSL HexDec_ThirtyTwoBitHexDecDivision	;&gt;Should Output example as: [$02, $08, $07, $04, $05, $04, $00, $02, $00] on !Scratchram_32bitHexDecOutput.
	if !RemoveLeadingZeroes != 0
		JSL HexDec_RemoveLeadingZeroes32Bit
	endif
	JSL HexDec_ThirtyTwoBitHexDecDivisionToOWB
	
	;Write to overworld border:
		LDX #((!NumberOfDigitsDisplayed-1)*2)
		LDY #(!NumberOfDigitsDisplayed-1)
		-
		PHX
		TYX							;&gt;Sigh, LDA $xxxxxx,y does not exist.
		LDA (!Scratchram_32bitHexDecOutput)+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
		PLX
		STA !OverworldBorder_TestDisplayElement_Pos_Tile,x
		LDA.b #!OverWorldBorder_TileProp
		STA.l !OverworldBorder_TestDisplayElement_Pos_Prop,x
		DEY
		DEX #2
		BPL -
	RTL</pre></div></p>
<p>Left and right aligned with 16-bit numbers:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!DisplayTwoNumbers = 1			;&gt;0 = only the first number, 1 = display 2.
!RightAligned = 1			;&gt;0 = left, 1 = right.


!NumberOfDigitsDisplayed = 5		;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

;Note: Pointless and a waste of processing to use the digit alignment display if you plan on having
;!DisplayTwoNumbers set to 0 and !RightAligned set to 1, as calling the HexDec routine, replace leading
;zeroes with blank tiles, then writing to the status bar/OWB would do the exact same thing with less processing.


;Don't touch
	if !RightAligned == 0
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_Pos_Tile	;&gt;Where to write on the OWB (left aligned)
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_Pos_Prop	;&gt;Where to write on the overworld border (properties, left aligned)
	else
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Tile	;&gt;Where to write on the OWB (right aligned)
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Prop	;&gt;Where to write on the overworld border (properties, right aligned)
	endif
;Code
	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90"). Also set up the properties.
		if !DisplayTwoNumbers == 0
			LDX.b #(!NumberOfDigitsDisplayed-1)*2
		else
			LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*2
		endif
		-
		if !RightAligned == 0
			LDA #!OverWorldBorderBlankTile		;\Clear tiles
			STA !OverworldBorderPositionTile,x	;/
			LDA.b #!OverWorldBorder_TileProp	;\Set tile properties
			STA.l !OverworldBorderPositionProp,x	;/
		else
			LDA #!OverWorldBorderBlankTile
			STA !OverworldBorderPositionTile-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
			LDA.b #!OverWorldBorder_TileProp
			STA.l !OverworldBorderPositionProp-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
		endif
		DEX #2
		BPL -
	if !DisplayTwoNumbers == 0
		;Number to string.
			;Process HexDec
				REP #$20						;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay1_2Bytes			;|
				STA $00							;|
				SEP #$20						;|
				JSL HexDec_SixteenBitHexDecDivision			;/
			;Remove leading zeroes and have it as a character table
				LDX #$00					;&gt;Start at character position 0.
				JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
			;Prevent writing too much characters.
				CPX.b #!NumberOfDigitsDisplayed+1		;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits				;/not being cleared from the previous code.
			;Convert to OWB digits
				JSL HexDec_ConvertAlignedDigitToOWB		;&gt;Convert to OWB digits (aligned digits)
	else
		;First number
			;Process HexDec
				REP #$20						;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay1_2Bytes			;|
				STA $00							;|
				SEP #$20						;|
				JSL HexDec_SixteenBitHexDecDivision			;/
			;Remove leading zeroes and have it as a character table
				LDX #$00					;&gt;Start at character position 0.
				JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
		;"/" symbol
				LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
				STA !Scratchram_CharacterTileTable,x		;/
				INX						;&gt;Next character position.
		;Second number
			;Process HexDec
				PHX							;&gt;Push X because it gets modified by the HexDec routine.
				REP #$20						;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay2_2Bytes			;|
				STA $00							;|
				SEP #$20						;|
				JSL HexDec_SixteenBitHexDecDivision			;/
				PLX							;&gt;Restore.
			;Remove leading zeroes and have it as a character table
				JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
			;Prevent writing too much characters.
				CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)	;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits				;/not being cleared from the previous code.
			;Convert to OWB digits
				JSL HexDec_ConvertAlignedDigitToOWB		;&gt;Convert to OWB digits (aligned digits)
	endif
	;Write to OWB
		LDA.b #!OverworldBorderPositionTile     : STA $00
		LDA.b #!OverworldBorderPositionTile&gt;&gt;8  : STA $01
		LDA.b #!OverworldBorderPositionTile&gt;&gt;16 : STA $02
		LDA.b #!OverWorldBorder_TileProp
		STA $06
		LDA.b #!OverworldBorderPositionProp     : STA $03
		LDA.b #!OverworldBorderPositionProp&gt;&gt;8  : STA $04
		LDA.b #!OverworldBorderPositionProp&gt;&gt;16 : STA $05
		if !RightAligned != 0
			;Convert to right-aligned
				JSL HexDec_ConvertToRightAlignedFormat2
		endif
		JSL HexDec_WriteStringDigitsToHUDFormat2
	..TooMuchDigits
	RTL</pre></div></p>
<p>Left and right aligned with 32-bit numbers:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!DisplayTwoNumbers = 1								;&gt;0 = only the first number, 1 = display 2.
!RightAligned = 0								;&gt;0 = left, 1 = right.
!NumberOfDigitsDisplayed = 9							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).


;Don't touch these unless you know what you're doing
	if !RightAligned == 0
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_Pos_Tile	;&gt;Where to write on the overworld border for left aligned
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_Pos_Prop	;&gt;Same as above but tile props.
	else
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Tile	;&gt;Where to write on the overworld border for right aligned
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Prop	;&gt;Same as above but tile props.
	endif
;Code below
	main:
	.NumberDisplayTest
	;Clear the tiles. To prevent leftover "ghost" tiles that should've
	;disappear when the number of digits decreases (so when "10" becomes "9",
	;won't display "90").
		if !DisplayTwoNumbers == 0
			LDX.b #(!NumberOfDigitsDisplayed-1)*2
		else
			LDX.b #(((!NumberOfDigitsDisplayed*2)+1)-1)*2
		endif
		-
		if !RightAligned == 0
			LDA #!OverWorldBorderBlankTile
			STA !OverworldBorderPositionTile,x
			LDA.b #!OverWorldBorder_TileProp
			STA !OverworldBorderPositionProp,x
		else
			LDA #!OverWorldBorderBlankTile
			STA !OverworldBorderPositionTile-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
			LDA.b #!OverWorldBorder_TileProp
			STA.l !OverworldBorderPositionProp-((((!NumberOfDigitsDisplayed*2)+1)-1)*2),x
		endif
		DEX #2
		BPL -
	if !DisplayTwoNumbers == 0
		;First number
			;Process HexDec
				REP #$20							;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay1_4Bytes				;|
				STA $00								;|
				LDA !Freeram_ValueDisplay1_4Bytes+2				;|
				STA $02								;|
				SEP #$20							;|
				JSL HexDec_ThirtyTwoBitHexDecDivision				;/
			;Remove leading zeroes and have it as a character table
				LDX #$00							;&gt;Start at character position 0.
				JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at position 0.
			;Prevent writing too many characters
				CPX.b #!NumberOfDigitsDisplayed+1				;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits						;/not being cleared from the previous code.
			;Convert to OWB digits
				JSL HexDec_ConvertAlignedDigitToOWB				;&gt;Convert to OWB digits (aligned digits)
	else
		;First number
			;Process HexDec
				REP #$20							;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay1_4Bytes				;|
				STA $00								;|
				LDA !Freeram_ValueDisplay1_4Bytes+2				;|
				STA $02								;|
				SEP #$20							;|
				JSL HexDec_ThirtyTwoBitHexDecDivision				;/
			;Remove leading zeroes and have it as a character table
				LDX #$00							;&gt;Start at character position 0.
				JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at after the slash symbol.
		;"/" symbol
				LDA #!StatusBarSlashCharacterTileNumb				;\Slash symbol.
				STA !Scratchram_CharacterTileTable,x				;/
				INX								;&gt;Next character position.
		;Second number
			;Process HexDec
				PHX								;&gt;Push X because it gets modified by the HexDec routine.
				REP #$20							;\Convert a given number to decimal digits.
				LDA !Freeram_ValueDisplay2_4Bytes				;|
				STA $00								;|
				LDA !Freeram_ValueDisplay2_4Bytes+2				;|
				STA $02								;|
				SEP #$20							;|
				JSL HexDec_ThirtyTwoBitHexDecDivision				;/
				PLX								;&gt;Restore.
			;Remove leading zeroes and have it as a character table
				JSL HexDec_SupressLeadingZeros32Bit				;&gt;Write the digits (without leading zeroes) starting at position 0.
			;Prevent writing too much characters.
				CPX.b #(((!NumberOfDigitsDisplayed*2)+1)+1)			;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..TooMuchDigits						;/not being cleared from the previous code.
			;Convert it to OWB digits and numbers
				JSL HexDec_ConvertAlignedDigitToOWB
	endif
	;Write to OWB
		LDA.b #!OverworldBorderPositionTile : STA $00			;\Set address to write at a given status bar position (tile number).
		LDA.b #!OverworldBorderPositionTile&gt;&gt;8 : STA $01		;|
		LDA.b #!OverworldBorderPositionTile&gt;&gt;16 : STA $02		;/
		LDA.b #!OverWorldBorder_TileProp : STA $06
		LDA.b #!OverworldBorderPositionProp : STA $03			;\Set address to write at a given status bar position (tile properties).
		LDA.b #!OverworldBorderPositionProp&gt;&gt;8 : STA $04		;|
		LDA.b #!OverworldBorderPositionProp&gt;&gt;16 : STA $05		;/
		if !RightAligned != 0
			;Convert to right-aligned
				JSL HexDec_ConvertToRightAlignedFormat2
		endif
		
		if !StatusbarFormat == $01
			JSL HexDec_WriteStringDigitsToHUD
		else
			JSL HexDec_WriteStringDigitsToHUDFormat2
		endif
	..TooMuchDigits
	RTL
</pre></div></p>
<p>A percentage:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!Default_PercentagePrecision = 2
 ;^0 = show whole number precisions, 1 = 1/10 of a percentage, 2 = 1/100. Not to be confused
 ; with !Scratchram_PercentageFixedPointPrecision.
!CapAt100 = 1								;&gt;0 = allow percentage to display values greater than 100, 1 = cap at 100.
!RightAligned = 1							;&gt;0 = left-aligned, 1 = right-aligned.


;Don't touch
	if !RightAligned == 0
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_Pos_Tile	;&gt;Where to write on the overworld border (tile number)
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_Pos_Prop	;&gt;Same as above but tile properties
	else
		!OverworldBorderPositionTile = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Tile	;&gt;Where to write on the overworld border (tile number, right aligned)
		!OverworldBorderPositionProp = !OverworldBorder_TestDisplayElement_RightAlignedText_Pos_Prop	;&gt;Same as above but tile properties
	endif


;Code below
main:
	;Submit fraction
		REP #$20
		LDA !Freeram_ValueDisplay1_2Bytes
		STA !Scratchram_PercentageQuantity
		LDA !Freeram_ValueDisplay2_2Bytes
		STA !Scratchram_PercentageMaxQuantity
		SEP #$20
		LDA #!Default_PercentagePrecision
		STA !Scratchram_PercentageFixedPointPrecision
		JSL HexDec_ConvertToPercentage
	;Prevent display percentages greater than 100%.
	;Note to self:
	;100				= $00000064
	;1000 (display as ***.*)	= $000003E8
	;10000 (display as ***.**)	= $00002710
		if !CapAt100 != 0
			.CheckExceed100
				REP #$30
				LDX.w #(10**(!Default_PercentagePrecision+2))
				;Check the high word of the XXXX (RAM_00-RAM_03 = $XXXXYYYY)
					LDA $02			;\Any nonzero digits in the high word would mean at least
					BNE ..Cap100		;/65536 ($00010000), which is guaranteed over 100/1000/10000.
				;Check low word
					TXA
					CMP $00			;\Max compares with RAM_00
					BCS ..Under		;/If Max &gt;= RAM_00 or RAM_00 is lower, don't set it to max.
				
				..Cap100
					TXA
					STA $00
				..Under
				SEP #$30
		endif
	;Avoid displaying 0% and 100% misleadingly if close to them.
		CPY #$00
		BEQ .Normal
		CPY #$01
		BEQ .RoundTo1Percent
		CPY #$02
		BCS .RoundTo99Percent		;&gt;Just in case somehow Y is a value $03 or more
		
		.RoundTo1Percent
			REP #$20
			LDA.w #1
			STA $00
			STZ $02
			SEP #$20
			BRA .Normal
		.RoundTo99Percent
			REP #$20
			LDA.w #(10**(!Default_PercentagePrecision+2)-1)		;&gt;99%, 99.9%, or 99.99%.
			STA $00
			STZ $02
			SEP #$20
		.Normal
	;Display the number.
		if !Default_PercentagePrecision == 0
			;Since it is very unlikely you display percentage greater than 100 (assuming you set !Default_PercentagePrecision to 0), you mostly
			;likely just need to use $00 (8-bit) alone.
			if !RightAligned == 1
				..DisplayDigits
					LDA $00
					JSL HexDec_EightBitHexDec3Digits			;&gt;A = 1s, X = 10s, Y = 100s
					CLC							;\Write 1s place
					ADC #$22						;|
					STA !OverworldBorderPositionTile-(1*2)			;/
					...HandleHundreds
						CPY #$00					;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
						BNE ....HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
						....NoHundreds
							LDA #!OverWorldBorderBlankTile			;\Erase the 100s digit
							STA !OverworldBorderPositionTile-(3*2)		;/
							BRA ...HandleTens				;&gt;Check if the next digit is also part of the leading zero.
						....HundredsNonZero
						TYA						;\Write 100s place
						CLC						;|
						ADC #$22					;|
						STA !OverworldBorderPositionTile-(3*2)		;/
						BRA ...HandleTens_WriteTens			;&gt;If at least 100, 10s shouldn't be omitted.
					...HandleTens
						CPX #$00					;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
						BNE ....WriteTens				;/No, then erase the 10s.
						....NoTens
							LDA #!OverWorldBorderBlankTile			;&gt;If 0, replace 10s digit with blank.
							STA !OverworldBorderPositionTile-(2*2)
							BRA ...WritePercent
						....WriteTens
							TXA						;\Write 10s place
							CLC						;|
							ADC #$22					;|
							STA !OverworldBorderPositionTile-(2*2)		;/
					...WritePercent
						LDA #!OverWorldBorderPercentTile
						STA !OverworldBorderPositionTile-(0*2)
					..WriteProps
						LDA.b #!OverWorldBorder_TileProp
						STA !OverworldBorderPositionProp-(0*2)
						STA !OverworldBorderPositionProp-(1*2)
						STA !OverworldBorderPositionProp-(2*2)
						STA !OverworldBorderPositionProp-(3*2)
			elseif !RightAligned == 0
				STZ $01
				JSL HexDec_SixteenBitHexDecDivision
				
				.ClearTiles
				;Clear the tiles. To prevent leftover "ghost" tiles that should've
				;disappear when the number of digits decreases (so when "10" becomes "9",
				;won't display "90"). Also setup tile properties when enabled.
					LDX.b #(4-1)*2
					..Loop
						LDA #!OverWorldBorderBlankTile
						STA !OverworldBorderPositionTile,x
						LDA.b #!OverWorldBorder_TileProp
						STA !OverworldBorderPositionProp,x
						DEX #2
						BPL ..Loop
				.StatusBarString
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
				;Prevent writing too much characters.
					CPX.b #4+1					;\Failsafe to avoid writing more characters than intended would write onto tiles
					BCS ..TooMuchDigits				;/not being cleared from the previous code.
				;Write percent symbol after the number
					LDA #!StatusBarPercentTile			;\Write percent symbol
					STA !Scratchram_CharacterTileTable,x		;/
					INX
					JSL HexDec_ConvertAlignedDigitToOWB
				;Write to status bar
					LDA.b #!OverworldBorderPositionTile : STA $00
					LDA.b #!OverworldBorderPositionTile&gt;&gt;8 : STA $01
					LDA.b #!OverworldBorderPositionTile&gt;&gt;16 : STA $02
					LDA.b #!OverworldBorderPositionProp : STA $03
					LDA.b #!OverworldBorderPositionProp&gt;&gt;8 : STA $04
					LDA.b #!OverworldBorderPositionProp&gt;&gt;16 : STA $05
					LDA.b #!OverWorldBorder_TileProp : STA $06
					JSL HexDec_WriteStringDigitsToHUDFormat2
					..TooMuchDigits
			endif
		else
			JSL HexDec_SixteenBitHexDecDivision
			if !RightAligned == 1
				if !Default_PercentagePrecision == 1
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast2
					;XXX.X%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/10s place
					JSL HexDec_SixteenBitHexDecDivisionToOWB
					
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !OverworldBorderPositionTile-(5*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(5*2)	;&gt;100s place
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !OverworldBorderPositionTile-(4*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(4*2)	;&gt;10s place
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !OverworldBorderPositionTile-(3*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(3*2)	;&gt;1s place
					LDA #!OverWorldBorderDotTile : STA !OverworldBorderPositionTile-(2*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(2*2)		;&gt;Decimal point symbol
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !OverworldBorderPositionTile-(1*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(1*2)	;&gt;1/10ths place
					LDA #!OverWorldBorderPercentTile : STA !OverworldBorderPositionTile-(0*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(0*2)		;&gt;percent symbol
				elseif !Default_PercentagePrecision == 2
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast3
					;XXX.XX%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$00 (10000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1/10s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/100s place
					JSL HexDec_SixteenBitHexDecDivisionToOWB
					
					LDA !Scratchram_16bitHexDecOutput+$00 : STA !OverworldBorderPositionTile-(6*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(6*2)	;&gt;100s place
					LDA !Scratchram_16bitHexDecOutput+$01 : STA !OverworldBorderPositionTile-(5*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(5*2)	;&gt;10s place
					LDA !Scratchram_16bitHexDecOutput+$02 : STA !OverworldBorderPositionTile-(4*2) : LDA #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(4*2)	;&gt;1s place
					LDA #!OverWorldBorderDotTile : STA !OverworldBorderPositionTile-(3*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(3*2)		;&gt;Decimal point symbol
					LDA !Scratchram_16bitHexDecOutput+$03 : STA !OverworldBorderPositionTile-(2*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(2*2)	;&gt;1/10ths place
					LDA !Scratchram_16bitHexDecOutput+$04 : STA !OverworldBorderPositionTile-(1*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(1*2)	;&gt;1/100ths place
					LDA #!OverWorldBorderPercentTile : STA !OverworldBorderPositionTile-(0*2) : LDA.b #!OverWorldBorder_TileProp : STA !OverworldBorderPositionProp-(0*2)		;&gt;percent symbol
				endif
			elseif !RightAligned == 0
				.ClearTiles
					LDA #!OverWorldBorderBlankTile
					if !Default_PercentagePrecision == 1
						LDX.b #($06-1)*2		;&gt;[100.0%] is 6 characters. So we must clear out 6 tiles.
					elseif !Default_PercentagePrecision == 2
						LDX.b #($07-1)*2		;&gt;[100.00%] is 7 characters. So we must clear out 7 tiles.
					endif
					..Loop
						STA !OverworldBorderPositionTile,x
						DEX #2
						BPL ..Loop
				LDX #$00
				if !Default_PercentagePrecision == 1
					LDA #!StatusBarDotTile					;\Decimal point
					STA $09							;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast2
				elseif !Default_PercentagePrecision == 2
					LDA #!StatusBarDotTile					;\Decimal point
					STA $09							;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast3
				endif
				LDA #!StatusBarPercentTile			;\Write percent symbol
				STA !Scratchram_CharacterTileTable,x		;/
				INX
				;Convert to OWB
					JSL HexDec_ConvertAlignedDigitToOWB
				;Write to OWB
					LDA.b #!OverworldBorderPositionTile : STA $00
					LDA.b #!OverworldBorderPositionTile&gt;&gt;8 : STA $01
					LDA.b #!OverworldBorderPositionTile&gt;&gt;16 : STA $02
					LDA.b #!OverworldBorderPositionProp : STA $03
					LDA.b #!OverworldBorderPositionProp&gt;&gt;8 : STA $04
					LDA.b #!OverworldBorderPositionProp&gt;&gt;16 : STA $05
					LDA.b #!OverWorldBorder_TileProp : STA $06
					JSL HexDec_WriteStringDigitsToHUDFormat2
			endif
		endif
			.Done
	;Done
		RTL
</pre></div></p>

<hr>
<h2 id="OAMHud"><a href="#OAMHudBack">^</a>Sprite-based HUD</h2>
<p>This part covers on how to display information in the form of sprite tiles. This means we will be dealing with OAM.</p>

<p>Before we get started, I highly recommend reading <a href="https://www.smwcentral.net/?p=viewthread&t=92218">this tutorial on coding sprites</a>. This document covers just the OAM handling.</p>

<h3>The OAM</h3>

<p>Drawing sprites involve storing these following information:</p>

<ul>
	<li>9 bits for the X position</li>
	<li>a byte for the Y position (<kbd>$F0</kbd> is offscreen and is used in SMW to determine if the tile is no longer used)</li>
	<li>a byte for the tile number to use</li>
	<li>a byte for the tile number properties to use (YXPPCCCT)</li>
</ul>
<p>There are 128 (numbered 0-127) slots each given this information. Stored in RAM <kbd>$7E0200-$7E041F</kbd> and <kbd>$7E0420-$7E049F</kbd>
(see <a href="Readme_Files/JS_OAM_Side_notes.html" id="OAMNotes">here for table and data format</a> for RAMs corresponding to which slot)
before transfered into the PPU. SMW reserves the later half (OAM slots 64-127) for its main sprites. Unlike layer 3 status bar handling:
<ul>
	<li>We have more information to write to display for sprite tiles.</li>
	<li>We have to explicitly write their X/Y position, in pixels whereas the layer 3, each tile is placed in a grid and have their own address. Stripe is somewhat similar but is confined to a grid. This also means that OAM can overlap.</li>
	<li>When writing tiles, we need to find out if the tile is used or not, and what's used can dynamically change, while the layer 3 status bar is mostly static.</li>
	<li>When using aligned digits display, you no longer have to clear out the tiles prior drawing your digits, since at the beginning of each frame, the game clears out the OAM by setting each OAM Y position to <kbd>$F0</kbd></li>
</ul>
</p>

<p>The good news is that most of the stuff are handled by subroutines from here, so you only need to know the basics of programming sprites as well as the inputs/outputs of the subroutines.</p>

<p>Note: These stuff here always handle HUD tiles as 8x8s, and very likely your sprite be composed 16x16 tiles, this means you have to manually set the size bit and have Y = <kbd>$FF</kbd> before calling
<kbd>%FinishOAMWrite()</kbd> (or <kbd>JSL $01B7B3</kbd>). To do that, see the previously link about the format.</p>

<p>The first thing is to insert the graphics, see <kbd>StatusBarTutorial/ExGFX</kbd>. Filenames are obvious.</p>

<h3>Notes</h3>
<ul>
<li>Due to sprites can display &ldquo;no tile&rdquo; by placing them offscreen (<kbd>OAM Y position = $F0</kbd> rather than a tile number, such as status bar tile <kbd>$FC</kbd>), writing digits using the following routines will always require a string-styled system
like how the RAM defined in <kbd>!Scratchram_CharacterTileTable</kbd> is being used by <kbd>SupressLeadingZeros</kbd>. Almost everything is performed similarly to the layer 3 status bar, up until you are done writing to <kbd>!Scratchram_CharacterTileTable</kbd>
(after the last time you call <kbd>SupressLeadingZeros</kbd>) is then you are dealing with OAM-related routines.</li>

<li>For repeating icon routines, they write to OAM directly without conversions, it does merely a loop of writing a given tile numbers and properties.</li>
</ul>
<h3 id="PixiSprite"><a href="#PixiSpriteBack">^</a>Pixi custom sprites</h3>
<p>I coded some templates in the <kbd>Pixi_CustomSprite</kbd> folder. To play around with them, insert the sprite (obviously you should insert the routines as well), place it in a level and use the D-pad to test the values.</p>
<p>For existing custom sprites, you'll have to edit them to display values.</p>

<h3 id="HUDSprites"><a href="#HUDSpritesBack">^</a>HUD-like sprites</h3>
<p>I provided a <b>patch</b> that merely writes OAM tiles to the screen (does not occupy any types of sprite slots (sprite slots for normal sprites (the ones that take 12/22 slots, by smw's enemies and pixi), cluster, extended, minor extended, bounce sprite, etc.)).
See <kbd>StatusBarTutorial/Patch_SpriteStatusBarTest</kbd>. To insert, use asar and patch to your game. Settings are in the patch file (defines pertaining the patch itself) and for global, in <kbd>StatusBarRoutinesDefines/Defines.asm</kbd>.</p>
<h3>Subroutines in OAMBasedHUD.asm</h3>
<p>Routines-based inputs is almost the same as the layer 3 status bar, you just have to read the comments and description in the code as well as the info in the subroutines to fully understand how this works and how to use it. I do not want to explain everything
as it would make this tutorial unnecessarily long.</p>

<p>Here are the subroutines to use. There are 2 variations, with the first one being for pixi sprites and the other with the <kbd>OAMOnly</kbd> (and 16-bit centering) in the name which writes OAM directly without using sprite slots at all.</p>

<p>Note: For pixi sprites, obviously <kbd>%GetDrawInfo()</kbd> must be used before calling subroutines that writes to the OAM table.</p>
<table>
<tr><th>Subroutine name</th><th>Input</th><th>Output</th><th>Description</th></tr>
<tr>
	<td><kbd>WriteStringAsSpriteOAM</kbd> and <kbd>WriteStringAsSpriteOAM_OAMOnly</kbd></td>
	<td>Pixi sprites:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>!Scratchram_CharacterTileTable</kbd> (<kbd>!NumberOfChar</kbd> bytes)</td>
				<td>The string (such as numbers)</td>
			</tr>
			<tr>
				<td><kbd>Y index</kbd> (8-bit XY)</td>
				<td>OAM index to start writing</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>X position relative to screen border (signed)</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>Y position relative to screen border (signed)</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> (1 byte)</td>
				<td>Number of tiles to write, minus 1</td>
			</tr>
			<tr>
				<td><kbd>$05</kbd> (1 byte)</td>
				<td>Properties (YXPPCCCT)</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> to <kbd>$08</kbd> (3 bytes)</td>
				<td>
					24-bit address location of a table for converting characters into graphics (often numbers):
					<table>
						<tr>
							<th>Value</th>
							<th>Graphic</th>
						</tr>
						<tr>
							<td><kbd>$00-$09</kbd></td>
							<td>Digits 0-9</td>
						</tr>
						<tr>
							<td><kbd>$0A</kbd></td>
							<td>"/"</td>
						</tr>
						<tr>
							<td><kbd>$0B</kbd></td>
							<td>"%"</td>
						</tr>
						<tr>
							<td><kbd>$0C</kbd></td>
							<td>"!"</td>
						</tr>
						<tr>
							<td><kbd>$0D</kbd></td>
							<td>"."</td>
						</tr>
						<tr>
							<td><kbd>$0E</kbd></td>
							<td>":"</td>
						</tr>
					</table>
					Note that the table must all be within a page, not crossing bank borders!
				</td>
			</tr>
		</table>
		<br>OAM only:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>!Scratchram_CharacterTileTable</kbd> (<kbd>!NumberOfChar</kbd> bytes)</td>
				<td>String to display</td>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>X position, relative to screen border (signed).</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> to <kbd>$03</kbd> (2 bytes)</td>
				<td>Y position, relative to screen border (signed).</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> to <kbd>$05</kbd> (2 bytes)</td>
				<td>Number of tiles to write, minus 1.</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> (1 byte)</td>
				<td>Properties (YXPPCCCT), will apply to all characters.</td>
			</tr>
			<tr>
				<td><kbd>$07</kbd> to <kbd>$09</kbd> (3 bytes)</td>
				<td>24-bit address location of a table for converting characters into graphics (often numbers). Same as the pixi version for <kbd>$06-$08</kbd></td>
			</tr>
		</table>
	</td>
	<td>
		<kbd>Y index</kbd> (8-bit, pixi sprites only): The OAM index after writing the last tile character. Does not output anything for OAM-only.
	</td>
	<td>
		Writes 8x8 tiles (often for numbers) into OAM in the form of text-style (1 line only). Can be used after calling Hexdec routines or after <kbd>SupressLeadingZeros</kbd>.
	</td>
</tr>
<tr>
	<td><kbd>GetStringXPositionCentered</kbd> and <kbd>GetStringXPositionCentered16Bit</kbd></td>
	<td>Pixi sprites:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>X index</kbd> (8-bit)</td>
				<td>How many characters</td>
			</tr>
			<tr>
				<td><kbd>$00</kbd> (1 byte)</td>
				<td>Sprite OAM X position</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>X position of the point the string to be centered with, relative to the sprite's origin (This routine takes what's in $00, add by what's in $03, then stores to $02)</td>
			</tr>
		</table>
		<br>16-bit:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>X index</kbd> (8-bit)</td>
				<td>How many characters.</td>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>The X position, relative to the borders of the screen, you want the string to be centered around on.</td>
			</tr>
		</table>
	</td>
	<td>
		Pixi sprites:
		<table>
			<tr>
				<th>Output</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>X position of string, for <kbd>WriteStringAsSpriteOAM</kbd>.</td>
			</tr>
		</table>
		<br>16-bit:
		<table>
			<tr>
				<th>Output</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>X position of the string, relative to the borders of the screen, for <kbd>WriteStringAsSpriteOAM</kbd> subroutine.</td>
			</tr>
		</table>
	</td>
	<td>
		Calculates the X position of the string to be centered with a given point. Use this before calling <kbd>WriteStringAsSpriteOAM</kbd>. Note that this ALWAYS treats each character 8 pixels wide.
		For more information about positioning, see <a id="SpritePositioningInfo_Back" href="Readme_Files/SpritePositining.html">this info</a></a>.
	</td>
</tr>
<tr>
	<td><kbd>WriteRepeatedIconsAsOAM</kbd> and <kbd>WriteRepeatedIconsAsOAM_OAMOnly</kbd></td>
	<td>Pixi sprites:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>Y index</kbd> (8-bit)</td>
				<td>OAM index</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>X position of the first tile relative to screen border (signed).</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>Y position of the first tile relative to screen border (signed).</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> (1 byte)</td>
				<td>Horizontal displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$05</kbd> (1 byte)</td>
				<td>Vertical displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> (1 byte)</td>
				<td>&ldquo;empty&rdquo; icon tile number</td>
			</tr>
			<tr>
				<td><kbd>$07</kbd> (1 byte)</td>
				<td>&ldquo;empty&rdquo; icon tile properties (YXPPCCCT)</td>
			</tr>
			<tr>
				<td><kbd>$08</kbd> (1 byte)</td>
				<td>&ldquo;full&rdquo; icon tile number</td>
			</tr>
			<tr>
				<td><kbd>$09</kbd> (1 byte)</td>
				<td>&ldquo;full&rdquo; icon tile properties (YXPPCCCT)</td>
			</tr>
			<tr>
				<td><kbd>$0A</kbd> (1 byte)</td>
				<td>How many icons filled</td>
			</tr>
			<tr>
				<td><kbd>$0B</kbd> (1 byte)</td>
				<td>How many total icons.</td>
			</tr>
		</table>
		<br>OAM only:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>X position of the first tile relative to screen border (16-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> to <kbd>$03</kbd> (2 bytes)</td>
				<td>Y position of the first tile relative to screen border (16-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> (1 byte)</td>
				<td>Horizontal displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$05</kbd> (1 byte)</td>
				<td>Vertical displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> (1 byte)</td>
				<td>Empty tile number</td>
			</tr>
			<tr>
				<td><kbd>$07</kbd> (1 byte)</td>
				<td>Empty tile properties</td>
			</tr>
			<tr>
				<td><kbd>$08</kbd> (1 byte)</td>
				<td>Full tile number</td>
			</tr>
			<tr>
				<td><kbd>$09</kbd> (1 byte)</td>
				<td>Full tile properties</td>
			</tr>
			<tr>
				<td><kbd>$0A</kbd> (1 byte)</td>
				<td>Number of tiles filled</td>
			</tr>
			<tr>
				<td><kbd>$0B</kbd> (1 byte)</td>
				<td>Total number of tiles.</td>
			</tr>

		</table>
	</td>
	<td>Pixi sprites:
		<table>
			<tr>
				<th>Output</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>Y index</kbd> (8-bit)</td>
				<td>OAM index after writing all icons</td>
			</tr>
		</table>
		<table>
			<tr>
				<th>Destroyed</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>Gets displaced by $07 for each icon written.</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>Gets displaced by $08 for each icon written.</td>
			</tr>
			<tr>
				<td><kbd>$0A</kbd> (1 byte)</td>
				<td>Will be <kbd>max(0, NumberOfFilledIcons-Total)</kbd> when routine is finished, used as a countdown on how many full tiles to write.</td>
			</tr>
			<tr>
				<td><kbd>$0B</kbd> (1 byte)</td>
				<td>Will be <kbd>#$00</kbd>. Used as a countdown on how many left to write total.</td>
			</tr>
		</table>
		<br>OAM only:
		<table>
			<tr>
				<th>Destroyed</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$03</kbd> (4 bytes)</td>
				<td>Overwritten as each tile displaced</td>
			</tr>
			<tr>
				<td><kbd>$0A</kbd> (1 byte)</td>
				<td>Will be <kbd>max(0, NumberOfFilledIcons-Total)</kbd> when routine is finished, used as a countdown on how many full tiles to write.</td>
			</tr>
			<tr>
				<td><kbd>$0B</kbd> (1 byte)</td>
				<td>Will be <kbd>#$00</kbd>. Used as a countdown on how many left to write total.</td>
			</tr>
		</table>
	</td>
	<td>
		<p>Writes repeated icons into OAM.</p>
		<p>Horizontal and vertical displacement refers to each displacement (in pixels) of each tile starting from the first tile being written. Negative numbers (<kbd>$80-$FF</kbd>) would write each tile to the left or up and positive numbers (<kbd>$01-$7F</kbd>)
		would write each to the right or down. This also means it affects the &ldquo;fill direction&rdquo; (e.g if horizontal displacement is <kbd>$F8</kbd>, the icons fill right-to-left). A displacement of <kbd>$00</kbd> means all the icons will be on
		the vertical and/or horizontal axis. Normally, you'll want a displacement value of <kbd>$F8</kbd> or <kbd>$08</kbd> on one axis with the other being <kbd>$00</kbd>. Examples follows:
		<img src="Readme_Files/RepeatedIconsDisplacements.png">
		</p>
	</td>
</tr>
<tr>
	<td>
		<kbd>CenterRepeatingIcons</kbd> and <kbd>CenterRepeatingIcons_OAMOnly</kbd>
	</td>
	<td>
		Pixi sprite:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>X position relative to screen border (signed, you can take $00/$01, offset it (add by some number), and write on here) of the point to be centered around with.</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>Y position relative to screen border (signed, you can take $00/$01, offset it (add by some number), and write on here) of the point to be centered around with.</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> (1 byte)</td>
				<td>X Displacement for each icon (signed)</td>
			</tr>
			<tr>
				<td><kbd>$05</kbd> (1 byte)</td>
				<td>Y Displacement for each icon (signed)</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> (1 byte)</td>
				<td>Max/total number of icons.</td>
			</tr>
		</table>
		<br>OAM only:
		<table>
			<tr>
				<th>Input</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>X position of the point to be centered around with, relative to screen border.</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> to <kbd>$03</kbd> (2 bytes)</td>
				<td>Y position of the point to be centered around with, relative to screen border.</td>
			</tr>
			<tr>
				<td><kbd>$04</kbd> (1 byte)</td>
				<td>X displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$05</kbd> (1 byte)</td>
				<td>Y displacement between each icon (8-bit signed)</td>
			</tr>
			<tr>
				<td><kbd>$06</kbd> (1 byte)</td>
				<td>Total number of icons.</td>
			</tr>
		</table>
	</td>
	<td>Pixi sprites:
		<table>
			<tr>
				<th>Output</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$02</kbd> (1 byte)</td>
				<td>X position for the repeated icons to be centered (signed).</td>
			</tr>
			<tr>
				<td><kbd>$03</kbd> (1 byte)</td>
				<td>Y position for the repeated icons to be centered (signed).</td>
			</tr>
		</table>
		<br>OAM only:
		<table>
			<tr>
				<th>Output</th>
				<th>Description</th>
			</tr>
			<tr>
				<td><kbd>$00</kbd> to <kbd>$01</kbd> (2 bytes)</td>
				<td>X position centered</td>
			</tr>
			<tr>
				<td><kbd>$02</kbd> to <kbd>$03</kbd> (2 bytes)</td>
				<td>Y position centered</td>
			</tr>
		</table>
	</td>
	<td>Calculates the X and Y position (of the first tile) of the repeating icons to be centered around a given point. For more information, see <a id="SpritePositioningInfo_Back2" href="Readme_Files/SpritePositining.html">this info</a>.</td>
</tr>
</table>
<hr>
<h2 id="StripeHud"><a href="#StripeHudBack">^</a>Stripe-based HUD</h2>
<p><i>See <a href="https://www.smwcentral.net/?p=viewthread&t=14531">this post at SMWC</a> about stripe images. Due to that not being updated for more than a decade and some info are wrong, best read
<a href="https://smwc.me/1600801">this one</a> and other posts after it afterwards before attempting this.</i></p>

<p>This section explains how to write layer 3 tiles anywhere on the layer 3 than just on the HUD. Please note this assumes you are using these ASM resources for <b>level</b>, not overworld, as the
tiles here by default uses status bar tiles.</p>

<p>Use this if you are not having a layer 3 background. And have the following set for your layer 3 scrolling:
<ul>
	<li><kbd>[check]</kbd> Force Layer 3 tiles with priority above other layers and sprites</li>
	<li><kbd>[check]</kbd> Enable advanced bypass settings for Layer 3</li>
	<li><kbd>[uncheck]</kbd> CGADSUB for Layer 3</li>
	<li><kbd>[uncheck]</kbd> Move layer 3 to subscreen</li>
	<li>Vertical scroll: <kbd>None</kbd></li>
	<li>Horizontal scroll: <kbd>None</kbd></li>
	<li>Initial Y position: <kbd>0</kbd></li>
	<li>Initial X position: <kbd>0</kbd></li>
</ul>
To set up writing to the stripe image, I made a subroutine, <kbd>SetupStripe</kbd> that does all the complex logic for you. The data usage follows:
<table>
	<tr><th>Input</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$00</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>X position, 0-63.</td></tr>
	<tr><td><kbd>$01</kbd></td><td style="text-align: center; vertical-align: middle;">1</td><td>Y position, 0-63.</td></tr>
	<tr>
		<td>
			<kbd>$02</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			What layer:
			<ul>
				<li><kbd>$02</kbd>: Layer 1</li>
				<li><kbd>$03</kbd>: Layer 2</li>
				<li><kbd>$05</kbd>: Layer 3</li>
			</ul>
		</td>
	</tr>
	<tr>
		<td>
			<kbd>$03</kbd>
		</td>
		<td style="text-align: center; vertical-align: middle;">1</td>
		<td>
			Direction and RLE: <kbd>%DR00000000</kbd>
			<ul>
				<li><kbd>R</kbd>: Repeat: 0 = no (manually write different tiles), 1 = yes (write one tile multiple times, based on input <kbd>$04-$05</kbd>)</li>
				<li><kbd>D</kbd>: Direction: 0 = horizontal (rightwards), 1 = vertical (downwards)</li>
			</ul>
		</td>
	</tr>
	<tr><td><kbd>$04</kbd> to <kbd>$05</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Number of tiles, minus 1 (a value of 2 here means 3 tiles). If RLE is used, this is how many times a tile is repeated, minus 1.</td></tr>
</table><br><br>
<table>
	<tr><th>Output</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$7F837B</kbd> to <kbd>$7F837C</kbd></td><td style="text-align: center; vertical-align: middle;">2</td><td>Updated length of stripe data.</td></tr>
	<tr><td><kbd>X register</kbd></td><td style="text-align: center; vertical-align: middle;">2 (not stored)</td><td>The index position of where to write tile data (starting at <kbd>$7F837D+4,x</kbd>). Note that the XY registers will be 16-bit.</td></tr>
</table><br><br>

<table>
	<tr><th>Destroyed</th><th>Number of bytes</th><th>Description</th></tr>
	<tr><td><kbd>$06</kbd> to <kbd>$08</kbd></td><td style="text-align: center; vertical-align: middle;">3</td><td>Used when not using RLE, to calculate the terminating byte location.</td></tr>
</table><br>
<div style="border: 20px; background-color: #300000; border: 20px solid #300000">
<p>Notes:</p>
	<ul>
		<li>The entire tilemap (assuming it is a 64x64 tile grid), is handled subdivided into 2x2 "screens" each having individual 32x32 tile zones, which internally handles XY position relative to each "screen". This subroutine treats XY position as
		absolute to the whole thing (example: a position of <kbd>X=32, Y=32</kbd> would be the bottom-right screen's <kbd>X=0, Y=0</kbd>).</li><br>
		<li>
			Any multi-tile writes crossing the screen border will cause wraparounds:
			<ul>
				<li>If the tile write is set to horizontal, and extends beyond the right edge (<kbd>X=31</kbd> within a screen), will wrap back to <kbd>X=0</kbd> and down a line (<kbd>Y+1</kbd>). If the same were to happen on the bottom row of
				the screen <kbd>Y=31</kbd>, would similarly wrap around but also advances to the next screen.</li><br>
				<li>If the tile write is set to vertical, and extends beyond the bottom edge of the screen, will wrap the Y position to <kbd>Y=0</kbd> and retains the X position but on the next screen.</li><br>
			</ul>
			What screens will multi-tile writes be written to goes in this order: Top-left &rightarrow; Top-right &rightarrow; Bottom-left &rightarrow; Bottom-right. Tiles written advancing past the bottom-right screen can corrupt the graphics, from my experience, several strange pixels from Mario sprite
			started showing. Here is a code testing the wraparound:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

;This ASM is for testing stripe wraparounds. Writes a red text "0123" onto the layer 3 tilemap.

init:
;Note to self
; $7F837D+4+(T*2)+P,x
;  - T = what tile along a stripe, starts at 0 at the given XY position, and each +1 is next tile.
;  - P = Tile byte type: 0 = tile number (TTTTTTTT), 1 = properties (YXPCCCTT)
;

!StatusBar_TilePropRed #= (!StatusBar_TileProp&%11100011)|%00001100

;Horizontal wraparound (Stripe 1)
	LDA.b #30
	STA $00
	LDA.b #5
	STA $01
	LDA #$05
	STA $02
	STZ $03
	LDA #$03
	STA $04
	STZ $05
	JSL HexDec_SetupStripe 
	LDA #$00 : STA $7F837D+4+(0*2)+0,x
	LDA #$01 : STA $7F837D+4+(1*2)+0,x
	LDA #$02 : STA $7F837D+4+(2*2)+0,x
	LDA #$03 : STA $7F837D+4+(3*2)+0,x
	LDA #!StatusBar_TilePropRed
	STA $7F837D+4+(0*2)+1,x
	STA $7F837D+4+(1*2)+1,x
	STA $7F837D+4+(2*2)+1,x
	STA $7F837D+4+(3*2)+1,x
	SEP #$10
;Same but on bottom row (stripe 2)
	LDA.b #30
	STA $00
	LDA.b #31
	STA $01
	LDA #$05
	STA $02
	STZ $03
	LDA #$03
	STA $04
	STZ $05
	JSL HexDec_SetupStripe 
	LDA #$00 : STA $7F837D+4+(0*2)+0,x
	LDA #$01 : STA $7F837D+4+(1*2)+0,x
	LDA #$02 : STA $7F837D+4+(2*2)+0,x
	LDA #$03 : STA $7F837D+4+(3*2)+0,x
	LDA #!StatusBar_TilePropRed
	STA $7F837D+4+(0*2)+1,x
	STA $7F837D+4+(1*2)+1,x
	STA $7F837D+4+(2*2)+1,x
	STA $7F837D+4+(3*2)+1,x
	SEP #$10
;Vertical write (stripe 3)
	LDA.b #15
	STA $00
	LDA.b #30
	STA $01
	LDA #$05
	STA $02
	LDA.b #%10000000
	STA $03
	LDA #$03
	STA $04
	STZ $05
	JSL HexDec_SetupStripe
	LDA #$00 : STA $7F837D+4+(0*2)+0,x
	LDA #$01 : STA $7F837D+4+(1*2)+0,x
	LDA #$02 : STA $7F837D+4+(2*2)+0,x
	LDA #$03 : STA $7F837D+4+(3*2)+0,x
	LDA #!StatusBar_TilePropRed
	STA $7F837D+4+(0*2)+1,x
	STA $7F837D+4+(1*2)+1,x
	STA $7F837D+4+(2*2)+1,x
	STA $7F837D+4+(3*2)+1,x
	
	SEP #$30		;&gt;Failsafe
	RTL
</pre></div><br><br>
And the results viewed on the tilemap viewer (the yellow lines represents the tilemap screen border), assuming you are not using any layer 3 backgrounds:<br>
<img src="Readme_Files/32x32Layer3Tilemap_StripeWraps.png">
		</li>
		<li>It is easier to write too many tiles at once to cause v-blank overflows; black bars flickering at the top of the screen (especially if written
		every frame). Status bars and overworld border+	patches would transfer RAM to VRAM data via DMA transfer, which reduces the risk of v-blank overflows.<br><br>
		
		One way to avoid this is only write when a tile change is needed. For example: If you have a symbol indicating something like a coin symbol before the number,
		then only the number can be written every frame while the two symbols before it only needs to be written once.</li><br>
		
		<li>Be careful not to write stripe data during a &ldquo;COURSE CLEAR!&rdquo; text is on screen when the player completes the level, as vanilla SMW writes the
		message at a <b>fixed location</b> in the stripe data (see code at <kbd>$05CCCB</kbd>). You can check RAM <kbd>$1493</kbd> and <kbd>%1426</kbd> (latter is for message box,
		as a failsafe just in case that also is placed in a fixed location):
<div class="CodeBlock" style="height: 180px"><pre>	LDA $1493|!addr		;&gt;Goal timer
	ORA $1426|!addr		;&gt;Message box (to me, I did experienced screen went black except for the layer 3, I kept this here anyways just in case)
	BEQ .SafeToWrite	;&gt;0 = None of the above are active, Nonzero: Any of above are active.
	.NotSafeToWrite
		;[...]
		RTL
	.SafeToWrite
		;Code to write your stripe tiles here
		;[...]
		RTL</pre></div>
		</li>
	</ul>
</div>

After calling that, all you have to do is write your tile data to <kbd>$7F837D+4,x</kbd> (XY register will be 16-bit) and beyond, but be careful not to overwrite the terminating byte (and potentially the bytes after) if this is your last stripe within a frame.
Just like the Super Status Bar patch and OWB+, its tile data format is &ldquo;2-bytes together&rdquo;. Unlike the status bar however, you absolutely must write the tile properties bytes, because whatever location in the stripe data to be written on may not
always be initialized, causing possible garbage tile properties.</p>

<p>Also just like sprite OAM patch, almost everything is the same except you are no longer writing to the status bar, also, note that since writing
tiles to the stripe have &ldquo;dynamic&rdquo; location since this is a table, thus the way you write them is different.</p>

<p>8-bit, 2 digits:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0					;&gt;0 = no, 1 = yes

	main:
	.StripeNumberTest
		LDA.b #!Layer3Stripe_TestDisplayElement_PosX	;\Position
		STA $00						;|
		LDA.b #!Layer3Stripe_TestDisplayElement_PosY	;|
		STA $01						;/
		LDA #$05					;\Layer
		STA $02						;/
		STZ $03						;&gt;D and RLE
		LDA.b #$02-1					;\Number of tiles
		STA $04						;|
		STZ $05						;/
		JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
		
		PHX						;&gt;Push 16-bit stripe index
		SEP #$30					;&gt;8-bit AXY
		LDA !Freeram_ValueDisplay1_1Byte		;&gt;Convert this number to BCD
		JSL HexDec_EightBitHexDec			;&gt;Get digits, A = 1s, X = 10s
		STX $00						;&gt;Store 10s in $00 for later
		REP #$10					;\Pull 16-bit stripe index
		PLX						;/
		STA.l $7F837D+6,x				;&gt;Write 1s place
		LDA $00						;&gt;if you are using status bar patches, STX $xxxxxx will not work.
		if !RemoveLeadingZeroes != 0
			BNE ..NotLeadingZero
			LDA #!StatusBarBlankTile
			..NotLeadingZero
		endif
		STA.l $7F837D+4,x				;&gt;Write 10s place
		
		LDA.b #!StatusBar_TileProp			;\Write tile properties
		STA.l $7F837D+4+1,x				;|
		STA.l $7F837D+6+1,x				;/
		SEP #$30
		RTL
</pre></div>
</p>
<p>
8-bit, 3 digits:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0					;&gt;0 = no, 1 = yes

	main:
	.StripeNumberTest
		LDA.b #!Layer3Stripe_TestDisplayElement_PosX	;\Position
		STA $00						;|
		LDA.b #!Layer3Stripe_TestDisplayElement_PosY	;|
		STA $01						;/
		LDA #$05					;\Layer
		STA $02						;/
		STZ $03						;&gt;D and RLE
		LDA.b #$03-1					;\Number of tiles
		STA $04						;|
		STZ $05						;/
		JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
		
		PHX						;&gt;Push 16-bit stripe index
		SEP #$30					;&gt;8-bit AXY
		LDA !Freeram_ValueDisplay1_1Byte		;&gt;Convert this number to BCD
		JSL HexDec_EightBitHexDec3Digits		;&gt;Obtain 3 digits in A (1s), X (10s) and Y (100s).
		STX $00						;&gt;Store 10s in $00 for later
		STY $01						;&gt;Store the 100s in $01 for later
		REP #$10					;\Pull 16-bit stripe index
		PLX						;/
		STA.l $7F837D+8,x				;&gt;Write 1s place
		if !RemoveLeadingZeroes == 0
			LDA $01					;\100s
			STA.l $7F837D+4,x			;/
			LDA $00					;\10s
			STA.l $7F837D+6,x			;/
		else
			..HandleHundreds
				LDA $01
				BNE ...HundredsNotZero
				
				...NoHundreds
					LDA #!StatusBarBlankTile
					STA.l $7F837D+4,x
					BRA ..HandleTens
				...HundredsNotZero
					STA.l $7F837D+4,x
					BRA ..HandleTens_WriteTens
			..HandleTens
				LDA $00
				BNE ...WriteTens
				
				...NoTens
					LDA #!StatusBarBlankTile
					BRA ..HandleDigitsDone
				...WriteTens
					LDA $00
			..HandleDigitsDone
					STA.l $7F837D+6,x
		endif
		
		LDA.b #!StatusBar_TileProp			;\Write tile properties
		STA.l $7F837D+4+1,x				;|
		STA.l $7F837D+6+1,x				;|
		STA.l $7F837D+8+1,x				;/
		SEP #$30
		RTL
</pre></div></p>

<p>16-bit N-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0					;&gt;0 = no, 1 = yes
!NumberOfDigitsDisplayed = 3					;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

	main:
	.StripeNumberTest
		LDA.b #!Layer3Stripe_TestDisplayElement_PosX	;\Position
		STA $00						;|
		LDA.b #!Layer3Stripe_TestDisplayElement_PosY	;|
		STA $01						;/
		LDA #$05					;\Layer
		STA $02						;/
		STZ $03						;&gt;D and RLE
		LDA.b #!NumberOfDigitsDisplayed-1		;\Number of tiles
		STA $04						;|
		STZ $05						;/
		JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
		
		PHX						;&gt;Push 16-bit stripe index
		SEP #$30					;&gt;8-bit AXY
		LDA !Freeram_ValueDisplay1_2Bytes		;\Convert this number to BCD
		STA $00						;|
		LDA !Freeram_ValueDisplay1_2Bytes+1		;|
		STA $01						;/
		JSL HexDec_SixteenBitHexDecDivision		;&gt;Digits stored at !Scratchram_16bitHexDecOutput
		if !RemoveLeadingZeroes != 0
			JSL HexDec_RemoveLeadingZeroes16Bit 	;&gt;Leading spaces, not zeroes
		endif
		REP #$20
		LDA $01,S					;\$00-$01: Stripe index, will be used for following loop to write each pair of bytes
		STA $00						;/(LDA $xx,s merely reads data in stack, which is better than PLX : STX $xx : PHX)
		SEP #$20
		REP #$10
		..WriteToStripe
			LDX #$0000
			...Loop
				LDA !Scratchram_16bitHexDecOutput+$04-(!NumberOfDigitsDisplayed-1),x
				PHX
				LDX $00					;&gt;X = current stripe tile index
				STA.l $7F837D+4,x
				LDA.b #!StatusBar_TileProp		;\Tile props
				STA.l $7F837D+4+1,x			;/
				PLX					;&gt;X = what digit from 16-bit hexdec
				....Next
					INC $00				;\Next stripe tile index
					INC $00				;/
					INX				;&gt;Next digit
					CPX.w #!NumberOfDigitsDisplayed	;\If 5th digit written, no more.
					BCC ...Loop			;/
		SEP #$20			;\8-bit A
		REP #$10			;/
		PLX				;&gt;Pull stripe index, into X
		SEP #$30
		RTL
</pre></div></p>

<p>32-bit N-digit:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!RemoveLeadingZeroes = 0					;&gt;0 = no, 1 = yes

;When handling the number of digits, be careful not to have !NumberOfDigitsDisplayed be greater than !Setting_32bitHexDec_MaxNumberOfDigits
;(the number digits stored in each byte in !Scratchram_32bitHexDecOutput), else garbage will appear.
	!NumberOfDigitsDisplayed = 9		;&gt;How many digits, enter 1-10 (pointless if you enter less than 5).


	main:
	.StripeNumberTest
		LDA.b #!Layer3Stripe_TestDisplayElement_PosX	;\Position
		STA $00						;|
		LDA.b #!Layer3Stripe_TestDisplayElement_PosY	;|
		STA $01						;/
		LDA #$05					;\Layer
		STA $02						;/
		STZ $03						;&gt;D and RLE
		LDA.b #!NumberOfDigitsDisplayed-1		;\Number of tiles
		STA $04						;|
		STZ $05						;/
		JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
		
		PHX						;&gt;Push 16-bit stripe index
		REP #$20
		LDA !Freeram_ValueDisplay1_4Bytes
		STA $00
		LDA !Freeram_ValueDisplay1_4Bytes+2
		STA $02
		SEP #$30
		JSL HexDec_ThirtyTwoBitHexDecDivision
		if !RemoveLeadingZeroes != 0
			JSL HexDec_RemoveLeadingZeroes32Bit
		endif
		REP #$30
		PLA						;&gt;Pull 16-bit stripe index
		CLC						;\$00-$02: Address of tile data to write (TileDataAddressToWrite = Stripe_Data_Index + $7F837D + 4)
		ADC.w #$7F837D+4				;|
		STA $00						;|
		SEP #$30					;|
		LDA #$7F					;|
		STA $02						;/

	;Write to stripe:
		LDX #(!NumberOfDigitsDisplayed-1)		;&gt;Digits left to write, -1, and 0-based
		LDY #((!NumberOfDigitsDisplayed-1)*2)		;&gt;Which tile data
		-
		LDA (!Scratchram_32bitHexDecOutput)+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
		STA [$00],y
		LDA.b #!StatusBar_TileProp
		INY						;\Next byte over to write properties
		STA [$00],y					;|
		DEY						;/
		DEY #2						;\Loop until all tiles written.
		DEX						;|
		BPL -						;/
	RTL
</pre></div>
</p>
<p>
16-bit N-digit with left/right aligned:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!DisplayTwoNumbers = 1								;&gt;0 = only the first number, 1 = display 2.
!RightAligned = 0								;&gt;0 = left, 1 = right.
!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).

;Don't touch these
	;This is needed to find how many tiles will be written and how they are positioned in the stripe data.
	;Also used when clearing tiles.
		!NumberOfCharactersMaxedMinus1 = !NumberOfDigitsDisplayed-1		;&gt;Maximum character index (-1 because 0-based indexing)
		if !DisplayTwoNumbers != 0
			!NumberOfCharactersMaxedMinus1 = (!NumberOfDigitsDisplayed*2)+1-1
			;^Maximum index of characters (e.g 5 digits is a value of 10 because 5*2 (times 2 because we display 2 numbers), plus 1 because of the slash character, minus 1 because 0-based indexing)
		endif
	;Figure out positions
		if !RightAligned == 0
			!Stripe_X_Pos = !Layer3Stripe_TestDisplayElement_PosX				;\Stripe tile position (left aligned)
			!Stripe_Y_Pos = !Layer3Stripe_TestDisplayElement_PosY				;/
		else
			!Stripe_X_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosX		;\Stripe tile position (right-aligned)
			!Stripe_Y_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosY		;/
		endif
	;Detect user trying to make a right-aligned single number (which avoids unnecessarily uses suppress leading zeroes)
		!IsUsingRightAlignedSingleNumber = and(notequal(!RightAligned, 0),equal(!DisplayTwoNumbers, 0))
;Code below
	main:
	.NumberDisplayTest
	if !IsUsingRightAlignedSingleNumber == 0
		if !DisplayTwoNumbers == 0
			;Number to string.
				;Process HexDec
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay1_2Bytes		;|
					STA $00						;|
					SEP #$20					;|
					JSL HexDec_SixteenBitHexDecDivision		;/
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
		else
			;First number
				;Process HexDec
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay1_2Bytes		;|
					STA $00						;|
					SEP #$20					;|
					JSL HexDec_SixteenBitHexDecDivision		;/
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
			;"/" symbol
					LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
					STA !Scratchram_CharacterTileTable,x		;/
					INX						;&gt;Next character position.
			;Second number
				;Process HexDec
					PHX						;&gt;Push X because it gets modified by the HexDec routine.
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay2_2Bytes				;|
					STA $00						;|
					SEP #$20					;|
					JSL HexDec_SixteenBitHexDecDivision		;/
					PLX						;&gt;Restore.
				;Remove leading zeroes and have it as a character table
					JSL HexDec_SupressLeadingZeros			;&gt;Write the digits (without leading zeroes) starting at position 0.
		endif
		;Write to stripe
			PHX						;&gt;push number of characters
			if !RightAligned == 0
				LDA.b #!Stripe_X_Pos					;\Position
			else
				LDA.b #!Stripe_X_Pos-!NumberOfCharactersMaxedMinus1
			endif
			STA $00						;|
			LDA.b #!Stripe_Y_Pos				;|
			STA $01						;/
			LDA #$05					;\Layer
			STA $02						;/
			STZ $03						;&gt;D and RLE
			LDA.b #!NumberOfCharactersMaxedMinus1		;\Number of tiles -1
			STA $04						;|(create a line of tiles whose number is a maximum number of characters to allow tile clearing)
			STZ $05						;/
			JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
			;Write starting address of empty stripe data we set to write to
				;RAM $7F837D,x after using "SetupStripe" locates
				REP #$20			;\$00-$02: Address of of open stripe data (tile data's TTTTTTTT).
				TXA				;|$03-$05: Address of of open stripe data (tile data's YXPCCCTT).
				CLC				;|
				ADC.w #$7F837D+4		;|Take X, the stripe index, add by #$7F8381
				STA $00				;|and store it at $00, since we are doing "Indirect Long" 
				INC				;|
				STA $03				;|
				SEP #$30			;|
				LDA #$7F			;|
				STA $02				;|
				STA $05				;/
				LDA.b #!StatusBar_TileProp	;\Props (WriteStringDigitsToHUD uses $06 to write)
				STA $06				;/
			;Clear tiles (blank tiles by default), so that leftover characters will disappear.
				LDY.b #!NumberOfCharactersMaxedMinus1*2
				-
				LDA #!StatusBarBlankTile		;\Clear tiles
				STA [$00],y				;/
				LDA.b #!StatusBar_TileProp		;\Set tile properties
				STA [$03],y				;/
				DEY #2
				BPL -
			PLX						;&gt;Pull number of characters
			;Prevent writing too much characters.
				CPX.b #!NumberOfCharactersMaxedMinus1+2		;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..StringTooLong				;/not being cleared from the previous code.
			if !RightAligned != 0
				;Find the rightmost position
				;Formula: StringPosition = (NumberOfCharactersMax - 1) - (NumberOfCharacters - 1)
				;
				;Processed in this order:
				;
				;StringPosition = -(NumberOfCharacters - 1) + (NumberOfCharactersMax - 1)
				REP #$20
				TXA						;\Clear high byte just in case
				AND #$00FF					;/
				DEC						;&gt;(NumberOfCharacters - 1)
				EOR #$FFFF					;\*(-1)
				INC						;/
				CLC						;\+ NumberOfCharactersMax
				ADC.w #!NumberOfCharactersMaxedMinus1		;/
				ASL						;&gt;*2 because each tile have 2 bytes
				PHA						;&gt;Save this offset for tile properties
				CLC						;\Offset from tile position
				ADC $00						;|
				STA $00						;|
				PLA						;|
				CLC						;|
				ADC $03						;|
				STA $03						;/
				SEP #$20					
			endif
			JSL HexDec_WriteStringDigitsToHUDFormat2
		..StringTooLong
	else
		LDA.b #!Stripe_X_Pos-(!NumberOfDigitsDisplayed-1)	;\Position
		STA $00							;|
		LDA.b #!Stripe_Y_Pos					;|
		STA $01							;/
		LDA #$05						;\Layer
		STA $02							;/
		STZ $03							;&gt;D and RLE
		LDA.b #!NumberOfDigitsDisplayed-1			;\Number of tiles
		STA $04							;|
		STZ $05							;/
		JSL HexDec_SetupStripe					;&gt;X (16-bit): The index position to write stripe data
		PHX						;&gt;Push 16-bit stripe index
		SEP #$30					;&gt;8-bit AXY
		LDA !Freeram_ValueDisplay1_2Bytes		;\Convert this number to BCD
		STA $00						;|
		LDA !Freeram_ValueDisplay1_2Bytes+1		;|
		STA $01						;/
		JSL HexDec_SixteenBitHexDecDivision		;&gt;Digits stored at !Scratchram_16bitHexDecOutput
		JSL HexDec_RemoveLeadingZeroes16Bit		;&gt;Leading spaces, not zeroes
		REP #$20
		LDA $01,S					;\$00-$01: Stripe index, will be used for following loop to write each pair of bytes
		STA $00						;/(LDA $xx,s merely reads data in stack, which is better than PLX : STX $xx : PHX)
		SEP #$20
		REP #$10
		..WriteToStripe
			LDX.w #$0000
			...Loop
				LDA !Scratchram_16bitHexDecOutput+4-(!NumberOfDigitsDisplayed-1),x
				PHX
				LDX $00						;&gt;X = current stripe tile index
				STA.l $7F837D+4,x
				LDA.b #!StatusBar_TileProp			;\Tile props
				STA.l $7F837D+4+1,x				;/
				PLX						;&gt;X = what digit from 16-bit hexdec
				....Next
					INC $00					;\Next stripe tile index
					INC $00					;/
					INX					;&gt;Next digit
					CPX.w #!NumberOfDigitsDisplayed		;\If ones digit written, no more.
					BCC ...Loop				;/
		SEP #$20			;\8-bit A
		REP #$10			;/
		PLX				;&gt;Pull stripe index, into X
		SEP #$30
	endif
	RTL
</pre></div>
</p>

<p>
32-bit N-digit with left and right aligned:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"


!DisplayTwoNumbers = 0								;&gt;0 = only the first number, 1 = display 2.
!RightAligned = 1								;&gt;0 = left, 1 = right.
!NumberOfDigitsDisplayed = 5							;&gt;How many digits, enter 1-5 (pointless if you enter less than 3).


;Don't touch unless you know what you're doing.
	;This is needed to find how many tiles will be written and how they are positioned in the stripe data.
	;Also used when clearing tiles.
		if !RightAligned == 0
			!Stripe_X_Pos = !Layer3Stripe_TestDisplayElement_PosX				;\Stripe tile position (left aligned)
			!Stripe_Y_Pos = !Layer3Stripe_TestDisplayElement_PosY				;/
		else
			!Stripe_X_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosX		;\Stripe tile position (right-aligned)
			!Stripe_Y_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosY		;/
		endif
	;This is needed to find how many tiles will be written and how they are positioned in the stripe data.
	;Also used when clearing tiles.
		!NumberOfCharactersMaxedMinus1 = !NumberOfDigitsDisplayed-1		;&gt;Maximum character index (-1 because 0-based indexing)
		if !DisplayTwoNumbers != 0
			!NumberOfCharactersMaxedMinus1 = (!NumberOfDigitsDisplayed*2)+1-1
			;^Maximum index of characters (e.g 5 digits is a value of 10 because 5*2 (times 2 because we display 2 numbers), plus 1 because of the slash character, minus 1 because 0-based indexing)
		endif
	;Detect user trying to make a right-aligned single number (which avoids unnecessarily uses suppress leading zeroes)
		!IsUsingRightAlignedSingleNumber = and(notequal(!RightAligned, 0),equal(!DisplayTwoNumbers, 0))
;Code below
	main:
	.NumberDisplayTest
	if !IsUsingRightAlignedSingleNumber == 0
		if !DisplayTwoNumbers == 0
			;Number to string.
				;Process HexDec
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay1_4Bytes		;|
					STA $00						;|
					LDA !Freeram_ValueDisplay1_4Bytes+2		;|
					STA $02						;|
					SEP #$20					;|
					JSL HexDec_ThirtyTwoBitHexDecDivision		;/
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros32Bit		;&gt;Write the digits (without leading zeroes) starting at position 0.
		else
			;First number
				;Process HexDec
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay1_4Bytes		;|
					STA $00						;|
					LDA !Freeram_ValueDisplay1_4Bytes+2		;|
					STA $02						;|
					SEP #$20					;|
					JSL HexDec_ThirtyTwoBitHexDecDivision		;/
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros32Bit		;&gt;Write the digits (without leading zeroes) starting at position 0.
			;"/" symbol
					LDA #!StatusBarSlashCharacterTileNumb		;\Slash symbol.
					STA !Scratchram_CharacterTileTable,x		;/
					INX						;&gt;Next character position.
			;Second number
				;Process HexDec
					PHX						;&gt;Push X because it gets modified by the HexDec routine.
					REP #$20					;\Convert a given number to decimal digits.
					LDA !Freeram_ValueDisplay2_4Bytes		;|
					STA $00						;|
					LDA !Freeram_ValueDisplay2_4Bytes+2		;|
					STA $02						;|
					SEP #$20					;|
					JSL HexDec_ThirtyTwoBitHexDecDivision		;/
					PLX						;&gt;Restore.
				;Remove leading zeroes and have it as a character table
					JSL HexDec_SupressLeadingZeros32Bit		;&gt;Write the digits (without leading zeroes) starting at position 0.
		endif
		;Write to stripe
			PHX						;&gt;push number of characters
			if !RightAligned == 0
				LDA.b #!Stripe_X_Pos					;\Position
			else
				LDA.b #!Stripe_X_Pos-!NumberOfCharactersMaxedMinus1
			endif
			STA $00						;|
			LDA.b #!Stripe_Y_Pos				;|
			STA $01						;/
			LDA #$05					;\Layer
			STA $02						;/
			STZ $03						;&gt;D and RLE
			LDA.b #!NumberOfCharactersMaxedMinus1		;\Number of tiles -1
			STA $04						;|(create a line of tiles whose number is a maximum number of characters to allow tile clearing)
			STZ $05						;/
			JSL HexDec_SetupStripe				;&gt;X (16-bit): The index position to write stripe data
			;Write starting address of empty stripe data we set to write to
				;RAM $7F837D,x after using "SetupStripe" locates
				REP #$20			;\$00-$02: Address of of open stripe data (tile data's TTTTTTTT).
				TXA				;|$03-$05: Address of of open stripe data (tile data's YXPCCCTT).
				CLC				;|
				ADC.w #$7F837D+4		;|Take X, the stripe index, add by #$7F8381
				STA $00				;|and store it at $00, since we are doing "Indirect Long" 
				INC				;|
				STA $03				;|
				SEP #$30			;|
				LDA #$7F			;|
				STA $02				;|
				STA $05				;/
				LDA.b #!StatusBar_TileProp	;\Props (WriteStringDigitsToHUD uses $06 to write)
				STA $06				;/
			;Clear tiles (blank tiles by default), so that leftover characters will disappear.
				LDY.b #!NumberOfCharactersMaxedMinus1*2
				-
				LDA #!StatusBarBlankTile		;\Clear tiles
				STA [$00],y				;/
				LDA.b #!StatusBar_TileProp		;\Set tile properties
				STA [$03],y				;/
				DEY #2
				BPL -
			PLX						;&gt;Pull number of characters
			;Prevent writing too much characters.
				CPX.b #!NumberOfCharactersMaxedMinus1+2		;\Failsafe to avoid writing more characters than intended would write onto tiles
				BCS ..StringTooLong				;/not being cleared from the previous code.
			if !RightAligned != 0
				;Find the rightmost position
				;Formula: StringPosition = (NumberOfCharactersMax - 1) - (NumberOfCharacters - 1)
				;
				;Processed in this order:
				;
				;StringPosition = -(NumberOfCharacters - 1) + (NumberOfCharactersMax - 1)
				REP #$20
				TXA						;\Clear high byte just in case
				AND #$00FF					;/
				DEC						;&gt;(NumberOfCharacters - 1)
				EOR #$FFFF					;\*(-1)
				INC						;/
				CLC						;\+ NumberOfCharactersMax
				ADC.w #!NumberOfCharactersMaxedMinus1		;/
				ASL						;&gt;*2 because each tile have 2 bytes
				PHA						;&gt;Save this offset for tile properties
				CLC						;\Offset from tile position
				ADC $00						;|
				STA $00						;|
				PLA						;|
				CLC						;|
				ADC $03						;|
				STA $03						;/
				SEP #$20					
			endif
			JSL HexDec_WriteStringDigitsToHUDFormat2
		..StringTooLong
	else
		LDA.b #!Stripe_X_Pos-(!NumberOfDigitsDisplayed-1)	;\Position
		STA $00							;|
		LDA.b #!Stripe_Y_Pos					;|
		STA $01							;/
		LDA #$05						;\Layer
		STA $02							;/
		STZ $03							;&gt;D and RLE
		LDA.b #!NumberOfDigitsDisplayed-1			;\Number of tiles
		STA $04							;|
		STZ $05							;/
		JSL HexDec_SetupStripe					;&gt;X (16-bit): The index position to write stripe data
		PHX							;&gt;Push 16-bit stripe index
		REP #$20						;\Convert a given number to decimal digits.
		SEP #$10						;|
		LDA !Freeram_ValueDisplay1_4Bytes			;|
		STA $00							;|
		LDA !Freeram_ValueDisplay1_4Bytes+2			;|
		STA $02							;|
		SEP #$30						;|
		JSL HexDec_ThirtyTwoBitHexDecDivision			;/
		JSL HexDec_RemoveLeadingZeroes32Bit
		REP #$20
		LDA $01,S					;\$00-$01: Stripe index, will be used for following loop to write each pair of bytes
		STA $00						;/(LDA $xx,s merely reads data in stack, which is better than PLX : STX $xx : PHX)
		SEP #$20					;&gt;8-bit A
		REP #$10					;&gt;16-bit XY
		..WriteToStripe
			LDX.w #$0000
			...Loop
				LDA (!Scratchram_32bitHexDecOutput)+(!Setting_32bitHexDec_MaxNumberOfDigits-1)-(!NumberOfDigitsDisplayed-1),x
				PHX
				LDX $00						;&gt;X = current stripe tile index
				STA.l $7F837D+4,x
				LDA.b #!StatusBar_TileProp			;\Tile props
				STA.l $7F837D+4+1,x				;/
				PLX						;&gt;X = what digit from 16-bit hexdec
				....Next
					INC $00					;\Next stripe tile index
					INC $00					;/
					INX					;&gt;Next digit
					CPX.w #!NumberOfDigitsDisplayed		;\If ones digit written, no more.
					BCC ...Loop				;/
		SEP #$20			;\8-bit A
		REP #$10			;/
		PLX				;&gt;Pull stripe index, into X
		SEP #$30			;&gt;8-bit AXY
		RTL
	endif
	RTL
</pre></div>
</p>
<p>Percentage:
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

!Default_PercentagePrecision = 2
 ;^0 = show whole number precisions, 1 = 1/10 of a percentage, 2 = 1/100. Not to be confused
 ; with !Scratchram_PercentageFixedPointPrecision.
!CapAt100 = 1								;&gt;0 = allow percentage to display values greater than 100, 1 = cap at 100.
!RightAligned = 0							;&gt;0 = left-aligned, 1 = right-aligned.


;Don't touch
	if !RightAligned == 0
		!Stripe_X_Pos = !Layer3Stripe_TestDisplayElement_PosX	;\Stripe tile position (left aligned)
		!Stripe_Y_Pos = !Layer3Stripe_TestDisplayElement_PosY	;/
	else
		!Stripe_X_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosX	;\Stripe tile position (right-aligned)
		!Stripe_Y_Pos = !Layer3Stripe_TestDisplayRightAlignedNumber_PosY	;/
	endif
	!NumberOfCharactersMaxedMinus1 = 3 ;&gt;"100%" is 4 characters, which means a value of 3 should be used
	if !Default_PercentagePrecision == 1
		!NumberOfCharactersMaxedMinus1 = 5 ;&gt;"100.0%" is 6 characters, which means a value of 5 should be used
	elseif !Default_PercentagePrecision == 2
		!NumberOfCharactersMaxedMinus1 = 6 ;&gt;"100.00%". 7 -&gt; 6
	endif

main:
	;Setup stripe
		if !RightAligned == 0
			LDA.b #!Stripe_X_Pos					;\Position
		else								;|
			LDA.b #!Stripe_X_Pos-!NumberOfCharactersMaxedMinus1	;|
		endif								;|
		STA $00								;|
		LDA.b #!Stripe_Y_Pos						;|
		STA $01								;/
		LDA #$05							;\Layer
		STA $02								;/
		STZ $03								;&gt;D and RLE
		LDA.b #!NumberOfCharactersMaxedMinus1				;\Number of tiles -1
		STA $04								;|
		STZ $05								;/
		JSL HexDec_SetupStripe						;&gt;X (16-bit): The index position to write stripe data
		PHX								;&gt;Push 16-bit stripe index
		SEP #$30
	;Submit fraction
		REP #$20
		LDA !Freeram_ValueDisplay1_2Bytes
		STA !Scratchram_PercentageQuantity
		LDA !Freeram_ValueDisplay2_2Bytes
		STA !Scratchram_PercentageMaxQuantity
		SEP #$20
		LDA #!Default_PercentagePrecision
		STA !Scratchram_PercentageFixedPointPrecision
		JSL HexDec_ConvertToPercentage
	;Prevent display percentages greater than 100%.
	;Note to self:
	;100				= $00000064
	;1000 (display as ***.*)	= $000003E8
	;10000 (display as ***.**)	= $00002710
		if !CapAt100 != 0
			.CheckExceed100
				REP #$30
				LDX.w #(10**(!Default_PercentagePrecision+2))
				;Check the high word of the XXXX (RAM_00-RAM_03 = $XXXXYYYY)
					LDA $02			;\Any nonzero digits in the high word would mean at least
					BNE ..Cap100		;/65536 ($00010000), which is guaranteed over 100/1000/10000.
				;Check low word
					TXA
					CMP $00			;\Max compares with RAM_00
					BCS ..Under		;/If Max &gt;= RAM_00 or RAM_00 is lower, don't set it to max.
				
				..Cap100
					TXA
					STA $00
				..Under
				SEP #$30
		endif
	;Avoid displaying 0% and 100% misleadingly if close to them.
		CPY #$00
		BEQ .Normal
		CPY #$01
		BEQ .RoundTo1Percent
		CPY #$02
		BCS .RoundTo99Percent		;&gt;Just in case somehow Y is a value $03 or more
		
		.RoundTo1Percent
			REP #$20
			LDA.w #1
			STA $00
			STZ $02
			SEP #$20
			BRA .Normal
		.RoundTo99Percent
			REP #$20
			LDA.w #(10**(!Default_PercentagePrecision+2)-1)		;&gt;99%, 99.9%, or 99.99%.
			STA $00
			STZ $02
			SEP #$20
		.Normal
	;Display the number.
		if !Default_PercentagePrecision == 0
			;Since it is very unlikely you display percentage greater than 100 (assuming you set !Default_PercentagePrecision to 0), you mostly
			;likely just need to use $00 (8-bit) alone.
			if !RightAligned == 1 ;right aligned, whole percentage
				.DisplayNumbers
					LDA $00
					JSL HexDec_EightBitHexDec3Digits			;&gt;A: 1s, X: 10s, Y: 100s
					STA $00							;\Store digits because we have X being the stripe index.
					STX $01							;|$00: 1s, $01: 10s, $02: 100s
					STY $02							;/
					REP #$10
					PLX							;&gt;Pull 16-bit stripe index
					STA $7F8381+(2*2),x					;&gt;Write 1s place
					..HandleHundreds
						LDA $02						;\Is the 100s place nonzero? Yes, then leave that and the 10s showing up
						BNE ...HundredsNonZero				;/No, then erase the 100s digit and see if 10s is also part of the leading 0s.
					...NoHundreds
						LDA #!StatusBarBlankTile			;\Erase the 100s digit
						STA $7F8381+(0*2),x				;/
						BRA ..HandleTens				;&gt;Check if the next digit is also part of the leading zero.
					...HundredsNonZero
						STA $7F8381+(0*2),x				;&gt;Write 100s place
						LDA $01
						BRA ..HandleTens_WriteTens			;&gt;If at least 100, 10s shouldn't be omitted.
					..HandleTens
						LDA $01						;\Is the 10s place nonzero? Yes, then leave the 10s place showing up
						BNE ...WriteTens				;/No, then erase the 10s.
						...NoTens
							LDA #!StatusBarBlankTile			;&gt;If 0, replace 10s digit with blank.
						...WriteTens
							STA $7F8381+(1*2),x				;&gt;Write 10s place
						LDA #!StatusBar_TileProp
						STA $7F8381+(0*2)+1,x
						STA $7F8381+(1*2)+1,x
						STA $7F8381+(2*2)+1,x
						STA $7F8381+(3*2)+1,x
					LDA #!StatusBarPercentTile
					STA $7F8381+(3*2),x
					SEP #$30
					RTL
			elseif !RightAligned == 0 ;Left aligned, whole percentage
				STZ $01
				JSL HexDec_SixteenBitHexDecDivision
				;!Scratchram_16bitHexDecOutput+0 to !Scratchram_16bitHexDecOutput+4: hexdec output
				;!Scratchram_16bitHexDecOutput+5 to !Scratchram_16bitHexDecOutput+7: address of stripe to clear tiles
				LDA #$7F					;\$00-$02: Stripe to write tile numbers
				STA !Scratchram_16bitHexDecOutput+5+2		;|$03-$05: Stripe to write tile properties
				REP #$30					;|
				PLX						;|&gt;Pull 16-bit stripe index
				TXA						;|
				CLC						;|
				ADC.w #$7F8381					;|
				STA !Scratchram_16bitHexDecOutput+5		;|
				PHX						;|&gt;Push 16-bit stripe index
				SEP #$30					;/
				.ClearTiles
				;Clear the tiles. To prevent leftover "ghost" tiles that should've
				;disappear when the number of digits decreases (so when "10" becomes "9",
				;won't display "90"). Also setup tile properties when enabled.
					LDY.b #(4-1)*2
					..Loop
						LDA #!StatusBarBlankTile
						STA [!Scratchram_16bitHexDecOutput+5],y
						LDA.b #!StatusBar_TileProp
						INY
						STA [!Scratchram_16bitHexDecOutput+5],y
						DEY
						DEY #2
						BPL ..Loop
				.StatusBarString
				;Remove leading zeroes and have it as a character table
					LDX #$00					;&gt;Start at character position 0.
					JSL HexDec_SupressLeadingZeros			;&gt;Digits at !Scratchram_CharacterTileTable
				;Write percent symbol after the number
					LDA #!StatusBarPercentTile			;\Write percent symbol
					STA !Scratchram_CharacterTileTable,x		;/
					INX
					CPX.b #5		;&gt;"XXX%" is 4 characters, so 5 and up is too long.
					BCS ..TooMuchDigits
					STX $07			;&gt;Save number of characters
				;Write to layer 3
					LDA #$7F			;\$00-$02: Stripe to write tile numbers
					STA $02				;|$03-$05: Stripe to write tile properties
					STA $05				;|
					REP #$30			;|
					PLX				;|&gt;Pull 16-bit stripe index
					TXA				;|
					CLC				;|
					ADC.w #$7F8381			;|
					STA $00				;|
					INC				;|
					STA $03				;|
					SEP #$30			;/
					LDA.b #!StatusBar_TileProp	;\Tile Properties
					STA $06				;/
					LDX $07			;&gt;Number of characters
					JSL HexDec_WriteStringDigitsToHUDFormat2
					RTL
					..TooMuchDigits
						PLX
						RTL
			endif
		else
			JSL HexDec_SixteenBitHexDecDivision
			if !RightAligned == 1 ;Right aligned, N-digit precision
				if !Default_PercentagePrecision == 1
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast2
					;XXX.X%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/10s place
					REP #$10
					PLX
					LDA !Scratchram_16bitHexDecOutput+$01 : STA $7F8381+(0*2),x	;&gt;100s
					LDA !Scratchram_16bitHexDecOutput+$02 : STA $7F8381+(1*2),x	;&gt;10s
					LDA !Scratchram_16bitHexDecOutput+$03 : STA $7F8381+(2*2),x	;&gt;1s
					LDA #$24 : STA $7F8381+(3*2),x					;&gt;.
					LDA !Scratchram_16bitHexDecOutput+$04 : STA $7F8381+(4*2),x	;&gt;1/10ths
					LDA #!StatusBarPercentTile : STA $7F8381+(5*2),x		;&gt;%
					LDA #!StatusBar_TileProp
					STA $7F8381+(0*2)+1,x						;&gt;100s
					STA $7F8381+(1*2)+1,x						;&gt;10s
					STA $7F8381+(2*2)+1,x						;&gt;1s
					STA $7F8381+(3*2)+1,x						;&gt;.
					STA $7F8381+(4*2)+1,x						;&gt;1/10s
					STA $7F8381+(5*2)+1,x						;&gt;%
				elseif !Default_PercentagePrecision == 2
					JSL HexDec_RemoveLeadingZeroes16BitLeaveLast3
					;XXX.XX%
					;DigitsFromHexDec (IntegerDigits) -&gt; DisplayedDigits
					;!Scratchram_16bitHexDecOutput+$00 (10000s place) -&gt; 100s place
					;!Scratchram_16bitHexDecOutput+$01 (1000s place) -&gt; 10s place
					;!Scratchram_16bitHexDecOutput+$02 (100s place) -&gt; 1s place
					;!Scratchram_16bitHexDecOutput+$03 (10s place) -&gt; 1/10s place
					;!Scratchram_16bitHexDecOutput+$04 (1s place) -&gt; 1/100s place
					REP #$10
					PLX
					LDA !Scratchram_16bitHexDecOutput+$00 : STA $7F8381+(0*2),x	;&gt;100s
					LDA !Scratchram_16bitHexDecOutput+$01 : STA $7F8381+(1*2),x	;&gt;10s
					LDA !Scratchram_16bitHexDecOutput+$02 : STA $7F8381+(2*2),x	;&gt;1s
					LDA #$24 : STA $7F8381+(3*2)					;&gt;.
					LDA !Scratchram_16bitHexDecOutput+$03 : STA $7F8381+(4*2),x	;&gt;1/10s
					LDA !Scratchram_16bitHexDecOutput+$04 : STA $7F8381+(5*2),x	;&gt;1/100s
					LDA #!StatusBarPercentTile : STA $7F8381+(6*2),x		;&gt;%
					LDA #!StatusBar_TileProp
					STA $7F8381+(0*2)+1,x						;&gt;100s
					STA $7F8381+(1*2)+1,x						;&gt;10s
					STA $7F8381+(2*2)+1,x						;&gt;1s
					STA $7F8381+(3*2)+1,x						;&gt;.
					STA $7F8381+(4*2)+1,x						;&gt;1/10s
					STA $7F8381+(5*2)+1,x						;&gt;1/100s
					STA $7F8381+(6*2)+1,x						;&gt;%
				endif
				SEP #$30
				RTL
			elseif !RightAligned == 0 ;left aligned, N-digit precision
				LDA #$7F					;\!Scratchram_16bitHexDecOutput+5 to !!Scratchram_16bitHexDecOutput+7: RAM containing stripe tile data to write
				STA !Scratchram_16bitHexDecOutput+5+2		;|
				REP #$30					;|
				PLX						;|&gt;Pull 16-bit stripe index
				TXA						;|
				CLC						;|
				ADC.w #$7F837D+4				;|
				STA !Scratchram_16bitHexDecOutput+5		;|
				PHX						;|&gt;Push 16-bit stripe index
				SEP #$30					;/
				.ClearTiles
				;Clear the tiles. To prevent leftover "ghost" tiles that should've
				;disappear when the number of digits decreases (so when "10" becomes "9",
				;won't display "90"). Also setup tile properties when enabled.
					LDY.b #!NumberOfCharactersMaxedMinus1*2
					..Loop
						LDA #!StatusBarBlankTile
						STA [!Scratchram_16bitHexDecOutput+5],y
						LDA.b #!StatusBar_TileProp
						INY
						STA [!Scratchram_16bitHexDecOutput+5],y
						DEY
						DEY #2
						BPL ..Loop
				
				LDX #$00
				if !Default_PercentagePrecision == 1
					LDA #$24						;\Decimal point
					STA $09							;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast2	;&gt;Characters are now in !Scratchram_CharacterTileTable
				elseif !Default_PercentagePrecision == 2
					LDA #$24						;\Decimal point
					STA $09							;/
					JSL HexDec_SupressLeadingZerosPercentageLeaveLast3	;&gt;Characters are now in !Scratchram_CharacterTileTable
				endif
				LDA #!StatusBarPercentTile			;\Write percent symbol
				STA !Scratchram_CharacterTileTable,x		;/
				INX
				CPX.b #!NumberOfCharactersMaxedMinus1+2
				BCS ..TooMuchDigits
				STX $07						;&gt;Save number of characters
				;Write to layer 3
					LDA #$7F				;\$00-$02: Tile numbers address
					STA $02					;|$03-$05: Tile properties address
					STA $05					;|
					REP #$30				;|
					PLX					;|
					TXA					;|
					CLC					;|
					ADC.w #$7F837D+4			;|
					STA $00					;|
					INC					;|
					STA $03					;/
					SEP #$30
					LDA #!StatusBar_TileProp		;\Tile properties to use
					STA $06					;/
					LDX $07
					JSL HexDec_WriteStringDigitsToHUDFormat2
					RTL
				..TooMuchDigits
				PLX
				RTL
			endif
		endif
</pre></div>
</p>

<p>Repeating icons
<div class="CodeBlock"><pre>
incsrc "../StatusBarRoutinesDefines/Defines.asm"
incsrc "../StatusBarRoutinesDefines/StatusBarDefines.asm"

;Notes:
; - Positioning here is always the top-leftmost icon, regardless of the fill direction
; - Because this is a stripe image, subroutine "WriteRepeatedSymbolsWriteVertically"
;   (including its "Format2" variant) should not be used. Stripe in vertical write
;   mode will automatically write one tile downwards for every next tile.

!MaxNumberOfSymbols = 5			;&gt;Total number of symbols (maximum)
!Vertical = $00				;&gt;$00 = horizontal, $80 = vertical. Best not to use other values
!Leftwards = 1				;&gt;0 = left-to-right (top to bottom if vertical) when filling, 1 = right-to-left (bottom to top if vertical) when filling.

;Code below

	main:
	LDA.b #!Layer3Stripe_TestDisplayElement_PosX
	STA $00
	LDA.b #!Layer3Stripe_TestDisplayElement_PosY
	STA $01
	LDA #$05
	STA $02
	LDA.b #!Vertical
	STA $03
	LDA.b #!MaxNumberOfSymbols-1
	STA $04
	STZ $05
	JSL HexDec_SetupStripe		;&gt;X (16-bit): index of stripe
	
	
	LDA !Freeram_ValueDisplay1_1Byte		;\$00: How many filled icons
	STA $00						;/
	LDA #!MaxNumberOfSymbols			;\$01: How many total icons
	STA $01						;/
	LDA #!StatusBar_RepeatedSymbols_EmptyTile	;\$02: Empty tile number
	STA $02						;/
	LDA #!StatusBar_RepeatedSymbols_FullTile	;\$03: Full tile number
	STA $03						;/
	LDA.b #!StatusBar_RepeatedSymbols_EmptyProp	;\$07: Empty tile property
	STA $07						;/
	LDA.b #!StatusBar_RepeatedSymbols_FullProp	;\$08: Full tile property
	STA $08						;/
	LDA #$7F					;\$04-$06: Address for tile numbers to write to
	STA $06						;|$09-$0B: Address for tile number properties to write to
	STA $0B						;|
	REP #$20					;|
	TXA						;|
	CLC						;|
	ADC.w #$7F837D+4				;|
	STA $04						;|
	INC						;|
	STA $09						;|
	SEP #$30					;/

	if !Leftwards == 0
		JSL RepeatedSymbols_WriteRepeatedSymbolsFormat2
	else
		JSL RepeatedSymbols_WriteRepeatedSymbolsLeftwardsFormat2
	endif
	RTL
</pre></div>
</p>
For a timer display, like the status bar version, is in a seperate ASM file due to having large number of lines and making use of UAT2.0's extra bytes feature.
<hr>
<h2 id="OtherNotes"><a href="#OtherNotesBack">^</a>Other notes</h2>
<ul>
	<li>
		<p>When using SA-1 ROM, SMW's vanilla status bar RAM address is relocated to address bank <kbd>$40</kbd> while its absolute address ($12<u>3456</u>)
		are kept the same ($7E0EF9 &rightarrow; $400EF9).</p>
	</li>
	<li>
		<p>SMW does actually have a 32-bit (up to 999,999, but <abbr title="6 changeable digits, there are 7 displayed, but the rightmost 0 is static.">up to 6 digits</abbr>) HexDec handling routine, this is used for displaying the score and strangely, the bonus stars. Unlike the 2-digit simple HexDec,
		it is handled from left-to-right (just <a href="#Left2RightHexDec">like this</a>), and by subtracting by 10<sup>(NumberOfDigits-1) &rightarrow; 0</sup> repeatedly. Here is what I mean with the example of a number 123456 ($01E240).
		Note that the score is stored internally as the displayed number, divided by 10 (&ldquo;1234560&rdquo; is 123456, which that is $01E240 in hex, stored in little endian as
		<kbd>[$40, $E2, $01]</kbd>, not as $12D680/<kbd>[$80, $D6, $12]</kbd>.), here is an example showing that same number:
<div class="CodeBlock"><pre>;Subtract by 100000 ($0186A0) repeatedly to get the 100000s place
$01E240 (123456, SubtractCount = 0) -&gt; 
$005BA0 (023456, SubtractCount = <u>1</u>), cannot subtract anymore, so SubtractCount (1) is the correct 100000s place.

;Subtract by 10000 ($002710) to get the 10000s place:
$005BA0 (023456, SubtractCount = 0, notice that this number is used after the previous repeated subtraction) -&gt;
$003490 (013456, SubtractCount = 1) -&gt;
$000D80 (003456, SubtractCount = <u>2</u>), cannot subtract anymore, so SubtractCount (2) is the correct 10000s place.

;Subtract by 1000 ($0003E8) to get the 1000s place:
$000D80 (003456, SubtractCount = 0) -&gt;
$000998 (002456, SubtractCount = 1) -&gt;
$0005B0 (001456, SubtractCount = 2) -&gt;
$0001C8 (000456, SubtractCount = <u>3</u>), cannot subtract anymore, so SubtractCount (3) is the correct 1000s place.

;Subtract by 100 ($000064) to get the 100s place:
$0001C8 (000456, SubtractCount = 0) -&gt;
$000164 (000356, SubtractCount = 1) -&gt;
$000100 (000256, SubtractCount = 2) -&gt;
$00009C (000156, SubtractCount = 3) -&gt;
$000038 (000056, SubtractCount = <u>4</u>), cannot subtract anymore, so SubtractCount (4) is the correct 100s place.

;Subtract by 10 ($00000A) to get the 10s place:
$000038 (000056, SubtractCount = 0) -&gt;
$00002E (000046, SubtractCount = 1) -&gt;
$000024 (000036, SubtractCount = 2) -&gt;
$00001A (000026, SubtractCount = 3) -&gt;
$000010 (000016, SubtractCount = 4) -&gt;
$000006 (000006, SubtractCount = <u>5</u>), cannot subtract anymore, so SubtractCount (5) is the correct 10s place.

;Subtract by 1 ($000001) to get the 1s place:
;(Wow, you can just write the low byte of this 24-bit difference into the ones place, because after the MOD 10
;(subtract by 10 repeatedly), this difference is ALWAYS the 1s place since you are essentially dividing by 1.
$000006 (000006, SubtractCount = 0) -&gt;
$000005 (000005, SubtractCount = 1) -&gt;
$000004 (000004, SubtractCount = 2) -&gt;
$000003 (000003, SubtractCount = 3) -&gt;
$000002 (000002, SubtractCount = 4) -&gt;
$000001 (000001, SubtractCount = 5) -&gt;
$000000 (000000, SubtractCount = <u>6</u>), cannot subtract anymore, so SubtractCount (6) is the correct 1s place.
</pre></div>
The routine is handled at address $009012-$009044, and the 10<sup>n</sup> table at $008FFA-$009011. This one is better
than doing digits from right to left using subtraction by 10 only (I mean, a number 999999 would take ages to finally get
the ones place, and then another ages to get the 10s, and so on. Which is why subtraction by <i>powers</i> of 10 from
left to right is much faster).</p>
	</li>
</ul>
<h2 id="Credits"><a href="#CreditsBack">^</a>Credits</h2>
<ul>
	<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Mozilla</a>: For documenting a lot of Javascript for me to make these scripts in this package</li>
	<li>StackOverflow for various help relating javascript. And thanks to Elias Zamaria and T.J. Crowder on <a href="https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript">this post</a>
	to let me display a javascript-generated number using comma notation to seperate digits into groups of 3.</li>
	<li><a href="https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/">KeesTalksTech</a> and <a href="https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click">sanwebe</a> for a javascript code that allow the codes
	presented here to be easily selected by simply double-clicking on them.</li>
	
	
</ul>
<script>
	function Calculate() {
		//SMW status bar table
			let LoopCount = 0n
			let CurrentRowYPos = 2n
			let StartOfLineXPos = 2n
			let OnSecondRow = 0n
			let StatusBarAddress = ParseBigIntValue("0EF9", 16)
			let StatusBarAddress_SA1 = ParseBigIntValue("6EF9", 16)
			let StatusBarAddress_SA1Long = ParseBigIntValue("400EF9", 16)
			
			let StatusBarDefaultTileAddress = ParseBigIntValue("008C89", 16)
			
			let OutputTable = document.getElementById("SMWStatusBarTable")
			while (OutputTable.lastElementChild) {
				OutputTable.removeChild(OutputTable.lastElementChild)
			}
			
			let TableRow_Header = document.createElement("tr")
			
			let TableHeaderCell_Index = document.createElement("th")
			TableHeaderCell_Index.appendChild(document.createTextNode("Tile number/index"))
			TableRow_Header.appendChild(TableHeaderCell_Index)
			
			let TableHeaderCell_Coordinate = document.createElement("th")
			TableHeaderCell_Coordinate.appendChild(document.createTextNode("Coordinate"))
			TableRow_Header.appendChild(TableHeaderCell_Coordinate)
			
			let TableHeaderCell_StatusBarRAM = document.createElement("th")
			TableHeaderCell_StatusBarRAM.appendChild(document.createTextNode("RAM address (Vanilla/SA-1/SA-1 long)"))
			TableRow_Header.appendChild(TableHeaderCell_StatusBarRAM)
			
			let TableHeaderCell_DefaultTiles = document.createElement("th")
			TableHeaderCell_DefaultTiles.appendChild(document.createTextNode("default tiles and properties ROM address (%TTTTTTTT, %YXPCCCTT)"))
			TableRow_Header.appendChild(TableHeaderCell_DefaultTiles)
			
			OutputTable.appendChild(TableRow_Header)
			
			for (let i=0n; i<55n; i++) {
				if (i == 28n) {
					let TableRow_SecondRowMsg = document.createElement("tr")
					let TableCell_SecondRowMsg = document.createElement("th")
					TableCell_SecondRowMsg.appendChild(document.createTextNode("Second line"))
					TableCell_SecondRowMsg.colSpan = "4"
					TableRow_SecondRowMsg.appendChild(TableCell_SecondRowMsg)
					OutputTable.appendChild(TableRow_SecondRowMsg)
				
					CurrentRowYPos = 3n
					StartOfLineXPos = 3n
					OnSecondRow = 28n
				}
				let TableRow_TileData = document.createElement("tr")
				
				let TableCell_TileIndex = document.createElement("td")
				TableCell_TileIndex.style.fontFamily = "monospace"
				TableCell_TileIndex.appendChild(document.createTextNode(i.toString(10).padStart(2, "0") + " ($" + i.toString(16).toUpperCase().padStart(2, "0") + ")"))
				TableRow_TileData.appendChild(TableCell_TileIndex)
				
				let TableCell_Coordinate = document.createElement("td")
				TableCell_Coordinate.style.fontFamily = "monospace"
				TableCell_Coordinate.appendChild(document.createTextNode("(" + (StartOfLineXPos+i-OnSecondRow).toString(10) + ", " + CurrentRowYPos.toString(10) + "), Hex: ($" + (StartOfLineXPos+i-OnSecondRow).toString(16).toUpperCase() + ", $" + CurrentRowYPos.toString(16).toUpperCase() + ")" ))
				TableRow_TileData.appendChild(TableCell_Coordinate)
				
				let TableCell_Addresses = document.createElement("td")
				TableCell_Addresses.style.fontFamily = "monospace"
				TableCell_Addresses.appendChild(document.createTextNode("$" + (StatusBarAddress+i).toString(16).toUpperCase().padStart(4, "0") + "/$" + (StatusBarAddress_SA1+i).toString(16).toUpperCase().padStart(4, "0") + "/$" + (StatusBarAddress_SA1Long+i).toString(16).toUpperCase().padStart(6, "0")))
				TableRow_TileData.appendChild(TableCell_Addresses)
				
				let TableCell_DefaultTiles = document.createElement("td")
				TableCell_DefaultTiles.style.fontFamily = "monospace"
				TableCell_DefaultTiles.appendChild(document.createTextNode("$" + (StatusBarDefaultTileAddress+(i*2n)).toString(16).toUpperCase().padStart(6, "0") + ", $" + (StatusBarDefaultTileAddress+(i*2n)+1n).toString(16).toUpperCase().padStart(6, "0")))
				TableRow_TileData.appendChild(TableCell_DefaultTiles)
				
				
				OutputTable.appendChild(TableRow_TileData)
			}
		
	}
	function pad(num, size) {
		let s = num+"";
		while (s.length < size) s = "0" + s;
		return s;
	}
	function ParseBigIntValue(string, radix) {
		//Acts more closely to parseInt, unlike other methods (other functions, like CorrectBinBigIntValue)
		//this works with bigInt.
		let Output = 0n
		let NegativeNumber = 1n
		if ((/^-/).test(string)) {
			NegativeNumber = -1n
		}
		let DigitPart = string.substring((string.search(/[0-9a-zA-Z]/)))
		switch (radix) {
			//decimal
				default:
				if ((/^-?\d+$/).test(string)) {
					Output = BigInt(string)
				}
				break
			//Hexadecimal
				case 16:
				case "0x":
				case "0X":
				if ((/^-?[0-9A-Fa-f]+$/).test(string)) {
					Output = BigInt("0x" + DigitPart) * NegativeNumber
				}
				break
			//Binary
				case 2:
				case "0b":
				case "0B":
				if ((/^-?[01]+$/).test(string)) {
					Output = BigInt("0b" + DigitPart) * NegativeNumber
				}
		
		}
		return Output
	}
//These makes all <pre>...</pre> have an effect that double-clicking will select all the text
//in it, to make it easy to copy code and paste it in your ASM stuff.
//
//Credit:
// https://keestalkstech.com/2014/04/click-to-select-all-on-the-pre-element/
// https://www.sanwebe.com/2014/04/select-all-text-in-element-on-click
document.addEventListener('dblclick', e => {
  let pre = getClosest(e.target, "PRE");
  if (pre && e.ctrlKey) {
    let range = new Range();
    range.selectNodeContents(pre);
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  }
});

function getClosest(el, tagName) {
  tagName = tagName && tagName.toUpperCase();

  if (!tagName || !el)
    return null;

  do
    if (el.nodeName === tagName)
      return el;
  while (el = el.parentNode);

  return null;
}

</script>