<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
		</style>
	</head>
<body onload="GenerateOAMTable()">
<a href="../HowToUseTheStatusBar.html#OAMNotes">Back</a>

<p>This list every byte the OAM slot corresponding to what RAM they use for SMW.<p>
<ul>
<li>Slot: Refers to which “unit” of a 1-increment index.</li><br>

<li>Index: Refers to a 4-increment index.</li><br>

<li>Normal Sprite OAM slot numbering and Normal sprite OAM index numbering: Refers to normal sprites
that are part of the 12-slot (22 for sa-1), not extended, minor extended, or cluster. They
use $15EA,x ($33A2,x under SA-1) which is an offset from <i>halfway</i> from the table (they load
starting at $0300 and $0460 instead of $0200 and $0420)</li><br>
</ul>

<p>Keep in mind is that when 2 or more OAMs overlap, the tile with the lower OAM slot (also lower indexes in RAM) will have priority
over the others (so OAM tile 0 will appear in front of OAM tile 1).</p>

The majority of stuff uses OAM indexing of increment-4, but one RAM, $0420 uses increments of 1.
To convert OAM indexing to 1-increment, take that index, transfer it to A, and perform LSR #2,
which will divide the value by 4, and it converts the value into increments of 1, then transfer
it back to either X or Y, example:
<table><tr><td><pre>PHY		;&gt;This likely will be in a loop and we do not want to lose our OAM index loop
TYA
LSR #2
TAY
&lt;do something&gt;
STA $0420,y
PLY</pre></td></tr></table><br>
And when we are done with writing OAM, before calling <kbd>%FinishOAMWrite()</kbd> (or <kbd>JSL $01B7B3</kbd>), have the accumulator (<kbd>A</kbd>) be a value representing how many tiles, minus 1, and have Y be <kbd>$FF</kbd> to indicate that the sprite has both 8x8 and 16x16 sizes.<br><br>

The reason for the increment-4 is because the data is formatted like this:
<table>
	<tr>
		<th>Relative address</th>
		<th>OAM number</th>
		<th>Byte containing info</th>
	</tr>
	<tr>
		<td><kbd>Address+0</kbd></td>
		<td rowspan="4">OAM tile 0</td>
		<td>low 8-bit X position</td>
	</tr>
	<tr>
		<td><kbd>Address+1</kbd></td>
		<td>8-bit Y position</td>
	</tr>
	<tr>
		<td><kbd>Address+2</kbd></td>
		<td>Tile number</td>
	</tr>
	<tr>
		<td><kbd>Address+3</kbd></td>
		<td>Properties (YXPPCCCT)</td>
	</tr>
	<tr>
		<td><kbd>Address+4</kbd></td>
		<td rowspan="4">OAM tile 1</td>
		<td>low 8-bit X position</td>
	</tr>
	<tr>
		<td><kbd>Address+5</kbd></td>
		<td>8-bit Y position</td>
	</tr>
	<tr>
		<td><kbd>Address+6</kbd></td>
		<td>Tile number</td>
	</tr>
	<tr>
		<td><kbd>Address+7</kbd></td>
		<td>Properties (YXPPCCCT)</td>
	</tr>
	<tr>
		<td colspan="3">Continues until...</td>
	</tr>
	<tr>
		<td><kbd>Address+508</kbd></td>
		<td rowspan="4">OAM tile 127</td>
		<td>low 8-bit X position</td>
	</tr>
	<tr>
		<td><kbd>Address+509</kbd></td>
		<td>8-bit Y position</td>
	</tr>
	<tr>
		<td><kbd>Address+510</kbd></td>
		<td>Tile number</td>
	</tr>
	<tr>
		<td><kbd>Address+511</kbd></td>
		<td>Properties (YXPPCCCT)</td>
	</tr>
</table><br>
Which means assuming the RAM data stored in SMW (<kbd>$7E0200-$7E03FF </kbd>) and using the second half (<kbd>$7E0300-$7E03FF</kbd>), we use data like this:
<table><tr><td><pre>STA $0300|!addr,y	;&gt;low 8-bit X position
...
STA $0301|!addr,y	;&gt;Y position
...
STA $0302|!addr,y	;&gt;Tile number
...
STA $0303|!addr,y	;&gt;Properties (YXPPCCCT)
...
INY			;\Next OAM index (increment by 4 for the whole OAM slot)
INY			;|
INY			;|
INY			;/
&lt;Loop condition to check if all tiles written&gt;
</pre></td></tr></table><br>

But what about the OAM extra bits (X position high bit and the size)? Well, they're stored in a separate table, <kbd>$7E0400-$7E041F</kbd> for the compressed version (same format as the
PPU register format (each byte contains 4 OAM slot: <kbd>%SXSXSXSX</kbd> where each <kbd>SX</kbd> starting from the low bits corresponds to each OAM index starting at the lowest OAM slot
number), and <kbd>$7E0420-$7E049F</kbd> (each byte is an OAM slot, formatted as <kbd>%000000SX</kbd>).<kbd>X</kbd> here means the high bit of the X position, and <kbd>S</kbd> is the size bit<br><br>

You really don't have to worry about the high bit X position since after finishing your OAM write and calling <kbd>%FinishOAMWrite()</kbd> (or <kbd>JSL $01B7B3</kbd>) will automatically handle the high bit X position for you.
However, we still need to worry about the size bit as previously mentioned.

<table id="Output"></table>

<script>
	function GenerateOAMTable() {
		let Address_0200 = BigInt("0x0200")
		let Address_0420 = BigInt("0x0420")
		let OutputTable = document.getElementById("Output")
	
		let TableRow_Header = document.createElement("tr")
		
		let TableRow_Header_SlotNum = document.createElement("th")
		TableRow_Header_SlotNum.appendChild(document.createTextNode("Slot"))
		TableRow_Header.appendChild(TableRow_Header_SlotNum)
		
		let TableRow_Header_Index = document.createElement("th")
		TableRow_Header_Index.appendChild(document.createTextNode("Index (x4)"))
		TableRow_Header.appendChild(TableRow_Header_Index)
		
		let TableRow_Header_153A_Numbering = document.createElement("th")
		TableRow_Header_153A_Numbering.appendChild(document.createTextNode("Normal sprite OAM slot numbering (by $15EA/$33A2)"))
		TableRow_Header.appendChild(TableRow_Header_153A_Numbering)
		
		let TableRow_Header_153A_NumberingTimes4 = document.createElement("th")
		TableRow_Header_153A_NumberingTimes4.appendChild(document.createTextNode("Normal sprite OAM index numbering (by $15EA/$33A2)"))
		TableRow_Header.appendChild(TableRow_Header_153A_NumberingTimes4)
		
		let TableRow_Header_0200_Addressing = document.createElement("th")
		TableRow_Header_0200_Addressing.appendChild(document.createTextNode("$0200"))
		TableRow_Header.appendChild(TableRow_Header_0200_Addressing)
		
		let TableRow_Header_0420_Addressing = document.createElement("th")
		TableRow_Header_0420_Addressing.appendChild(document.createTextNode("$0420"))
		TableRow_Header.appendChild(TableRow_Header_0420_Addressing)
		
		OutputTable.appendChild(TableRow_Header)
		
		for (let SlotNumberCount = 0n; SlotNumberCount < 128n; SlotNumberCount++) {
			let TableRow_Slot = document.createElement("tr")
			
			let TableCell_Slot = document.createElement("td")
			TableCell_Slot.style.fontFamily = "monospace"
			TableCell_Slot.style.whiteSpace = "nowrap"
			TableCell_Slot.style.textAlign = "center"
			TableCell_Slot.appendChild(document.createTextNode(SlotNumberCount.toString(10).padStart(3, "0") + " ($" + SlotNumberCount.toString(16).toUpperCase().padStart(2, "0") + ")"))
			TableRow_Slot.appendChild(TableCell_Slot)
			
			let TableCell_IndexTimes4 = document.createElement("td")
			TableCell_IndexTimes4.style.fontFamily = "monospace"
			TableCell_IndexTimes4.style.whiteSpace = "nowrap"
			TableCell_IndexTimes4.style.textAlign = "center"
			TableCell_IndexTimes4.appendChild(document.createTextNode((SlotNumberCount*4n).toString(10).padStart(3, "0") + " ($" + (SlotNumberCount*4n).toString(16).toUpperCase().padStart(4, "0") + ")"))
			TableRow_Slot.appendChild(TableCell_IndexTimes4)
			
			let TableCell_15EA = document.createElement("td")
			TableCell_15EA.style.fontFamily = "monospace"
			TableCell_15EA.style.whiteSpace = "nowrap"
			TableCell_15EA.style.textAlign = "center"
			let Text_15EA = "N/A"
			if (SlotNumberCount >= 64n) {
				let SecondHalfNumbering = SlotNumberCount - 64n
				Text_15EA = SecondHalfNumbering.toString(10).padStart(2, "0") + " ($" + SecondHalfNumbering.toString(16).toUpperCase().padStart(2, "0") + ")"
			}
			TableCell_15EA.appendChild(document.createTextNode(Text_15EA))
			TableRow_Slot.appendChild(TableCell_15EA)
			
			let TableCell_15EATimes4 = document.createElement("td")
			TableCell_15EATimes4.style.fontFamily = "monospace"
			TableCell_15EATimes4.style.whiteSpace = "nowrap"
			TableCell_15EATimes4.style.textAlign = "center"
			let Text_15EATimes4 = "N/A"
			if (SlotNumberCount >= 64n) {
				let SecondHalfNumbering = SlotNumberCount - 64n
				Text_15EATimes4 = (SecondHalfNumbering*4n).toString(10).padStart(3, "0") + " ($" + (SecondHalfNumbering*4n).toString(16).toUpperCase().padStart(2, "0") + ")"
			}
			TableCell_15EATimes4.appendChild(document.createTextNode(Text_15EATimes4))
			TableRow_Slot.appendChild(TableCell_15EATimes4)
			
			let TableCell_0200 = document.createElement("td")
			TableCell_0200.style.fontFamily = "monospace"
			TableCell_0200.style.whiteSpace = "nowrap"
			TableCell_0200.style.textAlign = "center"
			TableCell_0200.appendChild(document.createTextNode( "$" + (Address_0200 + (SlotNumberCount*4n)).toString(16).toUpperCase().padStart(4, "0") + "-$" + (Address_0200 + (SlotNumberCount*4n) + 3n).toString(16).toUpperCase().padStart(4, "0") ))
			TableRow_Slot.appendChild(TableCell_0200)
			
			let TableCell_0420 = document.createElement("td")
			TableCell_0420.style.fontFamily = "monospace"
			TableCell_0420.style.whiteSpace = "nowrap"
			TableCell_0420.style.textAlign = "center"
			TableCell_0420.appendChild(document.createTextNode( "$" + (Address_0420+SlotNumberCount).toString(16).toUpperCase().padStart(4, "0")))
			TableRow_Slot.appendChild(TableCell_0420)
			
			
			
			OutputTable.appendChild(TableRow_Slot)
		}
	}
</script>